<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 驱动之基础（一）Device-I/O | Matrix</title><meta name="author" content="CarlyleLiu"><meta name="copyright" content="CarlyleLiu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Memory Mapped IOGetting Access to the DeviceThis address should not be used directly. Instead, to get an address suitable for passing to the accessor functions described below, you should call ioremap">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 驱动之基础（一）Device-I&#x2F;O">
<meta property="og:url" content="https://carlyleliu.github.io/LinuxDriver/LinuxDriverBaseDeviceIO/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="Memory Mapped IOGetting Access to the DeviceThis address should not be used directly. Instead, to get an address suitable for passing to the accessor functions described below, you should call ioremap">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unsplash.it/1600/900?random&1641">
<meta property="article:published_time" content="2024-04-22T13:23:06.000Z">
<meta property="article:modified_time" content="2025-09-27T04:36:15.387Z">
<meta property="article:author" content="CarlyleLiu">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unsplash.it/1600/900?random&1641"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://carlyleliu.github.io/LinuxDriver/LinuxDriverBaseDeviceIO/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 驱动之基础（一）Device-I/O',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-27 12:36:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Matrix" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://unsplash.it/1600/900?random&amp;1641')"><nav id="nav"><span id="blog-info"><a href="/" title="Matrix"><span class="site-name">Matrix</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux 驱动之基础（一）Device-I/O</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-22T13:23:06.000Z" title="发表于 2024-04-22 21:23:06">2024-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-27T04:36:15.387Z" title="更新于 2025-09-27 12:36:15">2025-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/">Technology Blog</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/Linux/Driver/">Driver</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux 驱动之基础（一）Device-I/O"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Memory-Mapped-IO"><a href="#Memory-Mapped-IO" class="headerlink" title="Memory Mapped IO"></a>Memory Mapped IO</h1><h2 id="Getting-Access-to-the-Device"><a href="#Getting-Access-to-the-Device" class="headerlink" title="Getting Access to the Device"></a>Getting Access to the Device</h2><p>This address should not be used directly. Instead, to get an address suitable for passing to the accessor functions described below, you should call ioremap(). An address suitable for accessing the device will be returned to you.</p>
<p>After you’ve finished using the device (say, in your module’s exit routine), call iounmap() in order to return the address space to the kernel. Most architectures allocate new address space each time you call ioremap(), and they can run out unless you call iounmap().</p>
<span id="more"></span>
<h2 id="Accessing-the-device"><a href="#Accessing-the-device" class="headerlink" title="Accessing the device"></a>Accessing the device</h2><p>The part of the interface most used by drivers is reading and writing memory-mapped registers on the device. Linux provides interfaces to read and write 8-bit, 16-bit, 32-bit and 64-bit quantities. Due to a historical accident, these are named byte, word, long and quad accesses. Both read and write accesses are supported; there is no prefetch support at this time.</p>
<p>The functions are named readb(), readw(), readl(), readq(), readb_relaxed(), readw_relaxed(), readl_relaxed(), readq_relaxed(), writeb(), writew(), writel() and writeq().</p>
<p>Some devices (such as framebuffers) would like to use larger transfers than 8 bytes at a time. For these devices, the memcpy_toio(), memcpy_fromio() and memset_io() functions are provided. Do not use memset or memcpy on IO addresses; they are not guaranteed to copy data in order.</p>
<p>The read and write functions are defined to be ordered. That is the compiler is not permitted to reorder the I/O sequence. When the ordering can be compiler optimised, you can use __readb() and friends to indicate the relaxed ordering. Use this with care.</p>
<h1 id="Port-Space-Accesses"><a href="#Port-Space-Accesses" class="headerlink" title="Port Space Accesses"></a>Port Space Accesses</h1><h2 id="Port-Space-Explained"><a href="#Port-Space-Explained" class="headerlink" title="Port Space Explained"></a>Port Space Explained</h2><p>Another form of IO commonly supported is Port Space. This is a range of addresses separate to the normal memory address space. Access to these addresses is generally not as fast as accesses to the memory mapped addresses, and it also has a potentially smaller address space.</p>
<p>Unlike memory mapped IO, no preparation is required to access port space.</p>
<h2 id="Accessing-Port-Space"><a href="#Accessing-Port-Space" class="headerlink" title="Accessing Port Space"></a>Accessing Port Space</h2><p>Accesses to this space are provided through a set of functions which allow 8-bit, 16-bit and 32-bit accesses; also known as byte, word and long. These functions are inb(), inw(),inl(), outb(), outw() and outl().</p>
<p>Some variants are provided for these functions. Some devices require that accesses to their ports are slowed down. This functionality is provided by appending a _p to the end of the function. There are also equivalents to memcpy. The ins() and<br>outs() functions copy bytes, words or longs to the given port.</p>
<h1 id="iomem-pointer-tokens"><a href="#iomem-pointer-tokens" class="headerlink" title="__iomem pointer tokens"></a>__iomem pointer tokens</h1><p>The data type for an MMIO address is an <strong>iomem qualified pointer, such as void </strong>iomem *reg. On most architectures it is a regular pointer that points to a virtual memory address and can be offset or dereferenced, but in portable code, it must only be passed from and to functions that explicitly operated on an __iomem token, in particular the ioremap() and readl()/writel() functions. The ‘sparse’ semantic code checker can be used to verify that this is done correctly.</p>
<p>While on most architectures, ioremap() creates a page table entry for an uncached virtual address pointing to the physical MMIO address, some architectures require special instructions for MMIO, and the __iomem pointer just encodes the physical address or an offsettable cookie that is interpreted by readl()/writel().</p>
<h1 id="Differences-between-I-O-access-functions"><a href="#Differences-between-I-O-access-functions" class="headerlink" title="Differences between I/O access functions"></a>Differences between I/O access functions</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readq(), readl(), readw(), readb(), writeq(), writel(), writew(), writeb()</span><br></pre></td></tr></tbody></table></figure>
<p>These are the most generic accessors, providing serialization against other MMIO accesses and DMA accesses as well as fixed endianness for accessing little-endian PCI devices and on-chip peripherals. Portable device drivers should generally use these for any access to __iomem pointers.</p>
<p>Note that posted writes are not strictly ordered against a spinlock, see Documentation/driver-api/io_ordering.rst.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readq_relaxed(), readl_relaxed(), readw_relaxed(), readb_relaxed(),</span><br><span class="line">writeq_relaxed(), writel_relaxed(), writew_relaxed(), writeb_relaxed()</span><br></pre></td></tr></tbody></table></figure>
<p>On architectures that require an expensive barrier for serializing against DMA, these “relaxed” versions of the MMIO accessors only serialize against each other, but contain a less expensive barrier operation. A device driver might use these in a particularly performance sensitive fast path, with a comment that explains why the usage in a specific location is safe without the extra barriers.</p>
<p>See memory-barriers.txt for a more detailed discussion on the precise ordering guarantees of the non-relaxed and relaxed versions.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ioread64(), ioread32(), ioread16(), ioread8(),</span><br><span class="line">iowrite64(), iowrite32(), iowrite16(), iowrite8()</span><br></pre></td></tr></tbody></table></figure>
<p>These are an alternative to the normal readl()/writel() functions, with almost identical behavior, but they can also operate on __iomem tokens returned for mapping PCI I/O space with pci_iomap() or ioport_map(). On architectures that require special instructions for I/O port access, this adds a small overhead for an indirect function call implemented in lib/iomap.c, while on other architectures, these are simply aliases.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ioread64be(), ioread32be(), ioread16be()</span><br><span class="line">iowrite64be(), iowrite32be(), iowrite16be()</span><br></pre></td></tr></tbody></table></figure>
<p>These behave in the same way as the ioread32()/iowrite32() family, but with reversed byte order, for accessing devices with big-endian MMIO registers.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hi_lo_readq(), lo_hi_readq(), hi_lo_readq_relaxed(), lo_hi_readq_relaxed(),</span><br><span class="line">ioread64_lo_hi(), ioread64_hi_lo(), ioread64be_lo_hi(), ioread64be_hi_lo(),</span><br><span class="line">hi_lo_writeq(), lo_hi_writeq(), hi_lo_writeq_relaxed(), lo_hi_writeq_relaxed(),</span><br><span class="line">iowrite64_lo_hi(), iowrite64_hi_lo(), iowrite64be_lo_hi(), iowrite64be_hi_lo()</span><br></pre></td></tr></tbody></table></figure>
<p>Some device drivers have 64-bit registers that cannot be accessed atomically on 32-bit architectures but allow two consecutive 32-bit accesses instead. Since it depends on the particular device which of the two halves has to be accessed first, a helper is provided for each combination of 64-bit accessors with either low/high or high/low word ordering. A device driver must include either <linux io-64-nonatomic-lo-hi.h=""> or <linux io-64-nonatomic-hi-lo.h=""> to get the function definitions along with helpers that redirect the normal readq()/writeq() to them on architectures that do not provide 64-bit access natively.</linux></linux></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__raw_readq(), __raw_readl(), __raw_readw(), __raw_readb(),</span><br><span class="line">__raw_writeq(), __raw_writel(), __raw_writew(), __raw_writeb()</span><br></pre></td></tr></tbody></table></figure>
<p>These are low-level MMIO accessors without barriers or byteorder changes and architecture specific behavior. Accesses are usually atomic in the sense that a four-byte __raw_readl() does not get split into individual byte loads, but multiple consecutive accesses can be combined on the bus. In portable code, it is only safe to use these to access memory behind a device bus but not MMIO registers, as there are no ordering guarantees with regard to other MMIO accesses or even spinlocks. The byte order is generally the same as for normal memory, so unlike the other functions, these can be used to copy data between kernel memory and device memory.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inl(), inw(), inb(), outl(), outw(), outb()</span><br></pre></td></tr></tbody></table></figure>
<p>PCI I/O port resources traditionally require separate helpers as they are implemented using special instructions on the x86 architecture. On most other architectures, these are mapped to readl()/writel() style accessors internally, usually pointing to a fixed area in virtual memory. Instead of an __iomem pointer, the address is a 32-bit integer token to identify a port number. PCI requires I/O port access to be non-posted, meaning that an outb() must complete before the following code executes, while a normal writeb() may still be in progress. On architectures that correctly implement this, I/O port access is therefore ordered against spinlocks. Many non-x86 PCI host bridge implementations and CPU architectures however fail to implement non-posted I/O space on PCI, so they can end up being posted on such hardware.</p>
<p>In some architectures, the I/O port number space has a 1:1 mapping to __iomem pointers, but this is not recommended and device drivers should not rely on that for portability. Similarly, an I/O port number as described in a PCI base address register may not correspond to the port number as seen by a device driver. Portable drivers need to read the port number for the resource provided by the kernel.</p>
<p>There are no direct 64-bit I/O port accessors, but pci_iomap() in combination with ioread64/iowrite64 can be used instead.</p>
<h1 id="Device-memory-mapping-modes"><a href="#Device-memory-mapping-modes" class="headerlink" title="Device memory mapping modes"></a>Device memory mapping modes</h1><p>Some architectures support multiple modes for mapping device memory. ioremap_*() variants provide a common abstraction around these architecture-specific modes, with a shared set of semantics.</p>
<p>ioremap() is the most common mapping type, and is applicable to typical device memory (e.g. I/O registers). Other modes can offer weaker or stronger guarantees, if supported by the architecture. From most to least common, they are as follows:</p>
<h2 id="ioremap"><a href="#ioremap" class="headerlink" title="ioremap()"></a>ioremap()</h2><ul>
<li><p>Uncached（无缓存）：</p>
<p>   CPU-side caches are bypassed, and all reads and writes are handled directly by the device</p>
</li>
<li><p>No speculative operations（无预测执行，可以认为是无乱序执行）：</p>
<p>  the CPU may not issue a read or write to this memory, unless the instruction that does so has been reached in committed program flow.</p>
</li>
<li><p>No reordering（无重排序，可以理解为加了强内存屏障指令）：</p>
<p>  The CPU may not reorder accesses to this memory mapping with respect to each other. On some architectures, this relies on barriers in readl_relaxed()/writel_relaxed().</p>
</li>
<li><p>No repetition：</p>
<p>  The CPU may not issue multiple reads or writes for a single program instruction.</p>
</li>
<li><p>No write-combining（无写合并，cache 的一种策略）：</p>
<p>  Each I/O operation results in one discrete read or write being issued to the device, and multiple writes are not combined into larger writes. This may or may not be enforced when using __raw I/O accessors or pointer dereferences.</p>
</li>
<li><p>Non-executable：</p>
<p>  The CPU is not allowed to speculate instruction execution from this memory (it probably goes without saying, but you’re also not allowed to jump into device memory).</p>
</li>
</ul>
<h2 id="ioremap-wc"><a href="#ioremap-wc" class="headerlink" title="ioremap_wc()"></a>ioremap_wc()</h2><p>Maps I/O memory as normal memory with write combining. Unlike ioremap(),</p>
<ul>
<li>The CPU may speculatively issue reads from the device that the program didn’t actually execute, and may choose to basically read whatever it wants.   </li>
<li>The CPU may reorder operations as long as the result is consistent from the program’s point of view.   </li>
<li>The CPU may write to the same location multiple times, even when the program issued a single write.   </li>
<li>The CPU may combine several writes into a single larger write.   </li>
</ul>
<p>This mode is typically used for video framebuffers, where it can increase performance of writes. It can also be used for other blocks of memory in devices (e.g. buffers or shared memory), but care must be taken as accesses are not guaranteed to be ordered with respect to normal ioremap() MMIO register accesses without explicit barriers.</p>
<p>On a PCI bus, it is usually safe to use ioremap_wc() on MMIO areas marked as<br>IORESOURCE_PREFETCH, but it may not be used on those without the flag. For on-chip devices, there is no corresponding flag, but a driver can use ioremap_wc() on a device that is known to be safe.</p>
<h2 id="ioremap-wt"><a href="#ioremap-wt" class="headerlink" title="ioremap_wt()"></a>ioremap_wt()</h2><p>Maps I/O memory as normal memory with write-through caching. Like ioremap_wc(), but also</p>
<p>The CPU may cache writes issued to and reads from the device, and serve reads from that cache.</p>
<p>This mode is sometimes used for video framebuffers, where drivers still expect writes to reach the device in a timely manner (and not be stuck in the CPU cache), but reads may be served from the cache for efficiency. However, it is rarely useful these days, as framebuffer drivers usually perform writes only, for which ioremap_wc() is more efficient (as it doesn’t needlessly trash the cache). Most drivers should not use this.</p>
<h2 id="ioremap-np"><a href="#ioremap-np" class="headerlink" title="ioremap_np()"></a>ioremap_np()</h2><p>就像 ioremap() 一样，但明确请求非发布写语义。ioremap_np() 明确请求非发布语义，这意味着写入指令将不会在设备接收到写入数据之前完成。裸的 ioremap_np() 仅在某些架构上可用；在其他架构上，它始终返回 NULL。驱动程序通常不应使用它。</p>
<h2 id="ioremap-uc"><a href="#ioremap-uc" class="headerlink" title="ioremap_uc()"></a>ioremap_uc()</h2><p>它也将内存标记为非缓存，可移植驱动程序应避免使用 ioremap_uc()。</p>
<h2 id="ioremap-cache-（将-I-O-内存当作普通-RAM-使用，支持-cache）"><a href="#ioremap-cache-（将-I-O-内存当作普通-RAM-使用，支持-cache）" class="headerlink" title="ioremap_cache()（将 I/O 内存当作普通 RAM 使用，支持 cache）"></a>ioremap_cache()（将 I/O 内存当作普通 RAM 使用，支持 cache）</h2><p>ioremap_cache() effectively maps I/O memory as normal RAM. CPU write-back caches can be used, and the CPU is free to treat the device as if it were a block of RAM.</p>
<h1 id="Architecture-example"><a href="#Architecture-example" class="headerlink" title="Architecture example"></a>Architecture example</h1><p>Here is how the above modes map to memory attribute settings on the ARM64 architecture:</p>
<p>+————————————+——————————————————————+<br>| API                    | Memory region type and cacheability        |<br>+————————————+——————————————————————+<br>| ioremap_np()           | Device-nGnRnE                              |<br>+————————————+——————————————————————+<br>| ioremap()              | Device-nGnRE                               |<br>+————————————+——————————————————————+<br>| ioremap_uc()           | (not implemented)                          |<br>+————————————+——————————————————————+<br>| ioremap_wc()           | Normal-Non Cacheable                       |<br>+————————————+——————————————————————+<br>| ioremap_wt()           | (not implemented; fallback to ioremap)     |<br>+————————————+——————————————————————+<br>| ioremap_cache()        | Normal-Write-Back Cacheable                |<br>+————————————+——————————————————————+</p>
<p>说明：ARM64 将内存分为两种一种是 Device 类型、一种是 Normal</p>
<p>对于 Device 内存有：</p>
<ul>
<li><p>Gathering 或者 non Gathering (G or nG)：</p>
<p>  这个特性表示对多个 memory 的访问是否可以合并，如果是 nG，表示处理器必须严格按照代码中内存访问来进行，不能把两次访问合并成一次。例如：代码中有 2 次对同样的一个地址的读访问，那么处理器必须严格进行两次 read transaction。</p>
</li>
<li><p>Re-ordering (R or nR)：</p>
<p>  这个特性用来表示是否允许处理器对内存访问指令进行重排。nR 表示必须严格执行 program order。</p>
</li>
<li><p>Early Write Acknowledgement (E or nE)：</p>
<p>  PE 访问 memory 是有问有答的（更专业的术语叫做 transaction），对于 write 而言，PE 需要 write ack 操作以便确定完成一个 write transaction。为了加快写的速度，系统的中间环节可能会设定一些 write buffer。nE 表示写操作的 ack 必须来自最终的目的地而不是中间的 write buffer。</p>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《Linux Document》   </p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Driver/">Driver</a></div><div class="post_share"><div class="social-share" data-image="https://unsplash.it/1600/900?random&amp;1641" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/LinuxDriver/LinuxDriverBaseDMA-API/" title="Linux 驱动之基础（二）DMA-API"><img class="cover" src="https://unsplash.it/1600/900?random&amp;3638" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux 驱动之基础（二）DMA-API</div></div></a></div><div class="next-post pull-right"><a href="/LinuxDriver/LinuxUSBUACASYNC/" title="UAC（六）UAC 同步方式"><img class="cover" src="https://unsplash.it/1600/900?random&amp;8834" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UAC（六）UAC 同步方式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/LinuxDriver/LinuxDriverBaseDMA-API/" title="Linux 驱动之基础（二）DMA-API"><img class="cover" src="https://unsplash.it/1600/900?random&3638" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-02</div><div class="title">Linux 驱动之基础（二）DMA-API</div></div></a></div><div><a href="/LinuxDriver/LinuxDriverDeviceModule/" title="Linux 驱动之设备驱动模型"><img class="cover" src="https://unsplash.it/1600/900?random&7938" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-07</div><div class="title">Linux 驱动之设备驱动模型</div></div></a></div><div><a href="/LinuxDriver/LinuxDriverDeviceTree/" title="Linux 驱动之设备树"><img class="cover" src="https://unsplash.it/1600/900?random&9232" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-25</div><div class="title">Linux 驱动之设备树</div></div></a></div><div><a href="/LinuxDriver/LinuxDriverCCF/" title="Linux 驱动之 CCF 子系统"><img class="cover" src="https://unsplash.it/1600/900?random&890" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-05</div><div class="title">Linux 驱动之 CCF 子系统</div></div></a></div><div><a href="/LinuxDriver/LinuxDriverFileSystem/" title="Linux 驱动之文件系统"><img class="cover" src="https://unsplash.it/1600/900?random&7897" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-08</div><div class="title">Linux 驱动之文件系统</div></div></a></div><div><a href="/LinuxDriver/LinuxDriverGPIO/" title="Linux 驱动之 GPIO 子系统"><img class="cover" src="https://unsplash.it/1600/900?random&4238" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-05</div><div class="title">Linux 驱动之 GPIO 子系统</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CarlyleLiu</div><div class="author-info__description">CarlyleLiu’s Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/carlyleliu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/carlyleliu" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yyliushuai@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://twitter.com/yyliushuai" target="_blank" title="Twitter"><i class="fab fa-twitter" style="color: #24292e;"></i></a><a class="social-icon" href="https://youtube.com/carlyleliu" target="_blank" title="YouTube"><i class="fab fa-youtube" style="color: #24292e;"></i></a><a class="social-icon" href="https://instagram.com/blurredliu" target="_blank" title="Instagram"><i class="fab fa-instagram" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">next主题站 https://carlyleliu.github.io/next</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Memory-Mapped-IO"><span class="toc-number">1.</span> <span class="toc-text">Memory Mapped IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Getting-Access-to-the-Device"><span class="toc-number">1.1.</span> <span class="toc-text">Getting Access to the Device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Accessing-the-device"><span class="toc-number">1.2.</span> <span class="toc-text">Accessing the device</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Port-Space-Accesses"><span class="toc-number">2.</span> <span class="toc-text">Port Space Accesses</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Port-Space-Explained"><span class="toc-number">2.1.</span> <span class="toc-text">Port Space Explained</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Accessing-Port-Space"><span class="toc-number">2.2.</span> <span class="toc-text">Accessing Port Space</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iomem-pointer-tokens"><span class="toc-number">3.</span> <span class="toc-text">__iomem pointer tokens</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Differences-between-I-O-access-functions"><span class="toc-number">4.</span> <span class="toc-text">Differences between I&#x2F;O access functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Device-memory-mapping-modes"><span class="toc-number">5.</span> <span class="toc-text">Device memory mapping modes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ioremap"><span class="toc-number">5.1.</span> <span class="toc-text">ioremap()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioremap-wc"><span class="toc-number">5.2.</span> <span class="toc-text">ioremap_wc()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioremap-wt"><span class="toc-number">5.3.</span> <span class="toc-text">ioremap_wt()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioremap-np"><span class="toc-number">5.4.</span> <span class="toc-text">ioremap_np()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioremap-uc"><span class="toc-number">5.5.</span> <span class="toc-text">ioremap_uc()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioremap-cache-%EF%BC%88%E5%B0%86-I-O-%E5%86%85%E5%AD%98%E5%BD%93%E4%BD%9C%E6%99%AE%E9%80%9A-RAM-%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%94%AF%E6%8C%81-cache%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">ioremap_cache()（将 I&#x2F;O 内存当作普通 RAM 使用，支持 cache）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Architecture-example"><span class="toc-number">6.</span> <span class="toc-text">Architecture example</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">7.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By CarlyleLiu</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><!-- hexo injector body_end end --></body></html>