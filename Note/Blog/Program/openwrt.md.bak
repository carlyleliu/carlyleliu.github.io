---
title: openwrt Makefile分析
categories: Program
date: 2020-07-14 23:45:09
tags: OpenWRT
---

# openwrt编译流程（vocore为例）
clone源码并解压
```bash
wget http://vonger.cn/misc/vocore2/openwrt.tar.bz2
tar -jxvf openwrt.tar.bz2
```
安装依赖包
```bash
sudo apt-get install gcc g++ binutils patch bzip2 flex bison make autoconf gettext texinfo unzip sharutils subversion libncurses5-dev ncurses-term zlib1g-dev libssl-dev python
```
编译过程中会有报错缺少intltool这个工具执行以下命令安装即可
```bash
apt-get install intltool
```
更新并编译
```bash
./scripts/feeds update -a
./scripts/feeds install -a
make menuconfig
make -j1 V=s
```
<!--more-->

# Makefile分析
## 主Makefile

```makefile
TOPDIR:=${CURDIR}
LC_ALL:=C
LANG:=C
TZ:=UTC
export TOPDIR LC_ALL LANG TZ

empty:=
space:= $(empty) $(empty)
$(if $(findstring $(space),$(TOPDIR)),$(error ERROR: The path to the LEDE directory must not include any spaces))
```

设置当前路径为编译顶层路径，将LC_ALL LANG设置为C并导出变量以在其他位置使用，同时openwrt路径不能包含空格路径

```makefile
world:

include $(TOPDIR)/include/host.mk

ifneq ($(OPENWRT_BUILD),1)
  _SINGLE=export MAKEFLAGS=$(space);

  override OPENWRT_BUILD=1
  export OPENWRT_BUILD
  GREP_OPTIONS=
  export GREP_OPTIONS
  include $(TOPDIR)/include/debug.mk
  include $(TOPDIR)/include/depends.mk
  include $(TOPDIR)/include/toplevel.mk
else
  include rules.mk
  include $(INCLUDE_DIR)/depends.mk
  include $(INCLUDE_DIR)/subdir.mk
  include target/Makefile
  include package/Makefile
  include tools/Makefile
  include toolchain/Makefile

$(toolchain/stamp-install): $(tools/stamp-install)
$(target/stamp-compile): $(toolchain/stamp-install) $(tools/stamp-install) $(BUILD_DIR)/.prepared
$(package/stamp-compile): $(target/stamp-compile) $(package/stamp-cleanup)
$(package/stamp-install): $(package/stamp-compile)
$(target/stamp-install): $(package/stamp-compile) $(package/stamp-install)
check: $(tools/stamp-check) $(toolchain/stamp-check) $(package/stamp-check)
```

这里目标word没有定义，是在include/topleve.mk文件里定义了，如下

```makefile
ifeq ($(SDK),1)

%::
	@+$(PREP_MK) $(NO_TRACE_MAKE) -r -s prereq
	@./scripts/config/conf --defconfig=.config Config.in
	@+$(ULIMIT_FIX) $(SUBMAKE) -r $@

else

%::
	@+$(PREP_MK) $(NO_TRACE_MAKE) -r -s prereq
	@( \
		cp .config tmp/.config; \
		./scripts/config/conf --defconfig=tmp/.config -w tmp/.config Config.in > /dev/null 2>&1; \
		if ./scripts/kconfig.pl '>' .config tmp/.config | grep -q CONFIG; then \
			printf "$(_R)WARNING: your configuration is out of sync. Please run make menuconfig, oldconfig or defconfig!$(_N)\n" >&2; \
		fi \
	)
	@+$(ULIMIT_FIX) $(SUBMAKE) -r $@ $(if $(WARN_PARALLEL_ERROR), || { \
		printf "$(_R)Build failed - please re-run with -j1 to see the real error message$(_N)\n" >&2; \
		false; \
	} )

endif
```

%：：是为所有没有定义的目标匹配规则，其中NO_TRACE_MAKE := $(MAKE) V=s$(OPENWRT_VERBOSE)，PREP_MK= OPENWRT_BUILD= QUIET=0即当执行make V=s就化简为

```makefile
@make V=s -r -s prereq
@make -w -r world
```

这会进入非第一次编译逻辑中

```makefile
include rules.mk
include $(INCLUDE_DIR)/depends.mk
include $(INCLUDE_DIR)/subdir.mk
include target/Makefile
include package/Makefile
include tools/Makefile
include toolchain/Makefile
```

其中subdir.mk文件中包含两个重要函数subdir和stampfile如下

```
define subdir
  $(call warn,$(1),d,D $(1))
  $(foreach bd,$($(1)/builddirs),
    $(call warn,$(1),d,BD $(1)/$(bd))
    $(foreach target,$(SUBTARGETS),
      $(foreach btype,$(buildtypes-$(bd)),
        $(call warn_eval,$(1)/$(bd),t,T,$(1)/$(bd)/$(btype)/$(target): $(if $(QUILT),,$($(1)/$(bd)/$(btype)/$(target)) $(call $(1)//$(btype)/$(target),$(1)/$(bd)/$(btype))))
		  $(call log_make,$(1)/$(bd),$(target),$(btype),$(filter-out __default,$(variant))) \
			$(if $(findstring $(bd),$($(1)/builddirs-ignore-$(btype)-$(target))), || $(call ERROR,$(1),   ERROR: $(1)/$(bd) [$(btype)] failed to build.))
        $(if $(call diralias,$(bd)),$(call warn_eval,$(1)/$(bd),l,T,$(1)/$(call diralias,$(bd))/$(btype)/$(target): $(1)/$(bd)/$(btype)/$(target)))
      )
      $(call warn_eval,$(1)/$(bd),t,T,$(1)/$(bd)/$(target): $(if $(QUILT),,$($(1)/$(bd)/$(target)) $(call $(1)//$(target),$(1)/$(bd))))
        $(foreach variant,$(if $(BUILD_VARIANT),$(BUILD_VARIANT),$(if $(strip $($(1)/$(bd)/variants)),$($(1)/$(bd)/variants),$(if $($(1)/$(bd)/default-variant),$($(1)/$(bd)/default-variant),__default))),
			$(if $(BUILD_LOG),@mkdir -p $(BUILD_LOG_DIR)/$(1)/$(bd)/$(filter-out __default,$(variant)))
			$(call log_make,$(1)/$(bd),$(target),,$(filter-out __default,$(variant))) \
				$(if $(findstring $(bd),$($(1)/builddirs-ignore-$(target))), || $(call ERROR,$(1),   ERROR: $(1)/$(bd) failed to build$(if $(filter-out __default,$(variant)), (build variant: $(variant))).))
        )
      $(if $(PREREQ_ONLY)$(DUMP_TARGET_DB),,
        # aliases
        $(if $(call diralias,$(bd)),$(call warn_eval,$(1)/$(bd),l,T,$(1)/$(call diralias,$(bd))/$(target): $(1)/$(bd)/$(target)))
	  )
	)
  )
  $(foreach target,$(SUBTARGETS),$(call subtarget,$(1),$(target)))
endef

ifndef DUMP_TARGET_DB
# Parameters: <subdir> <name> <target> <depends> <config options> <stampfile location>
define stampfile
  $(1)/stamp-$(3):=$(if $(6),$(6),$(STAGING_DIR))/stamp/.$(2)_$(3)$(5)
  $$($(1)/stamp-$(3)): $(TMP_DIR)/.build $(4)
	@+$(SCRIPT_DIR)/timestamp.pl -n $$($(1)/stamp-$(3)) $(1) $(4) || \
		$(MAKE) $(if $(QUIET),--no-print-directory) $$($(1)/flags-$(3)) $(1)/$(3)
	@mkdir -p $$$$(dirname $$($(1)/stamp-$(3)))
	@touch $$($(1)/stamp-$(3))

  $$(if $(call debug,$(1),v),,.SILENT: $$($(1)/stamp-$(3)))

  .PRECIOUS: $$($(1)/stamp-$(3)) # work around a make bug

  $(1)//clean:=$(1)/stamp-$(3)/clean
  $(1)/stamp-$(3)/clean: FORCE
	@rm -f $$($(1)/stamp-$(3))

endef
```

这两个函数比较复杂，我们以target/Makefile为例来分析subdir和stampfile函数。如下两条语句

```makefile
$(eval $(call subdir,$(curdir)))
```

将其展开得到

```makefile
$(call warn,target,d,D target)
 $(foreach bd,$(target/builddirs),
   $(call warn,target,d,BD target/$(bd))
   $(foreach target,$(SUBTARGETS),
     $(foreach btype,$(buildtypes-$(bd)),
       $(call warn_eval,target/$(bd),t,T,target/$(bd)/$(btype)/$(target): $(if $(QUILT),,$(target/$(bd)/$(btype)/$(target)) $(call target//$(btype)/$(target),target/$(bd)/$(btype))))
	  $(call log_make,target/$(bd),$(target),$(btype),$(filter-out __default,$(variant))) \
		$(if $(findstring $(bd),$(target/builddirs-ignore-$(btype)-$(target))), || $(call ERROR,target,   ERROR: target/$(bd) [$(btype)] failed to build.))
       $(if $(call diralias,$(bd)),$(call warn_eval,target/$(bd),l,T,target/$(call diralias,$(bd))/$(btype)/$(target): target/$(bd)/$(btype)/$(target)))
     )
     $(call warn_eval,target/$(bd),t,T,target/$(bd)/$(target): $(if $(QUILT),,$(target/$(bd)/$(target)) $(call target//$(target),target/$(bd))))
       $(foreach variant,$(if $(BUILD_VARIANT),$(BUILD_VARIANT),$(if $(strip $(target/$(bd)/variants)),$(target/$(bd)/variants),$(if $(target/$(bd)/default-variant),$(target/$(bd)/default-variant),__default))),
		$(if $(BUILD_LOG),@mkdir -p $(BUILD_LOG_DIR)/target/$(bd)/$(filter-out __default,$(variant)))
		$(call log_make,target/$(bd),$(target),,$(filter-out __default,$(variant))) \
			$(if $(findstring $(bd),$(target/builddirs-ignore-$(target))), || $(call ERROR,target,   ERROR: target/$(bd) failed to build$(if $(filter-out __default,$(variant)), (build variant: $(variant))).))
       )
     $(if $(PREREQ_ONLY)$(DUMP_TARGET_DB),,
       # aliases
       $(if $(call diralias,$(bd)),$(call warn_eval,target/$(bd),l,T,target/$(call diralias,$(bd))/$(target): target/$(bd)/$(target)))
  )
)
 )
 $(foreach target,$(SUBTARGETS),$(call subtarget,target,$(target)))
```

 stampfile函数就是生成target/stamp-prereq规则而subdir函数则是进入子目录执行make -C操作。这样Makefile就通过这两个函数生成子目录构建规则和进入子目录进行编译。

```makefile
  printdb:
	@true

prepare: $(target/stamp-compile)

clean: FORCE
	rm -rf $(BUILD_DIR) $(STAGING_DIR) $(BIN_DIR) $(OUTPUT_DIR)/packages/$(ARCH_PACKAGES) $(BUILD_LOG_DIR) $(TOPDIR)/staging_dir/packages

dirclean: clean
	rm -rf $(STAGING_DIR_HOST) $(TOOLCHAIN_DIR) $(BUILD_DIR_HOST) $(BUILD_DIR_TOOLCHAIN)
	rm -rf $(TMP_DIR)
```

定义一些规则。比较重要的是clean和distclean删除编译过程中的一些文件，distclean依赖clean命令会先执行clean命令之后再删除剩余的编译过程文件

```makefile
ifndef DUMP_TARGET_DB
$(BUILD_DIR)/.prepared: Makefile
	@mkdir -p $$(dirname $@)
	@touch $@

tmp/.prereq_packages: .config
	unset ERROR; \
	for package in $(sort $(prereq-y) $(prereq-m)); do \
		$(_SINGLE)$(NO_TRACE_MAKE) -s -r -C package/$$package prereq || ERROR=1; \
	done; \
	if [ -n "$$ERROR" ]; then \
		echo "Package prerequisite check failed."; \
		false; \
	fi
	touch $@
endif
```

tmp/.prereq_packages目标是对所需软件包的预处理。目标依赖于.config，即执行make menuconfig后将会进行一次所需软件包的预处理。本次编译后tmp/.prereq_packages文件为空，并没有生成什么

```makefile
# check prerequisites before starting to build
prereq: $(target/stamp-prereq) tmp/.prereq_packages
	@if [ ! -f "$(INCLUDE_DIR)/site/$(ARCH)" ]; then \
		echo 'ERROR: Missing site config for architecture "$(ARCH)" !'; \
		echo '       The missing file will cause configure scripts to fail during compilation.'; \
		echo '       Please provide a "$(INCLUDE_DIR)/site/$(ARCH)" file and restart the build.'; \
		exit 1; \
	fi

checksum: FORCE
	$(call sha256sums,$(BIN_DIR))

diffconfig: FORCE
	mkdir -p $(BIN_DIR)
	$(SCRIPT_DIR)/diffconfig.sh > $(BIN_DIR)/config.seed

prepare: .config $(tools/stamp-install) $(toolchain/stamp-install)
world: prepare $(target/stamp-compile) $(package/stamp-compile) $(package/stamp-install) $(target/stamp-install) FORCE
	$(_SINGLE)$(SUBMAKE) -r package/index
	$(_SINGLE)$(SUBMAKE) -r diffconfig
	$(_SINGLE)$(SUBMAKE) -r checksum

.PHONY: clean dirclean prereq prepare world package/symlinks package/symlinks-install package/symlinks-clean

endif
```

prereq编译前的检查如果$(INCLUDE_DIR)/site/$(ARCH)不是常规文件打印提示信息然后返回。checksum对目标文件进行sha256校验。word为目标文件。PHONY说明clean dirclean prereq prepareworld package/symlinks package/symlinks-installpackage/symlinks-clean属于伪目标。

这样主Makefile就分析完了，其实就是构建了world目标，并生成依赖，然后调用其他目录下的Makefile，这些Makefile再调用subdir和stampfile函数进行子目录的构建，从而完成整个系统的构建。

### kernel的构建
以mtk芯片为例简单分析一下kernel的编译，其Makefile在/target/linux/ramips/Makefile文件中，最关键的一句是

```makefile
$(eval $(call BuildTarget))
```
在include $(INCLUDE_DIR)/target.mk文件中定义如下
```makefile
ifeq ($(TARGET_BUILD),1)
  include $(INCLUDE_DIR)/kernel-build.mk
  BuildTarget?=$(BuildKernel)
endif
```
BuildKernel可以通过include $(INCLUDE_DIR)/kernel-build.mk这句找到，其定义如下
```makefile
define BuildKernel
  $(if $(QUILT),$(Build/Quilt))
  $(if $(LINUX_SITE),$(call Download,kernel))	//下载内核
  $(if $(call qstrip,$(CONFIG_KERNEL_GIT_CLONE_URI)),$(call Download,git-kernel))	//通过git clone

  .NOTPARALLEL:

  $(Kernel/Autoclean)			//删除buidir目录重新构建
  $(STAMP_PREPARED): $(if $(LINUX_SITE),$(DL_DIR)/$(LINUX_SOURCE))
	-rm -rf $(KERNEL_BUILD_DIR)
	-mkdir -p $(KERNEL_BUILD_DIR)
	$(Kernel/Prepare)
	touch $$@

  $(KERNEL_BUILD_DIR)/symtab.h: FORCE
	rm -f $(KERNEL_BUILD_DIR)/symtab.h
	touch $(KERNEL_BUILD_DIR)/symtab.h
	+$(MAKE) $(KERNEL_MAKEOPTS) vmlinux		//构建vmlinux
	find $(LINUX_DIR) $(STAGING_DIR_ROOT)/lib/modules -name \*.ko | \
		xargs $(TARGET_CROSS)nm | \
		awk '$$$$1 == "U" { print $$$$2 } ' | \
		sort -u > $(KERNEL_BUILD_DIR)/mod_symtab.txt
	$(TARGET_CROSS)nm -n $(LINUX_DIR)/vmlinux.o | grep ' [rR] __ksymtab' | sed -e 's,........ [rR] __ksymtab_,,' > $(KERNEL_BUILD_DIR)/kernel_symtab.txt 		//构建vmlinux
	grep -Ff $(KERNEL_BUILD_DIR)/mod_symtab.txt $(KERNEL_BUILD_DIR)/kernel_symtab.txt > $(KERNEL_BUILD_DIR)/sym_include.txt
	grep -Fvf $(KERNEL_BUILD_DIR)/mod_symtab.txt $(KERNEL_BUILD_DIR)/kernel_symtab.txt > $(KERNEL_BUILD_DIR)/sym_exclude.txt
	( \
		echo '#define SYMTAB_KEEP \'; \
		cat $(KERNEL_BUILD_DIR)/sym_include.txt | \
			awk '{print "KEEP(*(___ksymtab+" $$$$1 ")) \\" }'; \
		echo; \
		echo '#define SYMTAB_KEEP_GPL \'; \
		cat $(KERNEL_BUILD_DIR)/sym_include.txt | \
			awk '{print "KEEP(*(___ksymtab_gpl+" $$$$1 ")) \\" }'; \
		echo; \
		echo '#define SYMTAB_DISCARD \'; \
		cat $(KERNEL_BUILD_DIR)/sym_exclude.txt | \
			awk '{print "*(___ksymtab+" $$$$1 ") \\" }'; \
		echo; \
		echo '#define SYMTAB_DISCARD_GPL \'; \
		cat $(KERNEL_BUILD_DIR)/sym_exclude.txt | \
			awk '{print "*(___ksymtab_gpl+" $$$$1 ") \\" }'; \
		echo; \
	) > $$@

  $(STAMP_CONFIGURED): $(STAMP_PREPARED) $(LINUX_KCONFIG_LIST) $(TOPDIR)/.config FORCE
	$(Kernel/Configure)
	touch $$@

  $(LINUX_DIR)/.modules: $(STAMP_CONFIGURED) $(LINUX_DIR)/.config FORCE
	$(Kernel/CompileModules)
	touch $$@

  $(LINUX_DIR)/.image: $(STAMP_CONFIGURED) $(if $(CONFIG_STRIP_KERNEL_EXPORTS),$(KERNEL_BUILD_DIR)/symtab.h) FORCE
	$(Kernel/CompileImage)
	$(Kernel/CollectDebug)
	touch $$@

  mostlyclean: FORCE
	$(Kernel/Clean)

  define BuildKernel
  endef
```

这里定义了一些列构建规则包括获取源码，自动清除和构建vmlinux，kernel-build.mk这个文件是关于如何构建linux kernel的，除了BuildKernel的定义外还有就是以下关键内容

```makefile
compile: $(LINUX_DIR)/.modules
$(MAKE) -C image compile TARGET_BUILD=
```

构建image compile TARGET_BUILD

```makefile
oldconfig menuconfig nconfig: $(STAMP_PREPARED) $(STAMP_CHECKED) FORCE
rm -f $(LINUX_DIR)/.config.prev
rm -f $(STAMP_CONFIGURED)
$(LINUX_RECONF_CMD) > $(LINUX_DIR)/.config
$(_SINGLE)$(MAKE) -C $(LINUX_DIR) $(KERNEL_MAKEOPTS) HOST_LOADLIBES="-L$(STAGING_DIR_HOST)/lib -lncurses" $$@
$(LINUX_RECONF_DIFF) $(LINUX_DIR)/.config > $(LINUX_RECONFIG_TARGET)
```

配置内核模块

```makefile
install: $(LINUX_DIR)/.image
+$(MAKE) -C image compile install TARGET_BUILD=
```

生成vmlinux

```makefile
clean: FORCE
rm -rf $(KERNEL_BUILD_DIR)

image-prereq:
@+$(NO_TRACE_MAKE) -s -C image prereq TARGET_BUILD=

prereq: image-prereq
```

 还有一些其他操作clean清除之类的；这里主要完成kernel的构建生成vmlinux
 ## 生成bin格式的firmware
 firmware由vmlinux和rootfs两部分组成。”target/linux/ramips/image/Makefile” 文件中的最后一句：$(eval $(call BuildImage))，将BuildImage展开在这里。BuildImage定义在 include/image.mk 文件中，其中定义了数个目标的规则。

 ```makefile
 define BuildImage

	...

  ifeq ($(IB),)
    .PHONY: download prepare compile clean image_prepare kernel_prepare install install-images
    compile:
		$(call Build/Compile)

    clean:
		$(call Build/Clean)

    image_prepare: compile
		mkdir -p $(BIN_DIR) $(KDIR)/tmp
		$(call Image/Prepare)

    legacy-images-prepare-make: image_prepare
		$(MAKE) legacy-images-prepare

  else
    image_prepare:
		mkdir -p $(BIN_DIR) $(KDIR)/tmp
  endif

  kernel_prepare: image_prepare
	$(call Image/Build/targz)
	$(call Image/Build/cpiogz)
	$(call Image/BuildKernel)	//处理vmlinux
	$(if $(CONFIG_TARGET_ROOTFS_INITRAMFS),$(if $(IB),,$(call Image/BuildKernel/Initramfs)))
	$(call Image/InstallKernel)

  $(foreach device,$(TARGET_DEVICES),$(call Device,$(device)))
  $(foreach device,$(LEGACY_DEVICES),$(call LegacyDevice,$(device)))

  install-images: kernel_prepare $(foreach fs,$(filter-out $(if $(UBIFS_OPTS),,ubifs),$(TARGET_FILESYSTEMS) $(fs-subtypes-y)),$(KDIR)/root.$(fs))
	$(foreach fs,$(TARGET_FILESYSTEMS),
		$(call Image/Build,$(fs))
	)

  legacy-images-make: install-images
	$(call Image/mkfs/ubifs/legacy)
	$(MAKE) legacy-images

  install: install-images
	$(call Image/Manifest)

endef
```

最终生成bin文件的Makefile在/target/linux/ramips/image/Makefile文件里

```makefile
define Image/BuildKernel
	cp $(KDIR)/vmlinux.elf $(BIN_DIR)/$(VMLINUX).elf
	cp $(KDIR)/vmlinux $(BIN_DIR)/$(VMLINUX).bin
	$(call CompressLzma,$(KDIR)/vmlinux,$(KDIR)/vmlinux.bin.lzma)
	$(call MkImage,lzma,$(KDIR)/vmlinux.bin.lzma,$(KDIR)/uImage.lzma)
	cp $(KDIR)/uImage.lzma $(BIN_DIR)/$(UIMAGE).bin
endef
```

该文件对文件系统和vmlinx进行组合，对内核进行压缩最后得到需要的固件。

# feeds
## 概述
feeds是一个软件包的集合,他可以位于远程服务器,本地文件或其他位置,openwrt自带了很多feeds软件包,包括luci,routing,telephony,packages等.构建过程中可以通过feeds命令下载和安装这些软件包,其配置文件为feeds.conf,默认配置文件为feeds.conf.default,可以在里面配置我们自己的软件包.
例如openwrt默认配置文件是这样的

```conf
src-git packages https://git.openwrt.org/feed/packages.git
src-git luci https://git.openwrt.org/project/luci.git
src-git routing https://git.openwrt.org/feed/routing.git
src-git telephony https://git.openwrt.org/feed/telephony.git
#src-git video https://github.com/openwrt/video.git
#src-git targets https://github.com/openwrt/targets.git
#src-git management https://github.com/openwrt-management/packages.git
#src-git oldpackages http://git.openwrt.org/packages.git
#src-link custom /usr/src/openwrt/custom-feed
```

#是注释,src-git代表代码在git仓库里通过git方式获取软件包,packages等是软件包下载到本地后的 文件夹名称,再之后是代码仓库地址,在通过git方式获取代码时有时需要指定分支名称,以第一个为例添加master分支修改为:
```conf
src-git packages https://git.openwrt.org/feed/packages.git:master
```
这样就指定了代码分支,link是连接本地文件后面跟代码路径,还有svn是通过svn获取代码,具体在openwrt官网上给出具体介绍如下
![](/picture/linux/feeds1.png)

## feed命令
**update**
通过OpenWrt根目录下的scripts/feeds脚本文件使用feeds,大多数命令需要从本地获取信息,因此首先需要更新,scripts/feeds update -a更新所有,也可以指定只更新一个文件,例如

```
scripts/feeds update luci
```

**install**
只更新luci这一个软件包通过install命令安装所有下载下来的软件包以及软件包的依赖,安装过程包括创建从 packages/feeds/$feed_name/$package_name到feeds/$feed_name/$package_name的软件接,以便于编译过程中编译package时会通过软连接去编译feeds目录下的软件包.feeds安装命令如下:
![](/picture/linux/feeds2.png)
**list**
下载下来的文件会有一个以.index为后缀名的文件那个是软件包的索引文件,list命令就是通过这个index后缀名的文件将软件包列出来.
**uninstall及clean**
uninstall卸载软件包,只是移除了软连接.clean是删除本地feeds目录下的软件包以及索引文件.

## 添加自己的软接包
修改feeds.conf文件添加自己的代码路径及获取方式

```conf
src-git your_package_name url:branch
```

把相关package添加到config文件编译就可以了.
## package相关
这里以添加一个较为常用的lrzsz软件包为例来说明构建一个package的过程,一般一个package里包含三个文件Makefile,patches,files.Makefile提供获取软件包的命令,包名称等一系列内容,其他两项是可选的其中patches一般包含的是补丁文件,针对源码存在的bug进行添加补丁,files目录下包含一些针对该软件的默认配置及启动脚本等文件.lrzsz的makefile文件如下:

```makefile
include $(TOPDIR)/rules.mk

PKG_NAME:=lrzsz
PKG_VERSION:=0.12.20
PKG_RELEASE:=1

PKG_SOURCE:=${PKG_NAME}-${PKG_VERSION}.tar.gz
PKG_SOURCE_URL:=https://ohse.de/uwe/releases/
PKG_MD5SUM:=b5ce6a74abc9b9eb2af94dffdfd372a4

PKG_MAINTAINER:=Bruno Randolf <ohse.de@gnu.org>
PKG_LICENSE:=GPL-2.0
PKG_LICENSE_FILES:=COPYING

include $(INCLUDE_DIR)/package.mk

define Package/lrzsz/Default
  SECTION:=Applications
  CATEGORY:=apps
  URL:=https://ohse.de/uwe/software/lrzsz.html
endef

define Package/lrzsz
  $(call Package/lrzsz/Default)
  TITLE:=Linux z-mode transport
endef

define Package/lrzsz/description
 lrzsz is a language that supports arbitrary precision numbers with
 interactive execution of statements.
endef

define Package/lrzsz/install
	$(INSTALL_DIR) $(1)/usr/bin
	$(INSTALL_BIN) $(PKG_BUILD_DIR)/src/lrz $(1)/usr/bin/rz
	$(INSTALL_BIN) $(PKG_BUILD_DIR)/src/lsz $(1)/usr/bin/sz
endef

$(eval $(call BuildPackage,lrzsz))
```

- PKG_NAME - 定义这个包的名字，在menucongfig中看到的包名字就是这里指定的
- PKG_VERSION - 定义了我们要下载的软件的上游版本号
- PKG_RELEASE - 这个包的Makefile版本号，可以理解为OpenWrt自己对每个pacakge赋予的版本
- PKG_LICENSE - 这个包的授权协议，一般都来自上游软件商
- PKG_LICENSE_FILE - 描述授权协议的文件
- PKG_BUILD_DIR - 将要在那个位置存储并编译这个包的软件源码
- PKG_SOURCE - 这个包的原始码的文件名
- PKG_SOURCE_URL - 从哪里下载这个包的源码
- PKG_MD5SUM - 用于验证所下载内容的校验码，可以使MD5或者SHA256其中之一
- PKG_CAT - 定义要用哪种方式压缩并释放原始码（zcat，bzcat，还是unzip）
- PKG_BUILD_DEPENDS - 定义这要编译这个包之前必须先编译的包，也就是这个包在编译过程的依赖包，运行时不一定需要。一般而言都是一些提供链接时的依赖库或者头文件等的包，使用的语法和后面要说到的DEPENDS相同
- PKG_INSTALL - 如果将这个变量设置为1，将会调用这个软件原代码中的原生make install，并将prefix设置为PKG_INSTALL_DIR的值
- PKG_INSTALL_DIR - 定义了make install将会把编译好的文件拷贝到哪里
- PKG_FIXUP - 这个变量的含义后面会详述，请参见下面的内容
- PKG_SOURCE_PROTO - 定义了用于获取原始代码的协议（git，svn）
- PKG_REV - svn revision要用的到，如果proto是svn时必须指定
- PKG_SOURCE_SUBDIR - 如果proto是svn或者git必须要指定这个，如：PKG_SOURCE_SUBDIR:=$(PKG_NAME)-$(PKG_VERSION)
- PKG_SOURCE_VERSION - 如果proto是git必须指定这个，表示git中的commit hash（一个tag名或者commit id），用于git的checkout操作
- PKG_CONFIG_DEPENDS - 指定了哪些依赖这个包的配置选项将被选中

一般makefile文件的写法参考已有的软件包进行写.其他软件包可以以相同方式进行添加.

