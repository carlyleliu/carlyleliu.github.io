---
title: Linux驱动之IIO子系统(二)模块分析篇
categories: 
- Linux
- 驱动
date: 2020-10-01 14:18:24
tags: Linux驱动
---

# Trigger机制
Trigger机制实现的数据结构如下：[原图](https://www.processon.com/view/link/615727b10e3e74663e94ea41)
![](/picture/linux_driver/iio/IIO_Trigger.png)

所有注册到系统的trigger都会挂载在一个全局链表iio_trigger_list中。通过其数据结构我们发现该数据结构并没有指向iio_dev或iio_buffer结构的指针，那么当事件发生时trigger是怎样通知到iio_dev设备的呢？

iio trigger为每一个trigger实现了一个虚拟的irq chip，而在进行iio trigger与iio device的绑定操作时，为待绑定的iio device申请一个该trigger尚未使用的虚拟irq，并完成对该中断的注册操作；而当外部设备驱动触发该trigger后，该trigger则遍历已注册的中断，调用其对应的中断处理函数进行相应的处理，这也就实现了调用所有已绑定的iio device提供的处理函数，进行trigger的处理操作。

<!--more-->

下面看下trigger与处理中断之间的关联：这个过程主要是通过调用iio_trigger_attach_poll_func函数完成的，如下：
```c
int iio_trigger_attach_poll_func(struct iio_trigger *trig,
				 struct iio_poll_func *pf)
{
	struct iio_dev_opaque *iio_dev_opaque = to_iio_dev_opaque(pf->indio_dev);
	bool notinuse =
		bitmap_empty(trig->pool, CONFIG_IIO_CONSUMERS_PER_TRIGGER);
	int ret = 0;

	/* Prevent the module from being removed whilst attached to a trigger */
	__module_get(iio_dev_opaque->driver_module);

	/* 1、获取中断号*/
	pf->irq = iio_trigger_get_irq(trig);
	if (pf->irq < 0) {
		pr_err("Could not find an available irq for trigger %s, CONFIG_IIO_CONSUMERS_PER_TRIGGER=%d limit might be exceeded\n",
			trig->name, CONFIG_IIO_CONSUMERS_PER_TRIGGER);
		goto out_put_module;
	}

	/* 2、申请中断 */
	ret = request_threaded_irq(pf->irq, pf->h, pf->thread,
				   pf->type, pf->name,
				   pf);
	if (ret < 0)
		goto out_put_irq;

	/* 3、在驱动中使能trigger */
	if (trig->ops && trig->ops->set_trigger_state && notinuse) {
		ret = trig->ops->set_trigger_state(trig, true);
		if (ret < 0)
			goto out_free_irq;
	}

    ...
}
```
linux/drivers/iio/industrialio-trigger.c是trigger的核心，提供trigger的注册实现，而linux/drivers/iio/trigger/目录下则是具体trigger的实现，例如interrupt的hrtime的sysfs的，我们以interrupt为例看下trigger的注册流程，如下：
```c
static struct platform_driver iio_interrupt_trigger_driver = {
	.probe = iio_interrupt_trigger_probe,
	.remove = iio_interrupt_trigger_remove,
	.driver = {
		.name = "iio_interrupt_trigger",
	},
};

module_platform_driver(iio_interrupt_trigger_driver);
```
iio_interrupt_trigger_driver是采用platform总线来构造trigger结构，下面看下iio_interrupt_trigger_probe的调用流程：[原图](https://www.processon.com/view/link/61573152f346fb69a72210b2)
![](/picture/linux_driver/iio/iio_interrupt_trigger_probe.png)

这里需要注意的是对于有外部中断的trigger方式，其注册一个iio_trigger结构体主要完成以下工作：

- iio_trigger_alloc主要完成iio_trigger结构体的分配与初始化操作，主要完成中断相关操作，在上图可以看到有两个中断处理程序，在该接口中是虚拟中断处理函数上半部。
- 注册中断处理程序（真实外部中断），在中断发生时再通过trigger的虚拟中断号继续产生一个中断，就是上面那个中断上半部。
- 注册iio_trigger，完成device的添加和将iio_trigger结构体挂载到全局链表中。

# Buffer模块实现
IIO buffer主要用于连续数据采集与缓存功能，IIO buffer模块借助IIO DEVICE字符设备文件与应用程序通信，同时借助IIO trigger模块与IIO device进行交互。

## Buffer数据访问
Buffer数据访问其实就是一个字符设备驱动程序，通过file_operations结构体在驱动层提供读写等函数的实现，然后将结构体注册进系统，对于iio buffer的实现也是如此，下面看下iio_buffer字符设备的注册过程：
```c
static const struct file_operations iio_buffer_fileops = {
	.owner = THIS_MODULE,
	.llseek = noop_llseek,
	.read = iio_buffer_read_outer_addr,
	.poll = iio_buffer_poll_addr,
	.unlocked_ioctl = iio_ioctl,
	.compat_ioctl = compat_ptr_ioctl,
	.open = iio_chrdev_open,
	.release = iio_chrdev_release,
};
```
该结构体在iio设备的注册过程中注册进系统：
```c
#define iio_device_register(indio_dev) \
	__iio_device_register((indio_dev), THIS_MODULE)
```
该函数流程如下：[原图](https://www.processon.com/view/link/61586e105653bb6791e22e8a)
![](/picture/linux_driver/iio/iio_device_register.png)

当iio设备注册的时候会将iio_buffer_fileops字符设备的file_operations结构体注册到系统供应用层用户访问，关于这个结构体里面具体函数的内容这里就不做分析了，感兴趣的读者可以自行阅读源码，buffer使用kfifo来管理组织，buffer通过kfifo实现对数据的存取等管理。

## buffer和trigger的关联
在上面介绍trigger的时候讲到trigger会通过一个虚拟中断来实现数据读取到buffer的操作，但是trigger和buffer之间的关联还是不清楚，这里我们将介绍两者是如何关联到一起的。驱动通过iio_triggered_buffer_setup宏定义函数实现两者之间的关联，如下：
```c
#define iio_triggered_buffer_setup(indio_dev, h, thread, setup_ops)		\
	iio_triggered_buffer_setup_ext((indio_dev), (h), (thread), (setup_ops), NULL)
```
iio_triggered_buffer_setup_ext函数实现如下：
```c
int iio_triggered_buffer_setup_ext(struct iio_dev *indio_dev,
	irqreturn_t (*h)(int irq, void *p),
	irqreturn_t (*thread)(int irq, void *p),
	const struct iio_buffer_setup_ops *setup_ops,
	const struct attribute **buffer_attrs)
{
	struct iio_buffer *buffer;
	int ret;

    /* 1、分配kfifo结构体 */
	buffer = iio_kfifo_allocate();
	if (!buffer) {
		ret = -ENOMEM;
		goto error_ret;
	}

    /* 2、分配一个iio_poll_func结构体 */
	indio_dev->pollfunc = iio_alloc_pollfunc(h,
						 thread,
						 IRQF_ONESHOT,
						 indio_dev,
						 "%s_consumer%d",
						 indio_dev->name,
						 iio_device_id(indio_dev));
	if (indio_dev->pollfunc == NULL) {
		ret = -ENOMEM;
		goto error_kfifo_free;
	}

	/* 3、环形缓冲区操作函数集*/
	indio_dev->setup_ops = setup_ops;

	/* 4、设置操作模式为触发缓冲区模式  */
	indio_dev->modes |= INDIO_BUFFER_TRIGGERED;

	buffer->attrs = buffer_attrs;

    /* 5、将buffer与iio_dev联系起来 */
	ret = iio_device_attach_buffer(indio_dev, buffer);
	if (ret < 0)
		goto error_dealloc_pollfunc;

	return 0;
 ...
}
```
这里关于pollfunc的thread线程的注册是文章一开始提到的那个函数iio_trigger_attach_poll_func完成的。到这里中断上半部，下半部的工作都得到执行。IIO子系统的设计是很复杂的，其中里面也还有一些疑惑，日后再慢慢研究吧。本文到此完。

# 参考文献   
[https://blog.csdn.net/lickylin/article/details/108394392?spm=1001.2014.3001.5501](https://blog.csdn.net/lickylin/article/details/108394392?spm=1001.2014.3001.5501)    
[https://blog.csdn.net/lickylin/article/details/108307541?spm=1001.2014.3001.5501](https://blog.csdn.net/lickylin/article/details/108307541?spm=1001.2014.3001.5501)    
《Linux内核源码》   
