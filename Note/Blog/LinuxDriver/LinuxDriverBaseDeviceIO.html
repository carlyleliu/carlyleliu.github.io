<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5txRYykRNG5Z1NrO_ZCLF1GZWnbFmCOLdJHGBVFuCIg">
  <meta name="baidu-site-verification" content="code-XfgDErPTZS">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Reddit+Mono:300,300italic,400,400italic,700,700italic%7CNoto+Sans:300,300italic,400,400italic,700,700italic%7COpen+Sans:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"carlyleliu.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":true,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Memory Mapped IO  Getting Access to the Device This address should not be used directly. Instead, to get an address suitable for passing to the accessor functions described below, you should call ior">
<meta property="og:type" content="website">
<meta property="og:title" content="Linux 驱动之基础（一）Device-I&#x2F;O">
<meta property="og:url" content="https://carlyleliu.github.io/note/Blog/LinuxDriver/LinuxDriverBaseDeviceIO.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="Memory Mapped IO  Getting Access to the Device This address should not be used directly. Instead, to get an address suitable for passing to the accessor functions described below, you should call ior">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-22T13:23:06.000Z">
<meta property="article:modified_time" content="2025-09-27T03:40:43.583Z">
<meta property="article:author" content="CarlyleLiu">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Driver">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://carlyleliu.github.io/note/Blog/LinuxDriver/LinuxDriverBaseDeviceIO">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"zh-CN","comments":true,"permalink":"https://carlyleliu.github.io/note/Blog/LinuxDriver/LinuxDriverBaseDeviceIO.html","path":"note/Blog/LinuxDriver/LinuxDriverBaseDeviceIO.html","title":"Linux 驱动之基础（一）Device-I/O"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux 驱动之基础（一）Device-I/O | Matrix
</title>
  







<link rel="dns-prefetch" href="https://waline.carlyleliu.vip">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Matrix" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Matrix</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">CarlyleLiu‘s Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-alist"><span class="exturl" data-url="aHR0cHM6Ly9hbGlzdC5jYXJseWxlbGl1LnZpcC8="><i class="fa-solid fa-cloud fa-fw"></i>网盘</span></li><li class="menu-item menu-item-books"><span class="exturl" data-url="aHR0cHM6Ly9jYWxpYnJlLmNhcmx5bGVsaXUudmlwLw=="><i class="fa-solid fa-book fa-fw"></i>书库</span></li><li class="menu-item menu-item-talk"><span class="exturl" data-url="aHR0cHM6Ly9tZW1vcy5jYXJseWxlbGl1LnZpcC9leHBsb3JlLw=="><i class="fas fa-comments fa-fw"></i>随笔</span></li><li class="menu-item menu-item-album"><span class="exturl" data-url="aHR0cHM6Ly9pbW1pY2guY2FybHlsZWxpdS52aXAvc2hhcmUvSmtSenVqZERfdWVJRnJRNHpvYnpfUW1EVndRZkdGS3ZyVTh0ZlJIYWN1ZG9ZMjV0Z2tFdDd6aS1Wck5oYUEzZUdpNC8="><i class="fa-solid fa-image fa-fw"></i>相册</span></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#memory-mapped-io"><span class="nav-text"> Memory Mapped IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#getting-access-to-the-device"><span class="nav-text"> Getting Access to the Device</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#accessing-the-device"><span class="nav-text"> Accessing the device</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#port-space-accesses"><span class="nav-text"> Port Space Accesses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#port-space-explained"><span class="nav-text"> Port Space Explained</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#accessing-port-space"><span class="nav-text"> Accessing Port Space</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#__iomem-pointer-tokens"><span class="nav-text"> __iomem pointer tokens</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#differences-between-io-access-functions"><span class="nav-text"> Differences between I&#x2F;O access functions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#device-memory-mapping-modes"><span class="nav-text"> Device memory mapping modes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ioremap"><span class="nav-text"> ioremap()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ioremap_wc"><span class="nav-text"> ioremap_wc()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ioremap_wt"><span class="nav-text"> ioremap_wt()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ioremap_np"><span class="nav-text"> ioremap_np()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ioremap_uc"><span class="nav-text"> ioremap_uc()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ioremap_cache%E5%B0%86-io-%E5%86%85%E5%AD%98%E5%BD%93%E4%BD%9C%E6%99%AE%E9%80%9A-ram-%E4%BD%BF%E7%94%A8%E6%94%AF%E6%8C%81-cache"><span class="nav-text"> ioremap_cache()（将 I&#x2F;O 内存当作普通 RAM 使用，支持 cache）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#architecture-example"><span class="nav-text"> Architecture example</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text"> 参考文献</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CarlyleLiu</p>
  <div class="site-description" itemprop="description">CarlyleLiu’s Blog</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">207</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhcmx5bGVsaXU=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;carlyleliu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnl5bGl1c2h1YWlAZ21haWwuY29t" title="E-Mail → mailto:yyliushuai@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95eWxpdXNodWFp" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;yyliushuai"><i class="fab fa-twitter fa-fw"></i>Twitter</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly95b3V0dWJlLmNvbS9jYXJseWxlbGl1" title="YouTube → https:&#x2F;&#x2F;youtube.com&#x2F;carlyleliu"><i class="fab fa-youtube fa-fw"></i>YouTube</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL2JsdXJyZWRsaXU=" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;blurredliu"><i class="fab fa-instagram fa-fw"></i>Instagram</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner page posts-expand">


    
    
    
    <div class="post-block" lang="zh-CN"><header class="post-header">

<h1 class="post-title" itemprop="name headline">Linux 驱动之基础（一）Device-I/O
</h1>

<div class="post-meta-container">
  <ul class="breadcrumb">
            <li><a href="/note/">NOTE</a></li>
            <li><a href="/note/Blog/">BLOG</a></li>
            <li><a href="/note/Blog/LinuxDriver/">LINUXDRIVER</a></li>
            <li>LINUXDRIVERBASEDEVICEIO</li>
  </ul>
</div>

</header>

      
      
      
      <div class="post-body">
          <h1 id="memory-mapped-io"><a class="markdownIt-Anchor" href="#memory-mapped-io"></a> Memory Mapped IO</h1>
<h2 id="getting-access-to-the-device"><a class="markdownIt-Anchor" href="#getting-access-to-the-device"></a> Getting Access to the Device</h2>
<p>This address should not be used directly. Instead, to get an address suitable for passing to the accessor functions described below, you should call ioremap(). An address suitable for accessing the device will be returned to you.</p>
<p>After you’ve finished using the device (say, in your module’s exit routine), call iounmap() in order to return the address space to the kernel. Most architectures allocate new address space each time you call ioremap(), and they can run out unless you call iounmap().</p>
<span id="more"></span>
<h2 id="accessing-the-device"><a class="markdownIt-Anchor" href="#accessing-the-device"></a> Accessing the device</h2>
<p>The part of the interface most used by drivers is reading and writing memory-mapped registers on the device. Linux provides interfaces to read and write 8-bit, 16-bit, 32-bit and 64-bit quantities. Due to a historical accident, these are named byte, word, long and quad accesses. Both read and write accesses are supported; there is no prefetch support at this time.</p>
<p>The functions are named readb(), readw(), readl(), readq(), readb_relaxed(), readw_relaxed(), readl_relaxed(), readq_relaxed(), writeb(), writew(), writel() and writeq().</p>
<p>Some devices (such as framebuffers) would like to use larger transfers than 8 bytes at a time. For these devices, the memcpy_toio(), memcpy_fromio() and memset_io() functions are provided. Do not use memset or memcpy on IO addresses; they are not guaranteed to copy data in order.</p>
<p>The read and write functions are defined to be ordered. That is the compiler is not permitted to reorder the I/O sequence. When the ordering can be compiler optimised, you can use __readb() and friends to indicate the relaxed ordering. Use this with care.</p>
<h1 id="port-space-accesses"><a class="markdownIt-Anchor" href="#port-space-accesses"></a> Port Space Accesses</h1>
<h2 id="port-space-explained"><a class="markdownIt-Anchor" href="#port-space-explained"></a> Port Space Explained</h2>
<p>Another form of IO commonly supported is Port Space. This is a range of addresses separate to the normal memory address space. Access to these addresses is generally not as fast as accesses to the memory mapped addresses, and it also has a potentially smaller address space.</p>
<p>Unlike memory mapped IO, no preparation is required to access port space.</p>
<h2 id="accessing-port-space"><a class="markdownIt-Anchor" href="#accessing-port-space"></a> Accessing Port Space</h2>
<p>Accesses to this space are provided through a set of functions which allow 8-bit, 16-bit and 32-bit accesses; also known as byte, word and long. These functions are inb(), inw(),inl(), outb(), outw() and outl().</p>
<p>Some variants are provided for these functions. Some devices require that accesses to their ports are slowed down. This functionality is provided by appending a _p to the end of the function. There are also equivalents to memcpy. The ins() and<br>
outs() functions copy bytes, words or longs to the given port.</p>
<h1 id="__iomem-pointer-tokens"><a class="markdownIt-Anchor" href="#__iomem-pointer-tokens"></a> __iomem pointer tokens</h1>
<p>The data type for an MMIO address is an __iomem qualified pointer, such as void __iomem *reg. On most architectures it is a regular pointer that points to a virtual memory address and can be offset or dereferenced, but in portable code, it must only be passed from and to functions that explicitly operated on an __iomem token, in particular the ioremap() and readl()/writel() functions. The ‘sparse’ semantic code checker can be used to verify that this is done correctly.</p>
<p>While on most architectures, ioremap() creates a page table entry for an uncached virtual address pointing to the physical MMIO address, some architectures require special instructions for MMIO, and the __iomem pointer just encodes the physical address or an offsettable cookie that is interpreted by readl()/writel().</p>
<h1 id="differences-between-io-access-functions"><a class="markdownIt-Anchor" href="#differences-between-io-access-functions"></a> Differences between I/O access functions</h1>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readq(), readl(), readw(), readb(), writeq(), writel(), writew(), writeb()</span><br></pre></td></tr></tbody></table></figure>
<p>These are the most generic accessors, providing serialization against other MMIO accesses and DMA accesses as well as fixed endianness for accessing little-endian PCI devices and on-chip peripherals. Portable device drivers should generally use these for any access to __iomem pointers.</p>
<p>Note that posted writes are not strictly ordered against a spinlock, see Documentation/driver-api/io_ordering.rst.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readq_relaxed(), readl_relaxed(), readw_relaxed(), readb_relaxed(),</span><br><span class="line">writeq_relaxed(), writel_relaxed(), writew_relaxed(), writeb_relaxed()</span><br></pre></td></tr></tbody></table></figure>
<p>On architectures that require an expensive barrier for serializing against DMA, these “relaxed” versions of the MMIO accessors only serialize against each other, but contain a less expensive barrier operation. A device driver might use these in a particularly performance sensitive fast path, with a comment that explains why the usage in a specific location is safe without the extra barriers.</p>
<p>See memory-barriers.txt for a more detailed discussion on the precise ordering guarantees of the non-relaxed and relaxed versions.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ioread64(), ioread32(), ioread16(), ioread8(),</span><br><span class="line">iowrite64(), iowrite32(), iowrite16(), iowrite8()</span><br></pre></td></tr></tbody></table></figure>
<p>These are an alternative to the normal readl()/writel() functions, with almost identical behavior, but they can also operate on __iomem tokens returned for mapping PCI I/O space with pci_iomap() or ioport_map(). On architectures that require special instructions for I/O port access, this adds a small overhead for an indirect function call implemented in lib/iomap.c, while on other architectures, these are simply aliases.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ioread64be(), ioread32be(), ioread16be()</span><br><span class="line">iowrite64be(), iowrite32be(), iowrite16be()</span><br></pre></td></tr></tbody></table></figure>
<p>These behave in the same way as the ioread32()/iowrite32() family, but with reversed byte order, for accessing devices with big-endian MMIO registers.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hi_lo_readq(), lo_hi_readq(), hi_lo_readq_relaxed(), lo_hi_readq_relaxed(),</span><br><span class="line">ioread64_lo_hi(), ioread64_hi_lo(), ioread64be_lo_hi(), ioread64be_hi_lo(),</span><br><span class="line">hi_lo_writeq(), lo_hi_writeq(), hi_lo_writeq_relaxed(), lo_hi_writeq_relaxed(),</span><br><span class="line">iowrite64_lo_hi(), iowrite64_hi_lo(), iowrite64be_lo_hi(), iowrite64be_hi_lo()</span><br></pre></td></tr></tbody></table></figure>
<p>Some device drivers have 64-bit registers that cannot be accessed atomically on 32-bit architectures but allow two consecutive 32-bit accesses instead. Since it depends on the particular device which of the two halves has to be accessed first, a helper is provided for each combination of 64-bit accessors with either low/high or high/low word ordering. A device driver must include either &lt;linux/io-64-nonatomic-lo-hi.h&gt; or &lt;linux/io-64-nonatomic-hi-lo.h&gt; to get the function definitions along with helpers that redirect the normal readq()/writeq() to them on architectures that do not provide 64-bit access natively.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__raw_readq(), __raw_readl(), __raw_readw(), __raw_readb(),</span><br><span class="line">__raw_writeq(), __raw_writel(), __raw_writew(), __raw_writeb()</span><br></pre></td></tr></tbody></table></figure>
<p>These are low-level MMIO accessors without barriers or byteorder changes and architecture specific behavior. Accesses are usually atomic in the sense that a four-byte __raw_readl() does not get split into individual byte loads, but multiple consecutive accesses can be combined on the bus. In portable code, it is only safe to use these to access memory behind a device bus but not MMIO registers, as there are no ordering guarantees with regard to other MMIO accesses or even spinlocks. The byte order is generally the same as for normal memory, so unlike the other functions, these can be used to copy data between kernel memory and device memory.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inl(), inw(), inb(), outl(), outw(), outb()</span><br></pre></td></tr></tbody></table></figure>
<p>PCI I/O port resources traditionally require separate helpers as they are implemented using special instructions on the x86 architecture. On most other architectures, these are mapped to readl()/writel() style accessors internally, usually pointing to a fixed area in virtual memory. Instead of an __iomem pointer, the address is a 32-bit integer token to identify a port number. PCI requires I/O port access to be non-posted, meaning that an outb() must complete before the following code executes, while a normal writeb() may still be in progress. On architectures that correctly implement this, I/O port access is therefore ordered against spinlocks. Many non-x86 PCI host bridge implementations and CPU architectures however fail to implement non-posted I/O space on PCI, so they can end up being posted on such hardware.</p>
<p>In some architectures, the I/O port number space has a 1:1 mapping to __iomem pointers, but this is not recommended and device drivers should not rely on that for portability. Similarly, an I/O port number as described in a PCI base address register may not correspond to the port number as seen by a device driver. Portable drivers need to read the port number for the resource provided by the kernel.</p>
<p>There are no direct 64-bit I/O port accessors, but pci_iomap() in combination with ioread64/iowrite64 can be used instead.</p>
<h1 id="device-memory-mapping-modes"><a class="markdownIt-Anchor" href="#device-memory-mapping-modes"></a> Device memory mapping modes</h1>
<p>Some architectures support multiple modes for mapping device memory. ioremap_*() variants provide a common abstraction around these architecture-specific modes, with a shared set of semantics.</p>
<p>ioremap() is the most common mapping type, and is applicable to typical device memory (e.g. I/O registers). Other modes can offer weaker or stronger guarantees, if supported by the architecture. From most to least common, they are as follows:</p>
<h2 id="ioremap"><a class="markdownIt-Anchor" href="#ioremap"></a> ioremap()</h2>
<ul>
<li>
<p>Uncached（无缓存）：</p>
<p>CPU-side caches are bypassed, and all reads and writes are handled directly by the device</p>
</li>
<li>
<p>No speculative operations（无预测执行，可以认为是无乱序执行）：</p>
<p>the CPU may not issue a read or write to this memory, unless the instruction that does so has been reached in committed program flow.</p>
</li>
<li>
<p>No reordering（无重排序，可以理解为加了强内存屏障指令）：</p>
<p>The CPU may not reorder accesses to this memory mapping with respect to each other. On some architectures, this relies on barriers in readl_relaxed()/writel_relaxed().</p>
</li>
<li>
<p>No repetition：</p>
<p>The CPU may not issue multiple reads or writes for a single program instruction.</p>
</li>
<li>
<p>No write-combining（无写合并，cache 的一种策略）：</p>
<p>Each I/O operation results in one discrete read or write being issued to the device, and multiple writes are not combined into larger writes. This may or may not be enforced when using __raw I/O accessors or pointer dereferences.</p>
</li>
<li>
<p>Non-executable：</p>
<p>The CPU is not allowed to speculate instruction execution from this memory (it probably goes without saying, but you’re also not allowed to jump into device memory).</p>
</li>
</ul>
<h2 id="ioremap_wc"><a class="markdownIt-Anchor" href="#ioremap_wc"></a> ioremap_wc()</h2>
<p>Maps I/O memory as normal memory with write combining. Unlike ioremap(),</p>
<ul>
<li>The CPU may speculatively issue reads from the device that the program didn’t actually execute, and may choose to basically read whatever it wants.</li>
<li>The CPU may reorder operations as long as the result is consistent from the program’s point of view.</li>
<li>The CPU may write to the same location multiple times, even when the program issued a single write.</li>
<li>The CPU may combine several writes into a single larger write.</li>
</ul>
<p>This mode is typically used for video framebuffers, where it can increase performance of writes. It can also be used for other blocks of memory in devices (e.g. buffers or shared memory), but care must be taken as accesses are not guaranteed to be ordered with respect to normal ioremap() MMIO register accesses without explicit barriers.</p>
<p>On a PCI bus, it is usually safe to use ioremap_wc() on MMIO areas marked as<br>
IORESOURCE_PREFETCH, but it may not be used on those without the flag. For on-chip devices, there is no corresponding flag, but a driver can use ioremap_wc() on a device that is known to be safe.</p>
<h2 id="ioremap_wt"><a class="markdownIt-Anchor" href="#ioremap_wt"></a> ioremap_wt()</h2>
<p>Maps I/O memory as normal memory with write-through caching. Like ioremap_wc(), but also</p>
<p>The CPU may cache writes issued to and reads from the device, and serve reads from that cache.</p>
<p>This mode is sometimes used for video framebuffers, where drivers still expect writes to reach the device in a timely manner (and not be stuck in the CPU cache), but reads may be served from the cache for efficiency. However, it is rarely useful these days, as framebuffer drivers usually perform writes only, for which ioremap_wc() is more efficient (as it doesn’t needlessly trash the cache). Most drivers should not use this.</p>
<h2 id="ioremap_np"><a class="markdownIt-Anchor" href="#ioremap_np"></a> ioremap_np()</h2>
<p>就像 ioremap() 一样，但明确请求非发布写语义。ioremap_np() 明确请求非发布语义，这意味着写入指令将不会在设备接收到写入数据之前完成。裸的 ioremap_np() 仅在某些架构上可用；在其他架构上，它始终返回 NULL。驱动程序通常不应使用它。</p>
<h2 id="ioremap_uc"><a class="markdownIt-Anchor" href="#ioremap_uc"></a> ioremap_uc()</h2>
<p>它也将内存标记为非缓存，可移植驱动程序应避免使用 ioremap_uc()。</p>
<h2 id="ioremap_cache将-io-内存当作普通-ram-使用支持-cache"><a class="markdownIt-Anchor" href="#ioremap_cache将-io-内存当作普通-ram-使用支持-cache"></a> ioremap_cache()（将 I/O 内存当作普通 RAM 使用，支持 cache）</h2>
<p>ioremap_cache() effectively maps I/O memory as normal RAM. CPU write-back caches can be used, and the CPU is free to treat the device as if it were a block of RAM.</p>
<h1 id="architecture-example"><a class="markdownIt-Anchor" href="#architecture-example"></a> Architecture example</h1>
<p>Here is how the above modes map to memory attribute settings on the ARM64 architecture:</p>
<p>±-----------------------±-------------------------------------------+<br>
| API                    | Memory region type and cacheability        |<br>
±-----------------------±-------------------------------------------+<br>
| ioremap_np()           | Device-nGnRnE                              |<br>
±-----------------------±-------------------------------------------+<br>
| ioremap()              | Device-nGnRE                               |<br>
±-----------------------±-------------------------------------------+<br>
| ioremap_uc()           | (not implemented)                          |<br>
±-----------------------±-------------------------------------------+<br>
| ioremap_wc()           | Normal-Non Cacheable                       |<br>
±-----------------------±-------------------------------------------+<br>
| ioremap_wt()           | (not implemented; fallback to ioremap)     |<br>
±-----------------------±-------------------------------------------+<br>
| ioremap_cache()        | Normal-Write-Back Cacheable                |<br>
±-----------------------±-------------------------------------------+</p>
<p>说明：ARM64 将内存分为两种一种是 Device 类型、一种是 Normal</p>
<p>对于 Device 内存有：</p>
<ul>
<li>
<p>Gathering 或者 non Gathering (G or nG)：</p>
<p>这个特性表示对多个 memory 的访问是否可以合并，如果是 nG，表示处理器必须严格按照代码中内存访问来进行，不能把两次访问合并成一次。例如：代码中有 2 次对同样的一个地址的读访问，那么处理器必须严格进行两次 read transaction。</p>
</li>
<li>
<p>Re-ordering (R or nR)：</p>
<p>这个特性用来表示是否允许处理器对内存访问指令进行重排。nR 表示必须严格执行 program order。</p>
</li>
<li>
<p>Early Write Acknowledgement (E or nE)：</p>
<p>PE 访问 memory 是有问有答的（更专业的术语叫做 transaction），对于 write 而言，PE 需要 write ack 操作以便确定完成一个 write transaction。为了加快写的速度，系统的中间环节可能会设定一些 write buffer。nE 表示写操作的 ack 必须来自最终的目的地而不是中间的 write buffer。</p>
</li>
</ul>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>《Linux Document》</p>

      </div>
      
      
      
    </div>
  <ul class="breadcrumb">
            <li><a href="/note/">NOTE</a></li>
            <li><a href="/note/Blog/">BLOG</a></li>
            <li><a href="/note/Blog/LinuxDriver/">LINUXDRIVER</a></li>
            <li>LINUXDRIVERBASEDEVICEIO</li>
  </ul>

    
    


    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">CarlyleLiu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">488k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">29:35</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhcmx5bGVsaXU=" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline.carlyleliu.vip","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"(发表评论)","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":["nick"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/note/Blog/LinuxDriver/LinuxDriverBaseDeviceIO.html"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
