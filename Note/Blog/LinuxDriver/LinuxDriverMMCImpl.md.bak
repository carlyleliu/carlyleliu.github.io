---
title: Linux驱动之MMC子系统（二）实现分析
categories: 
- Linux
- 驱动
date: 2020-10-10 02:40:56
tags: Linux驱动
---

# 概述
在MMC子系统中，主要包含MMC总线、SDIO总线两个部分，其中MMC部分则主要用于适配MMC卡、SD卡、TF卡等存储设备，而SDIO部分则主要用于实现针对SDIO接口连接的设备（wifi、bluetooth、uart、gps、esata等）

## MMC总线
MMC协议是一个总线协议，因此包括Host controller、Bus、Card三类实体。相应的，MMC framework抽象出了host、bus、card三个软件实体，以便和硬件一一对应：

- host：负责驱动Host controller，提供诸如访问card的寄存器、检测card的插拔、读写card等操作方法。从设备模型的角度看，host会检测卡的插入，并向bus注册MMC card设备。
- bus：是MMC bus的虚拟抽象，以标准设备模型的方式，收纳MMC card（device）以及对应的MMC driver（driver）。
- card：抽象具体的MMC卡，由对应的MMC driver驱动（从这个角度看，可以忽略MMC的技术细节，只需关心一个个具有特定功能的卡设备，如存储卡、WIFI卡、GPS卡等等）。

三者之间的关系如下：[原图](https://www.processon.com/view/link/616255921e085340f83d5a65)
![](/picture/linux_driver/mmc/MMC_Framework.png)


## SDIO总线
dio总线驱动模型和mmc类型，结构体上的区别为其driver类型为sdio_driver，并增加了sdio_func结构体变量（该结构体包含了该sdio设备相关的厂商id、设备id，同时包含了mmc_card），与mmc总线驱动模型的区别为：

- 因sdio主要突出接口概念，其设备端可以连接wifi、gps等设备，因此其外设备驱动需要由驱动工程师自己实现，sdio驱动模块不提供对应的驱动，如下：[原图](https://www.processon.com/view/link/616258711efad41d824bb2d7)
![](/picture/linux_driver/mmc/SDIO_Framework.png)


<!--more-->

# 数据结构
MMC子系统的数据结构如下：[原图](https://www.processon.com/view/link/61630eb7e401fd3c248dca7c)
![](/picture/linux_driver/mmc/MMC_Struct.png)

- mmc_host   
    MMC core使用struct mmc_host结构抽象具体的MMC host controller，该结构的定义位于“include/linux/mmc/host.h”中，它既可以用来描述MMC控制器所具有的特性、能力（host driver关心的内容），也保存了host driver运行过程中的一些状态、参数（MMC core关心的内容）

- mmc_card   
    struct mmc_card是mmc core由mmc设备抽象出来的card设备的结构体，用于代表一个mmc设备。mmc card类型（mmc_card->type）如下
    ```c
    #define MMC_TYPE_MMC        0       /* MMC card */
    #define MMC_TYPE_SD         1       /* SD card */
    #define MMC_TYPE_SDIO       2       /* SDIO card */
    #define MMC_TYPE_SD_COMBO   3       /* SD combo (IO+mem) card */
    ```

- mmc_host_ops   
    struct mmc_host_ops抽象并集合了MMC host controller所有的操作函数集

- mmc_pwrseq   
    MMC framework的power sequence是一个比较有意思的功能，它提供一个名称为struct mmc_pwrseq_ops的操作函数集，集合了power on、power off等操作函数，用于控制MMC系统的供电。与此同时，MMC core提供了一个通用的pwrseq的管理模块（drivers/mmc/core/pwrseq.c），以及一些简单的pwrseq策略（如drivers/mmc/core/pwrseq_simple.c、drivers/mmc/core/pwrseq_emmc.c），最终的目的是，通过一些简单的dts配置，即可正确配置MMC的供电

- mmc_ios   
    struct mmc_ios中保存了MMC总线当前的配置情况。

- mmc_supply   
    struct mmc_supply中保存了两个struct regulator指针（如下），用于控制MMC子系统有关的供电（vmmc和vqmmc）。vmmc是卡的供电电压，一般连接到卡的VDD管脚上。而vqmmc则用于上拉信号线（CMD、CLK和DATA[6]）。通常情况下vqmmc使用和vmmc相同的regulator，同时供电即可。后来，一些高速卡（例如UHS SD）要求在高速模式下，vmmc为3.3v，vqmmc为1.8v，这就需要两个不同的regulator独立控制。

- mmc_request   
    struct mmc_request封装了一次传输请求。要理解这个数据结构，需要先了解MMC的总线协议，在eMMC的spec中，称总线协议为“message-based MultiMediaCard bus protocol”，这里的message由三种信标（token）组成：Command，用于启动（或者停止）一次传输，由Host通过CMD line向Card发送；Response，用于应答上一次的Command，由Card通过CMD line想Host发送；Data，传输数据，由Host（或者Card）通过DATA lines向Card（或者Host发送）。以上token除了Command之外，剩余的两个（Response和Data）都是非必需的，也就是说，一次传输可以是：不需要应答、不需要数据传输的Command；需要应答、不需要数据传输的Command；不需要应答、需要数据传输的Command；不需要应答、不需要数据传输的Command。Command token的格式只有一种（具体可参考[2]中“Command token format”有关的表述），长度为48bits，包括Start bit(0)、Transmitter bit(1, host command)、Content(38bits)、CRC checksum(7bits)、Stop bit(1)。根据内容的不同，Response token的格式有5中，分别简称为R1/R3/R4/R5/R2，其中R1/R3/R4/R5的长度为48bits，R2为136bits（具体可参考[2]中“Response token format”有关的表述）。对于包含了Data token的Command，有两种类型：Sequential commands，发送Start command之后，数据以stream的形式传输，直到Stop command为止。这种方式只支持1-bit总线模式，主要为了兼容旧的技术，一般不使用；Block-oriented commands，发送Start command之后，数据以block的形式传输（每个block的大小是固定的，且都由CRC保护）。最后，以block为单位的传输，大体上也分为两类：在传输开始的时候（Start command），没有指定需要传输的block数目，直到发送Stop command为止。这种方法在spec中称作“Open-ended”；在传输开始的时候（Start command），指定需要传输的block数据，当达到数据之后，Card会自动停止传输，这样可以省略Stop command。这种方法在spec中称作pre-defined block count。

- mmc_command   
    struct mmc_command结构抽象了一个MMC command。

- mmc_data   
    struct mmc_data结构包含了数据传输有关的内容。

# 实现
## MMC 总线的注册
```c
static int __init mmc_init(void)
{
	int ret;

	ret = mmc_register_bus();
	if (ret)
		return ret;

	ret = mmc_register_host_class();
	if (ret)
		goto unregister_bus;

	ret = sdio_register_bus();
	if (ret)
		goto unregister_host_class;

	return 0;

unregister_host_class:
	mmc_unregister_host_class();
unregister_bus:
	mmc_unregister_bus();
	return ret;
}
```
总线的注册在mmc_init函数中，除了注册mmc总线之外还注册了sdio总线以及host_class,其中mmc_register_bus就是简单的调用bus_register，如下：
```c
static struct bus_type mmc_bus_type = {
	.name		= "mmc",
	.dev_groups	= mmc_dev_groups,
	.match		= mmc_bus_match,
	.uevent		= mmc_bus_uevent,
	.probe		= mmc_bus_probe,
	.remove		= mmc_bus_remove,
	.shutdown	= mmc_bus_shutdown,
	.pm		= &mmc_bus_pm_ops,
};

int mmc_register_bus(void)
{
	return bus_register(&mmc_bus_type);
}
```
这里需要注意几个函数，第一个是match函数，如下：
```c
static int mmc_bus_match(struct device *dev, struct device_driver *drv)
{
	return 1;
}
```
当前将任何 MMC 驱动程序与任何 MMC 卡匹配,实际上mmc协议都是标准化的了，其驱动就一个就可以完成对所有符合mmc标准的设备的驱动。

而probe函数就是简单的调用driver的probe函数，这里不再啰嗦了，跟platform类似。

##  MMC 驱动（mmc_driver）的注册
mmc是属于块设备驱动程序，因此driver分为两部分，一部分是块设备驱动程序，一部分的mmc协议驱动部分，下面分别看下这两部分内容：
block的初始化在linux/drivers/mmc/core/block.c文件里，其函数入口为：
```c
static int __init mmc_blk_init(void)
{
	int res;

    /* 1. 注册rpmb总线 */
	res  = bus_register(&mmc_rpmb_bus_type);
	if (res < 0) {
		pr_err("mmcblk: could not register RPMB bus type\n");
		return res;
	}
    /* 2. 注册rpmb字符设备驱动 */
	res = alloc_chrdev_region(&mmc_rpmb_devt, 0, MAX_DEVICES, "rpmb");
	if (res < 0) {
		pr_err("mmcblk: failed to allocate rpmb chrdev region\n");
		goto out_bus_unreg;
	}

	if (perdev_minors != CONFIG_MMC_BLOCK_MINORS)
		pr_info("mmcblk: using %d minors per device\n", perdev_minors);

	max_devices = min(MAX_DEVICES, (1 << MINORBITS) / perdev_minors);

    /* 3. 注册块设备驱动 */
	res = register_blkdev(MMC_BLOCK_MAJOR, "mmc");
	if (res)
		goto out_chrdev_unreg;

    /* 4. 注册mmc driver */
	res = mmc_register_driver(&mmc_driver);
	if (res)
		goto out_blkdev_unreg;

	return 0;

out_blkdev_unreg:
	unregister_blkdev(MMC_BLOCK_MAJOR, "mmc");
out_chrdev_unreg:
	unregister_chrdev_region(mmc_rpmb_devt, MAX_DEVICES);
out_bus_unreg:
	bus_unregister(&mmc_rpmb_bus_type);
	return res;
}
```

- RPMB分区   
    在mmc驱动的第一篇中已经说明了rpmb分区的作用，这里再重复一下：RPMB Partition PMB 是 Replay Protected Memory Block 的简称，它通过 HMAC SHA-256 和 Write Counter 来保证保存在 RPMB 内部的数据不被非法篡改。 在实际应用中，RPMB 分区通常用来保存安全相关的数据，例如指纹数据、安全支付相关的密钥等。

- block设备注册   
    register_blkdev(MMC_BLOCK_MAJOR, "mmc")用来注册mmc的块设备驱动，没什么好说的。

- mmc driver注册   
    mmc_register_driver就是简单的调用driver_register注册一个driver，一切都是熟悉的面孔，设备驱动模型。注册的结构体如下：
    ```c
    static struct mmc_driver mmc_driver = {
	    .drv		= {
	    	.name	= "mmcblk",
	    	.pm	= &mmc_blk_pm_ops,
	    },
	    .probe		= mmc_blk_probe,
	    .remove		= mmc_blk_remove,
	    .shutdown	= mmc_blk_shutdown,
    };
    ```
    mmc_blk_probe是mmc driver的核心，会完成很多工作，例如对支持的命令的检查，分配和初始化gendisk结构，添加gendisk结构体，初始化请求队列等等。这个是一个标准化的流程，本人这里也没有详细了解，感兴趣的可以去阅读源码。

## MMC 设备的注册
MMC设备主要包括主设备host和从设备card两部分，而主设备host将被封装在 platform_device 中注册到驱动模型中。以mmc_spi.c为例，函数入口如下：
```c
static struct spi_driver mmc_spi_driver = {
	.driver = {
		.name =		"mmc_spi",
		.of_match_table = mmc_spi_of_match_table,
	},
	.probe =	mmc_spi_probe,
	.remove =	mmc_spi_remove,
};

module_spi_driver(mmc_spi_driver);
```
其中关键的是probe函数，如下：
```c
static int mmc_spi_probe(struct spi_device *spi)
{
	void			*ones;
	struct mmc_host		*mmc;
	struct mmc_spi_host	*host;
	int			status;
	bool			has_ro = false;

    /* 1. 依赖全双工传输，主要是为了减少每次传输的开销 */
	if (spi->master->flags & SPI_MASTER_HALF_DUPLEX)
		return -EINVAL;

    /* 2. MMC 和 SD 规范似乎只关心采样处于上升沿......意味着 SPI 模式 0 或 3。
     * 所以 SPI 模式应该是合法的。 我们将使用模式 0，因为稳定状态为 0，这适用于热
     * 插拔，除非平台数据指定模式 3（如果硬件与模式 0 不兼容）。
     */
	if (spi->mode != SPI_MODE_3)
		spi->mode = SPI_MODE_0;
	spi->bits_per_word = 8;

    /* 3. 准备spi设备 */
	status = spi_setup(spi);
	if (status < 0) {
		dev_dbg(&spi->dev, "needs SPI mode %02x, %d KHz; %d\n",
				spi->mode, spi->max_speed_hz / 1000,
				status);
		return status;
	}

    /* 4. 我们需要一个供电来完成传输。 这是 CPU 接触这些的唯一时间，因此缓存一致性不是问题。*/
	status = -ENOMEM;
	ones = kmalloc(MMC_SPI_BLOCKSIZE, GFP_KERNEL);
	if (!ones)
		goto nomem;
	memset(ones, 0xff, MMC_SPI_BLOCKSIZE);

    /* 5. 调用host core提供的标志函数分配mmc_host结构体 */
	mmc = mmc_alloc_host(sizeof(*host), &spi->dev);
	if (!mmc)
		goto nomem;

    /* 6. 设置mmc_host成员 */
	mmc->ops = &mmc_spi_ops;
	mmc->max_blk_size = MMC_SPI_BLOCKSIZE;
	mmc->max_segs = MMC_SPI_BLOCKSATONCE;
	mmc->max_req_size = MMC_SPI_BLOCKSATONCE * MMC_SPI_BLOCKSIZE;
	mmc->max_blk_count = MMC_SPI_BLOCKSATONCE;

	mmc->caps = MMC_CAP_SPI;

    /* 7. SPI 不需要 MMC 或 SD 卡的低速设备识别功能，一些 SPI 主机无法处理非常低的速度！*/
	mmc->f_min = 400000;
	mmc->f_max = spi->max_speed_hz;

	host = mmc_priv(mmc);
	host->mmc = mmc;
	host->spi = spi;

	host->ones = ones;

	dev_set_drvdata(&spi->dev, mmc);

    /* 8. platform数据用于连接诸如卡感应和电源切换 gpios 之类的东西。 */
	host->pdata = mmc_spi_get_pdata(spi);
	if (host->pdata)
		mmc->ocr_avail = host->pdata->ocr_mask;
	if (!mmc->ocr_avail) {
		dev_warn(&spi->dev, "ASSUMING 3.2-3.4 V slot power\n");
		mmc->ocr_avail = MMC_VDD_32_33|MMC_VDD_33_34;
	}
	if (host->pdata && host->pdata->setpower) {
		host->powerup_msecs = host->pdata->powerup_msecs;
		if (!host->powerup_msecs || host->powerup_msecs > 250)
			host->powerup_msecs = 250;
	}

	/* 9. 预分配 dma buffers */
	host->data = kmalloc(sizeof(*host->data), GFP_KERNEL);
	if (!host->data)
		goto fail_nobuf1;

	status = mmc_spi_dma_alloc(host);
	if (status)
		goto fail_dma;

	/* 10. 状态/忙回读的设置消息 */
	spi_message_init(&host->readback);
	host->readback.is_dma_mapped = (host->dma_dev != NULL);

	spi_message_add_tail(&host->status, &host->readback);
	host->status.tx_buf = host->ones;
	host->status.tx_dma = host->ones_dma;
	host->status.rx_buf = &host->data->status;
	host->status.rx_dma = host->data_dma + offsetof(struct scratch, status);
	host->status.cs_change = 1;

	/* 11. 注册卡检测irq */
	if (host->pdata && host->pdata->init) {
		status = host->pdata->init(&spi->dev, mmc_spi_detect_irq, mmc);
		if (status != 0)
			goto fail_glue_init;
	}

	/* pass platform capabilities, if any */
	if (host->pdata) {
		mmc->caps |= host->pdata->caps;
		mmc->caps2 |= host->pdata->caps2;
	}

	status = mmc_add_host(mmc);
	if (status != 0)
		goto fail_add_host;

	/*
	 * Index 0 is card detect
	 * Old boardfiles were specifying 1 ms as debounce
	 */
	status = mmc_gpiod_request_cd(mmc, NULL, 0, false, 1000);
	if (status == -EPROBE_DEFER)
		goto fail_add_host;
	if (!status) {
		/*
		 * The platform has a CD GPIO signal that may support
		 * interrupts, so let mmc_gpiod_request_cd_irq() decide
		 * if polling is needed or not.
		 */
		mmc->caps &= ~MMC_CAP_NEEDS_POLL;
		mmc_gpiod_request_cd_irq(mmc);
	}
	mmc_detect_change(mmc, 0);

	/* Index 1 is write protect/read only */
	status = mmc_gpiod_request_ro(mmc, NULL, 1, 0);
	if (status == -EPROBE_DEFER)
		goto fail_add_host;
	if (!status)
		has_ro = true;

	dev_info(&spi->dev, "SD/MMC host %s%s%s%s%s\n",
			dev_name(&mmc->class_dev),
			host->dma_dev ? "" : ", no DMA",
			has_ro ? "" : ", no WP",
			(host->pdata && host->pdata->setpower)
				? "" : ", no poweroff",
			(mmc->caps & MMC_CAP_NEEDS_POLL)
				? ", cd polling" : "");
	return 0;
    ...
}
```
mmc_spi_probe函数流程较为复杂，这里以一张图来展示其函数调用关系，如下：[原图](https://www.processon.com/view/link/6164696c5653bb1336d5ae7d)
![](/picture/linux_driver/mmc/mmc_spi_probe.png)

这里做几点说明：

- mmc_alloc_host   
    动态分配内存给 struct mmc_host 结构体，并对结构体成员初始化，调用 device_initialize() 对 host->class_dev 进行初始化，包括 kobject 、 mutex 等，初始化自旋锁、等待队列 (waitqueue)和延迟的工作队列 (Delayed Work)，其中，用处理函数 mmc_rescan() 来初始化延迟的工作队列 host->detect。

- mmc_add_host   
    device_add() 将 host->class_dev 加入到sysfs中device层次结构中，调用 mmc_start_host() 启动主设备，也即MMC设备开始正常工作。

- _mmc_detect_change   
    mmc_detect_change() 函数用来检测MMC状态的改变，具体是通过调度工作队列实现。mmc_rescan() 作为处理函数被绑定在延迟工作队列 host->detect 上。因此，此处实际上是启动 mmc_rescan() 的执行过程。

- mmc_rescan   
    mmc_rescan(&host->detect) 会调用 mmc_rescan_try_freq(host, max(freqs[i], host->f_min)) ，进一步调用重要的 mmc_attach_mmc(host) 函数，将MMC设备加入到驱动模型中。

- mmc_attach_mmc   
    获取MMC基本硬件初始化信息，例如OCR register （工作电压相关），mmc_init_card(host, rocr, NULL) ：MMC card初始化，将MMC card加入到设备驱动模型中。

- mmc_add_card   
    这里最关键的一步是熟悉的 device_add(&card->dev) 函数，它将mmc card添加到驱动模型中。注意到 card.dev 的 parent 被设置为 mmc.class_dev。


# 参考文献   
[https://blog.csdn.net/lickylin/article/details/104717742](https://blog.csdn.net/lickylin/article/details/104717742)    
[http://www.wowotech.net/comm/mmc_framework_arch.html](http://www.wowotech.net/comm/mmc_framework_arch.html)   
[https://blog.csdn.net/ooonebook/article/details/55105481](https://blog.csdn.net/ooonebook/article/details/55105481)    


