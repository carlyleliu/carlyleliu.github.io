---
title: Linux驱动之IIO子系统(一)基础篇
categories: 
- Linux
- 驱动
date: 2020-10-01 04:45:07
tags: Linux驱动
---

# 概述
工业I/O （Industrial I/O，IIO）是专用于模数转换器 （ADC）和数模转换器（DAC）的内核子系统。随着分散在内核源代码上由不同代码守现的传感器（具有模拟到数字或数字到模拟转换功能的测量设备）数量的增加，集中它们变得非常必要。这就是IIO框架所要实现的功能，它以通用一致的方式来实现。乔纳杰.卡梅隆和Linux-IlO社区从2009年开始开发它。

加速度计、陀螺仪、电流/电压测量芯片、光传威器、压力传威器等都属于II0系列设备。
IIO模型基于设备和通道架构。

- 设备代表芯片本身，它位于整个层次结构的顶层。
- 通道表示设备的单个采集线，设备可能有一个或多个通道。例如，加速度计是具有3个通道的设备，每个轴（X、Y和Z）都有一个通道。

IIO芯片是物理和硬件传感器/转换器，它作为字符设备提供给用户空间（当支持触发缓冲时）和sysfs目录项，该目录中包含一组文件，其中一些代表通道。单个通道用单个sysfs文件项表示。下面是从用户空间与IIO驱动程序进行交互的两种方式。

- /sys/bus/iio/iio：deviceX/：代表传感器及其通道。
- /dev/iio：devicex：字符设备，用于输出设备事件和数据缓冲区。

下图显示IIO框架在内核和用户空间之间的组织方式。该驱动程序使用IIO内核提供的功能和API来管理硬件，并向IIO内核报告处理情况。然后，1I0子系统通过sysfs接口和字符设备将整个底层机制抽象到用户空间，用户可以在其上执行系统调用。[原图](https://www.processon.com/view/link/61569841e401fd6be07b8c31)
![](/picture/linux_driver/iio/IIO_Framework.png)

<!--more-->

而在IIO子系统内部，则主要包括如下四部分的内容：

- iio buffer用于处理需要进行连续采集的数据，当一个IIO device的各通道数据支持连续采集时，则调用iio buffer模块提供的接口，创建iio buffer用于存储连续的数据，同时该模块提供字符设备文件的注册，因此应用程序通过字符设备文件即可读取该IIO device各通道连续采集的数据。
- 当IIO DEVICE支持连续采集时，一般需要绑定一种触发方法，作为数据到达的信号，而IIO子系统提个iio trigger实现该功能，当iio trigger信号到后，则将数据pu到iio buffer中（目前IIO子系统提供了iio trigger的注册、注销与查找接口，且系统中已提供了iio-trig-sysfs、iio-trig-gpio、iio-trig-irq等通用的触发方这种方 式是不是很眼熟，在led子系统中，也包含为led-trigger，一个led-class可以和一个led-trigger绑定，从而实现对led亮度的控制策略）。
- 针对温度传感器等器件，也会进行事件触发（如温度传感器设置温度上限阈值，当温度高于该阈值后，则触发中断信号），因此IIO子系统提供了iio event模块，iio eve模块提供了字符设备操作接口用于对event的监控（该字符设备操作接口并没有创建字符设备文件，而是在iio buffer的ioctl中开启event monitor，然后anon_inode_getfd创建了一个匿名inode节点，并设置inode的ops接口等）。
- 以上3个都是iio 子系统各子功能，而iio core则主要实现iio device的创建，并根据传递的参数决定是否需要创建iio buffer等，提供了iio device的内存申、请与注  销接口。

# 数据结构
IIO子系统实现的数据结构如下：[原图](https://www.processon.com/view/link/615716fff346fb69a722043b)
![](/picture/linux_driver/iio/IIO_Struct.png)

## iio_dev数据结构 

- modes：表示设备支持的不同模式。支持的模式如下。

    - INDIO_DIRECT_MODE：设备提供sysfs类型的接口。
    - INDIO_BUFFER_TRIGGERED：设备支持硬件触发。当使用iio_triggered_buffer_setup()函数设置触发缓冲区时，该模式会自动添加到设备。 
    - INDIO_BUFFER_HARDWARE：设备具有硬件缓冲区。
    - INDIO_ALL_BUFFER_MODES：上述两种模式的组合。

- currentmode：设备实际使用的模式。
- dev：IIO设备绑定的sruct device（根据Linux设备型号）。
- buffer：数据缓冲区，使用触发缓冲区模式时被推送到用户空间。当使用iio triggered_buffer_setup函数启用触发缓冲区支持时，会自动分配缓冲区并把它关联到设备。
- scan_bytes：捕获并提供给缓冲区的字节数。从用户空间使用缓冲区的大小至少应为indio->scan_bytes字节
- available_scan_masks：可选数组的位掩码。使用触发缓冲区时，可以启用通道，以捕获数据并将其反馈给II0缓冲区。如果不想启用某些通道，则应该填写该数组，只启用允许的通道。以下例子为加速度计（带有X、Y和Z通道）提供扫描掩码：
```c
/*
 * 允许掩码0x7（0b111）和0（0b000）
 * 这意味着可以不启用或全部启用
 * .例如，不能只启用x和Y
 */
static const unsigned long my_scan_masks[] = {0x7,0};
indio_dev->available_scan_masks = my_scan_masks;
```
- active_scan_mask：已启用通道的位掩码。只有来自这些通道的数据才应该被推入buffer。例如，对于8通道ADC转换器，如果仅启用第一（0）、第三 （2）和最后（7）通道，则位掩码将为0b10000101（0x85）。active_scan_mask将被设置为0x85。然后驱动程序可以使用for_each_set_bit宏遍历每个设置位（setbit），根据通道获取数据并填充缓冲区。

- scan_timestamp：指出是否将捕获时间戳推入缓冲区。如果为true，则时间戳将作为缓冲区的最后一个元素进行推送。时间戳是8字节（64位）长。
- trig：当前设备的触发器（当支持缓冲模式时）。
- pollfunc：在接收的触发器上运行的函数。
- channels：表格通道规范结构，用于描述设备的每个通道。
- num_channels： channels中指定的通道数量。
- name：设备名称。
- info：来自驱动程序的回调和常量信息。
- setup_ops：启用/禁用缓冲区之前和之后调用的一组回调函数。
 
## iio_info数据结构 

- attrs：设备属性。
- read_raw：用户读取设备sysfs文件属性时运行的回调函数。mask参数是位掩码，说明请求的值是哪种类型。chan通道参数指出有关的通道。它可用于采样频率，用于将原始值转换为可用值或原始值自身的比例。
- write_raw：用于向设备写入值的回调函数。例如，可以使用它来设置采样频率。 

## IIO通道
通道代表单条采集线。例如，加速度计有3个通道（X、Y、Z），因为每个轴代表单个采集线。iio_chan_spec结构体表示和描述内核中的单个通道：
该结构中每个元素的含义如下。

- type：指出通道产生的测量类型。对于电压测量，它应该是IIO_VOLTAGE；对于光传感器，它是IIO_LIGHT；对于加速度计，使用IIO_ACCEL。所有可用的类型在include/uapi/linux/iio/types.h中定义为enum iio_chan_type。要为给定的转换器编写驱动程序，请查看该文件，了解每个通道所属类型。
- channel：当.indexed设置为1时，指定通道索引。
- channel2：当.modified设置为1时，指定通道修饰符。
- modified：指出修饰符是否应用于此通道属性名称。在这种情况下，修饰符在.channel2中设置（例如，IIO_MOD_X、IIO_MOD_Y、IIO_MOD_Z是围绕xvz轴的轴向传感器的修饰符）。可用修饰符列表在内核IIO头文件中定义头enum iio_modifier。修饰符仅影响sysfs中的通道属性名称，而不是值.
- indexed：指出通道属性名称是否具有索引。如果有，则在.channel字段指定索引。
- scan_index和scan_type：当使用缓冲区触发器时，这些字段用于标识来自缓冲区的元素。scan_index设置捕获通道在缓冲区内的位置。具有较低scan_index的通道将放置在具有较高索引的通道之前。将.scan_index设置为-1将阻止通道缓冲捕获（scan_elements目录中没有条目）。

提供给用户空间的通道sysfs属性以位掩码的形式指定。根据其共享信息，可以将属性设置为以下掩码之一。

- info_mask_separate：将属性标记为专属于此通道。
- info_mask_shared_by_type：将该属性标记为由相同类型的所有通道共享导出的信息由同一类型的所有通道共享。
- info_mask_shared_by_dir：将属性标记为由相同方向的所有通道共享。导出的信息由相同方向的所有通道共享。
- info_mask_shared_by_all：将该属性标记为由所有通道共享，无论它们的类型或方向如何。导出的信息由所有通道共享。这些属性枚举的位掩码全部在include/linux/iio/iio.h中定义：
```c
enum iio_chan info enum {
    IIO CHAN INFO RAW = O,
    IIO CHAN INFO PROCESSED,
    IIO CHAN INFO SCALE
    IIO CHAN INFO OFFSET
    IIO CHAN INFO CALIBSCALE,
    [...]
};
```

###  通道属性和命名约定
属性名称由IIO内核按照以下模式自动生成：{direction}_{type}_{index}_{modifier}_{info_mask}。

- directiion对应于属性方向，取值依据drivers/iio/industrialio-core.c中的struct iio_direction结构：
```c
static const char * const iio_direction [] = {
    [0] ="in",
    [1] ="out",
};
```

- type对应于通道类型，取值依据字符数组const iio_chan_type_name_spec： 
```c
static const char * const iio_chan type name_spec []={
    [IIO_VOLTAGE] = "voltage",
    [IIO_CURRENT] = "current",
    [IIO_POWER] = "power",
    [IIO_ACCEL] = "accel"
    [...]
    [IIO_UVINDEX] = "uvindex",
    [IIO_ELECTRICALCONDUCTIVITY] = "electricalconductivity",
    [IIO_COUNT] = "count",
    [IIO_INDEX] = "index"
    [IIO_GRAVITY] = "qravity",
};
```
- index（索引模式）取决于通道的.indexed字段是否设置。如果设置，索引将从.channel字段获取以替换{index}模式。
- modifier（修饰符模式）取决于通道的.modified字段是否设置。如果设置，修饰符将从.channel2字段中获取，{modifier}模式将根据字符数组struct iio_modifier_names结构进行替换：
```c
static const char * const iio_modifier_names[] = {
    [IIO_MOD_X] = "x",
    [IIO_MOD_Y] = "y",
    [IIO_MOD_Z] ="z",
    [IIO_MOD_X_AND_Y] = "x&y",
    [IIO_MOD X_AND_Z] ="x&z",
    [IIO_MOD_Y_AND_Z] = "y&z",
    [...]
    [IIO_MOD_CO2] = "co2",
    [IIO_MOD_VOC] = "vOC"
};
```

- info mask取决干字符数组iio_chan_info_postfix中通道信息掩码、私有或共享、索引值：
```c
/*依赖于这些共享对*/
static const char * const iio_chan_info_postfix[] = {
    [IIO_CHAN_INFO_RAW] = "raw"
    [IIO_CHAN_INFO_PROCESSED] = "input",
    [IIO_CHAN_INFO_SCALE] = "scale",
    [IIO_CHAN_INFO_CALIBBIAS] = "calibbias",
    [...]
    [IIO_CHAN_INFO_SAMP_FREQ] = "sampling frequency"
    [IIO_CHAN_INFO_FREQUENCY] = "frequency",
    [...]
};
```

### 区分通道
当每种通道有多个数据通道时，可能会遇到麻烦：如何识别它们。有两种解决方案：索引和修饰符。

使用索引：假设ADC设备只有一个通道线，则不需要索引。其通道定义如下：
```c
static const struct iio chan spec adc channels[] = 
{
    {
        .type = IIO_VOLTAGE,
        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
    }，
}
```
描述以上通道的属性名称将是in_voltage_raw：
```bash
/sys/bus/iio/iio:deviceX/in_voltage_raw
```
现在，假若该转换器有4个甚至8个通道。如何识别它们？其解决方案是使用索引.indexed字段设置为1将使通道属性名称使用.channel值，而不是{index}模式:
```c
static const struct iio_chanspec_adc_channels[] = {
    {
        .type = IIO_VOLTAGE,
        .indexed = 1,
        .channel = 0,
        .info_mask_separate = BIT(IIO_CHAN_INEO_RAW), 
    },
    {
        .type = IIO_VOLTAGE,
        .indexed = 1,
        .channel = 1,
        .info_mask_separate = BIT(IIO_CHAN_INEO_RAW),
    },
    {
        .type = IIO_VOLTAGE,
        .indexed = 1,
        .channel = 2,
        .info_mask_separate = BIT(IIO_CHAN_INEO_RAW), 
    },
    {
        .type = IIO_VOLTAGE,
        .indexed = 1,
        .channel = 3,
        .info_mask_separate = BIT(IIO_CHAN_INEO_RAW),
    },

```
最终的通道属性如下：
```bash
/sys/bus/iio/iio:deviceX/in_voltage0_raw
/sys/bus/iio/iio:devicex/in_voltage1_raw
/sys/bus/iio/iio:devicex/in_voltage2_raw
/sys/bus/iio/iio:devicex/in_voltage3_raw
```
使用修饰符：假若光传感器具有两个通道，一个用于红外光，另一个用于红外和可见光，没有索引或修饰符，则属性名称为in_intensity_raw。这里使用索引可能容易出错，因为in_intensityo_ir_raw和in_intensityl_ir_raw没有意义。使用修饰符有助于提供有意义的属性名称。通道定义可以像下面这样：
```
static const struct iio_chan_spec_mylight_channels[] = {
    {
        .type = IIO_INTENSITY,
        .modified = 1
        .channel2 = IIO_MOD_LIGHT_IR,
        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW), 
        .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREO)，
    },
    {
        .type = IIO_INTENSITY,
        .modified = 1,
        .channel2 = IIO_MOD_LIGHT_BOTH
        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW), 
        .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREQ),
    },
    {
        .type = IIO_LIGHT,
        .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),
        .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREQ),
    }，
}，
```
最终属性如下。

- /sys/bus/iio/iio:deviceX/in_intensity_ir_raw：测量IR强度的通道。
- /sys/bus/iio/iio:deviceX/in intensity_both_raw：测量红外和可见光的通道。
- /sys/bus/iio/iio:devicex/in_illuminanceinput：用于处理数据。
- /sys/bus/iio/iio:deviceX/sampling_frequency：用于采样频率，全部通道共享。

# 触发缓冲区支持
在许多数据分析应用中，能够基于某些外部信号（触发器）捕获数据非常有用。这些触发器可能如下。

- 数据就绪信号。
- 连接到某个外部系统（GPIO或其他）的IRQ线。
- 处理器周期性中断。
- 用户空间读/写sysfs中的特定文件。

IIO设备驱动程序与触发器完全无关。触发器可以初始化一个或多个设备上的数据捕获，这些触发器用于填充缓冲区、作为字符设备提供给用户空间。
人们可以开发自己的触发器驱动程序，但这超出了本书的范围。这里集中介绍现有的触发器驱动程序。

- iio-trig-interrupt：这为使用IRQ作为IIO触发器提供支持。在旧的内核版本中，它曾使用的是iio-trig-gpio。启用此触发模式的内核选项是 CONFIG_IIO_INTERRUPT_TRIGGER。如果构建为模块，该模块将称为iio-trig-interrupt。
- iio-tria-hrtimer：提供基于频率的II0触发器，使用HRT作为中断源（自内核v4.5开始）在旧内核版本中，它曾使用的是iio-trig-rtc。负责这种触发模式的内核选项是IIO_ HRTIMER_TRIGGER。如果构建为模块，则该模址称为iio-tria-hrtimer。
- iio-trig-hrtimerciio-tria-sysfs：这分许使用sysfs项触发数据捕获。CONFIG_IIO_SYSFS_TRIGGER是添加此触发模式支持的内核选项。
- iio-tric-hfin-timer：这允许使用blackfin定时器作为IIO触发器（仍于筹备阶段）。

IIO提供API，使用它们可以进行如下操作。

- 声明任意数量的触发器。
- 选择哪些通道的数据将推入缓冲区。

IIO设备提供触发缓冲区支持时，必须设置iio_dev.pollfunc，触发器触发时执行它，该处理程序负责通过indio dev->active_scan_mask查找启用的通道，检索其数据，并使用iio_push_to_buffers_with_timestamp函数将它们提供给 indio_dev->buffer。因此，缓冲区和触发器在IIO子系统中有紧密的联系。 

IIO内核提供了一组辅助函数来设置触发缓冲区，这些函数可以在drivers/iio/sindustrialio-triggered-buffer-c中找到。
以下是驱动程序支持触发缓冲区的步骤。

- 如果需要填写iio_buffer_setupops结构：
```c
const struct iio_buffer_setup_ops sensor_buffer_setup_ops = {
    .preenable= my_sensor_buffer_preenable,
    .postenable = mysensor_buffer_postenable,
    .postdisable =my_sensor_buffer_ postdisable,
    .predisable = my_sensor_buffer_predisable,
};
```

- 编写与触发器关联的上半部。在99%的情况下，必须提供与捕获相关的时间戳： 
```c
irqreturn_t sensor_iio_pollfunc(int irq, void *p)
{
    pf->timestamp = iio_get_time_ns((struct indio_dev*)p); 
    return IRQ_WAKE_THREAD;
}
```

- 编写触发器的下半部，它将从每个启用的通道读取数据，并把它们送入缓冲区
```c
irqreturn_t sensor_trigger_handler(int irq, void *p)
{
    u16 buf[8];
    int bit,i= O;
    struct iio_poll_func *pf = p;
    struct iio_dev *indio_dev = pf->indio_dev;

    /* 这里可使用锁来保护缓冲区 */
    /* mutex_lock(&my_mutex); */

    /* 读取每个活动通道的数据 */
    for_each_set_bit(bit, indio_dev->active_scanmask,
                    indio_dev->masklength)
        buf[i++] = sensor_get_data(bit);

    /*
     * 如果iio_dev.scan_timestamp = true，则捕获时间戳将被推送和存储
     * 在将其推送到设备缓冲区之前，它作为示例数据缓冲区中的最后一个元素
     */
    iio_push_to_buffers_with_timestamp(indio_dev, buf, timestamp); 
    
    /*打开任意锁*/
    /* mutex_unlock(&my_mutex); */

    /*通知触发*/
    iio_trigger_notify_done(indio_dev->trig);
    return IRQ_HANDLED;
}
```

- 在probe函数中，必须在使用iio_device_register()注册设备之前先设置缓冲区本身：
```c
iio_triggered_buffer_setup(indiodev, sensor_iio_polfunc,
                            sensor_trigger_handler,
                            sensor_buffer_setup_ops);
```
这里的神奇函数是iio_triggered_buffer_setup。这也将为设备提供INDIO_DIRECT_MODE功能。当（从用户空间）把触发器指定到设备时，无法知道什么时候会被触发。

在连续缓冲捕获激活时，应该防止（通过返回错误）驱动程序在各个通道上执行sysfs数据捕获（由read_raw()钩子执行），以避免不确定的行为，因为触发器处理程序和read_raw()钩子将尝试同时访问设备。用于检查是否实际使用缓冲模式的函数是iio_buffer_enabled()。钩子看起来像这样:
```c
static int my_read_rawi(struct iio_dev *indio_dev,
                        const struct iio_chan_spec *chan,
                        int *val, int *val2, long mask)
{
    [...]
    switch(mask){
        case IIO_CHAN_INFO_RAW:
        if (iio_buffer_enabled(indio_dev))
            return -EBUSY;
    [...]
}
```
iio_buffer_enabled()函数简单地测试给定IIO设备的缓冲区是否启用。 下面总结一些重要内容。

- iio_buffer_setup_ops：提供缓冲区设置函数，以在缓冲区配置一系列固定步骤（启用/禁用之前之后）中调用。如果未指定，IIO内核则将默认的iio_triggered_buffer_setup_ops提供给设备。
- sensor_iio_pollfunc：触发器的上半部。与每个上半部一样，它在中断环境中运行，必须执行尽可能少的处理。在99%的情况下，只需提供与捕获相关的时间戳。再次重申，可以使用默认的IIO函数iio_pollfunc_storetime.
- sensor_trigger_handler：下半部，它运行在内核线程中，能够执行任何处理，甚至包括获取互斥锁或睡眠。重处理应该发生在这里。它通常从设备中读取数据，将其与上半部中记录的时间戳一起存储在内部缓冲区中，并将其推送到IIO设备缓冲区。

> 对触发缓冲而言，触发器是必需的。它告诉驱动程序何时从设备读取采样数据，并将其放入缓冲区。触发缓冲对编写IIO设备驱动程序而言不是必需的。通过读取通道的原始属性，也可以通过sysfs使用单次捕捉，它只执行一次转换（对于所读取的通道属性）。缓冲模式允许连续转换，从而一次捕获多个通道

## II0触发器和sysfs（用户空间）
sysfs中有两个位置与触发器相关。

- /sys/bus/iio/devices/triggerY/：-旦II0触发器在II0内核中注册并且对应于索引Y的触发器，就会创建该目录。该目录中至少有一个属性，name：触发器名称，之后可用于与设备建立关联。
- /sys/bus/iio/devices/iio：如果设备支持触发缓冲区，则会自动创建目录deviceX/trigger/*。在current_triacer文件中用触发器的名称就可以将触发器与设备相关联起来。

### sysfs触发器接口
svsfs触发器由内核中的CONFIG_IIO_SYSFS_TRTGGER = y配置选项启用，这将导致自动创建/sys/bus/iio/devices/iio_sysfs_trigger/文件夹，该文件夹可用于sysfs触发器管理。该目录中有两个文件：add_trigger和remove_triggero其驱动程序位于drivers/iio/trigger/iio-trig-sysfs.c中。

- add_trigger文件   
这用于创建新的sysfs触发器。将正值（将用作触发器ID）写入该文件即可创建新触发器。它会创建新的sysfs触发器，可在/sys/bus/iio/devices/triggerX处访问，其中X是触发器编号。
例如：
```bash
# echo 2 > add_trigger
```
这将创建新的sysfs触发器，在/sys/bus/iio/devices/trigger2处可访问它。如果系统中已经存在指定ID的触发器，则会返回无效的参数消息。sysfs触发器名称模式是
sysfsstrig{ID}。命令echo 2 > add_trigger将创建触发器/sys/bus/iio/devices/trigger2，其名称为sysfstrig2：
```bash
$ cat/sys/bus/iio/devices/trigger2/name
sysfstrig2
```
每个sysfs触发器至少包含一个文件：trigger_now。 写入该文件将指示在current_trigger中具有相应触发器名称的所有设备开始捕获，并将数据推入它们各自的缓冲区。每个设备缓冲区必须设置其大小，并且必须启用（echo 1 > /sys/bus/iio/devices/iio:devicex/buffer/enable)。

- remove_trigger文件   
要删除触发器，请使用以下命令：
```bash
#echo 2 > remove_trigger
```

- 绑定设备与触发器   
要把设备与指定的触发器关联，需将触发器的名称写入该设备触发器目录下可用的current_trigger文件中。例如，假若需要将设备与索引为2的触发器绑定
```bash
# set trigger2 as current trigger for device0
# echo sysfstrig2 > /sys/bus/iio/devices/ii0:.device0/trigger/current_trigger
```
要解除设备与触发器的绑定，应该将空字符串写入设备触发器目录中的current_trigger文件，如下所示：
```bash
# echo "" > iio:device0/trigger/current_trigger
```

### 中断触发器接口
请看下面的例子：
```c
static struct resource iio_irg_trigger_resources[] = {
    [0] = {
        .start = IRQ_NR_FOR_YOUR_IRQ,
        .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE,
    }，
};

static struct platform_device iio_irq_trigger = {
    .name = "iio interrupt_trigger",
    .num resources = ARRAY_SIZE(iio_irq_trigger_resources),
    .resource = iio_irq_trigger_resources,
};
platform device_register(&iioirq_trigger)
```
声明IRQ触发器，这将导致加载IRQ触发器独立模块。如果其probe函数成功，则会有与触发器相对应的目录。IRQ触发器名称的格式为iratrigX，其中X对应于刚传递的虚拟IRQ，在/proc/interrupt中会看到它：
```bash
$ cd /sys/bus/iio/devices/trigger0/
$ cat name
```
irqtrig85；正如对其他触发器所做的那样，必须用以下方式把该触发器分配给设备，将其名称写入设备的current_trigger文件。
```bash
#echo "irqtrig85" > /sys/bus/iio/devices/iio:device0/trigger/current_trigger
```
现在，中断每次触发时，设备数据将被捕获。

>IRO触发器驱动程序不支持DT，这就是使用开发板init文件的原因但是这没关系，因为驱动程序需要资源、因此无须更改任何代码即可使用DT.

以下设备树节点声明IRQ触发器接口：
```c
mylabel: my_trigger@0{
    compatible = "iio_interrupt_trigger";
    interrupt-parent = <&gpio4>;
    interrupts = <30 0x0>;
};
```
该例子假设IRQ线是属于GPIO控制器节点gpio4的GPIO#30。这包括使用GPIO作为中断源，以便每当GPIO改变到给定状态时，就会产生中断，从而触发捕获。

### hrtimer触发器接口
hrtimer触发器依赖于configfs文件系统（请参阅内核源文件中的Documentation/iio/iio_configfs.txt），它可通过CONFIG_IIO_CONFIGFS配置选项启用，并挂载到系统上（通常位于/config目录下）：
```bash
# mkdir /config
#mount -t configfs none /config
```
现在，加载模块iio-trig-hrtimer将创建可在/config/iio下访问的IIO组，使用户能够在/config/iio/triggers/hrtimer下创建hrtimer触发器。
例如：
```bash
#创建一个hrtimer触发器
$ mkdir /config/iio/triggers/hrtimer/my_trigger_name
#移除触发器
$ rmdir /config/iio/triggers/hrtimer/my_trigger_name
```
每个hrtimer触发器在该触发器目录中都包含单个sampling_frequency属性。

##  II0缓冲区
II0缓冲区提供连续的数据捕获，一次可以同时读取多个数据通道。可通过dev/iio：device字符设备节点从用户空间访问缓冲区。在触发器处理程序中，用于填充缓冲区的函数是iio_push_to_buffers_with_timestamp。负责为设备分配触发缓冲区的函数是iio_triggered_buffer_setup()。

### II0缓冲区的sysfs接口
IIO缓冲区在/sys/bus/iio/iio下有一个关联的属性目录：deviceX/buffer/*。 以下是其一些属性。

- length：缓冲区可存储的数据取样总数（容量）。这是缓冲区包含的扫描数量。 
- enable：激活缓冲区捕获，启动缓冲区捕获。
- watermark：自内核版本v4.2以来，该属性一直可用。它是一个正数，指定阻塞读取应该等待的扫描元素数量。例如，如果使用轮询，则会阻塞直到水印为止。它只有在水印大于所请求的读数量时才有意义，不会影响非阻塞读取。可以用暂停阻止轮询，并在暂停过期后读取可用样本，从而获得最大延迟保证。

# I0缓冲区设置
数据将被读取并推入缓冲区的通道称为扫描元素。它们的配置可通过/sys/bus/iio/iio：deviceX/scan_elements/*目录从用户空间访问，其中包含以下属性。

- en：实际上是属性名称的后缀，用于启用频道。当且仅当其属性不为零时，触发的捕捉将包含此通道的数据取样。例如in_voltage0_en in_voltagelen1_en等。
- type：描述扫描元素数据在缓冲区内的存储，因此描述从用户空间读取它的形式。例如in_voltage0_type。格式为[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]。
    - be或le：指出字节顺序（大端或小端）。
    - s或u：指出符号，带符号（2的补码）或无符号
    - bits：有效数据位数。
    - stroagebits：该通道在缓冲区中占用的位数。例如，一个值可能实际编码是12位（bit），但占用缓冲区中的16位（stroagebit）。因此必须将数据向右移位4次才能得到实际值。该参数取决于设备，应参考设备的数据手册
    - shift：表示在屏蔽掉未使用的位之前应该移位数据值的次数。这个参数并不总是需要的。如果有效位数（bit）等于存储位数，则shift将为0。在设备数据手册中也可以找到该参数。
    - repeat：指出位/存储重复数量。当重复元素为0或1时，重复值被省略。解释本节最好的方法是通过内核文档的摘录。例如，有关三轴加速度计驱动程序（12位分辨率，其中数据存储在两个8位寄存器中）的文档说明如下：

        7   6   5   4   3   2   1   0
      +---+---+---+---+---+---+---+---+
      |D3 |D2 |D1 |D0 | X | X | X | X | (LOW byte, address 0x06)
      +---+---+---+---+---+---+---+---+

        7   6   5   4   3   2   1   0
      +---+---+---+---+---+---+---+---+
      |D11|D10|D9 |D8 |D7 |D6 |D5 |D4 | (HIGH byte, address 0x07)
      +---+---+---+---+---+---+---+---+
      
每个轴将具有以下扫描元素类型：
```bash
    $ cat /sys/bus/iio/devices/iio:device0/scan_elements/in_accel_y_type
    le:s12/16>>4
```
这将解释为小端有符号数据，16位长度，在屏蔽12位有效数之前需要将它右移4位。struct iio_chan spec中负责确定通道值应该如何存储到缓冲区中的元素是scant_type。
```c
struct iio_chan_spec {
/* other members */
        int scan_index
        struct {
                char sign;
                u8 realbits;
                u8 storagebits;
                u8 shift;
                u8 repeat;
                enum iio_endian endianness;
               } scan_type;
       };
```
这个结构绝对匹配[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]它是前面描述过的模式。该结构中的每个成员如下
```c
struct iio_chan_spec accel_channels[] = {
    {
                .type = IIO_ACCEL,
	   .modified = 1,
	   .channel2 = IIO_MOD_X,
	   /* other stuff here */
	   .scan_index = 0,
	   .scan_type = {
	           .sign = 's',
		   .realbits = 12,
		   .storagebits = 16,
		   .shift = 4,
		   .endianness = IIO_LE,
	   },
    }
    /* similar for Y (with channel2 = IIO_MOD_Y, scan_index = 1)
     * and Z (with channel2 = IIO_MOD_Z, scan_index = 2) axis
     */
 }
```

- sign：表示数据的符号，匹配模式中的[s|u]。 
- realbits：对应于模式中的bits.
- storagebits：匹配模式中的同名元素。
- shift：对应于模式中的移位，repeat也相同。
- iio_indian：表示模式中的字节顺序，匹配模式中的[be|le]。此时，可以编写与前面解释过的类型相对应的IIO通道结构

# IIO数据访问
大家可能已经猜测到，只有两种方法可以通过IIO框架访问数据：通过sysfs通道单次捕获，或通过IIO字符设备的连续模式（触发缓冲区）。

## 单次捕获
单次数据捕获通过svsfs接口完成。通过读取对应于通道的sysfs条目，将只捕获与该频道相关的数据。对于具有两个通道的温度传感器：一个用于测量环境温度，另一个用于测量热电偶温度：
```bash
# cd /sys/bus/iio/devices/iio:device0
# cat in voltage3 raw
6646

# cat in voltage scale
0.305175781
```
将刻度乘以原始值即获得处理后的值。
电压值：6646 x 0.30517578120 = 28.19824053
设备数据手册中说明处理值以MV为单位。在本例中，它对应于2.02819V。

## 缓冲区数据访问
要使触发采集正常工作，必须在驱动程序中实现触发器支持。然后，要从用户空间获取数据，则必须：创建触发器并进行分配，启用ADC通道，设置缓冲区的大小并启用它。

###  使用sysfs触发器捕获
使用sysfs触发器捕获数据包括发送一组命令，但涉及少数几个sysfs文件。具体实现步骤如下。

- 1、创建触发器。在将触发器分配给任何设备之前，应该创建它
```bash
echo 0 > /sys/devices/iio_sysfs_trigger/add_trigge
 ```
这里，0对应于需要分配给触发器的索引。此命今执行后，该触发器目录在/sys/bus/iio/devices/下作为trigger0'提供

- 2、将触发器分配给设备。触发器由其名称唯一标识，使用名称可以将设备与触发哭绑定。由于这里使用0作为索引，因此触发器将命名为sysfstrigO：
```bash
# echo sysfstrig0 > /sys/bus/iio/devices/iio:device0/trigger/current_trigger
```
也可以使用这个命令：
```bash
cat /sys/bus/iio/devices/trigger0/name > /sys/bus/iio/devices/iio:device0/trigger/current_trigger
```
如果写入的值与现有的触发器名称不符，则不会发生任何事情。为了确保定义了触发器，可以使用该命令查看：
```bash
cat /sys/bus/iio/devices/iio:device0/trigger/current_trigger
```

- 3、启用一些扫描元素。此步骤包括选择哪些通道的数据值推入缓冲区。应该注意驱动程序中的available_scan_masks：
```bash
# echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage4_en
# echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage5_en
# echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage6_en
# echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage7_en
```

- 4、设置缓冲区大小。这里应该设置缓冲区可以保存的样本集的数量： 
```bash
# echo 100 > /sys/bus/iio/devices/iio:device0/buffer/length
```

- 5、启用缓冲区。此步骤将缓冲区标记为准备好接收推送的数据： 
```bash
# echo 1 > /sys/bus/iio/devices/iio:device0/buffer/enable 
```
要停止捕获，必须在同一个文件中写入0。

- 6、触发触发器。启动获取：
```bash
# echo 1 > /sys/bus/iio/devices/trigger0/trigger_now
```

- 7、禁用缓冲区：
```bash
#echo 0 > /sys/bus/iio/devices/iio:device0/bufferl/enable
```

- 8、分离触发器：
```bash
#echo 1 > /sys/bus/iio/devices/iio:device0/trigger/current_trigger
```

- 9、转存IIO字符设备的内容：
```bash
# cat /dev/iio\:device0 | xxd-
```

### 使用hrtimer触发器捕获
下面这组命令允许使用hrtimer触发器捕获数据：
```bash
# echo /sys/kernel/config/iio/triggers/hrtimer/trigger0
# echo 50 > /sys/bus/iio/devices/trigger0/sampling_frequency
# echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage4_en 
# echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage5_en 
# echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage6_en 
# echo 1 > /sys/bus/iio/devices/iio:device0/scan elements/in_voltage7_en 
# echo 1 > /sys/bus/iio/devices/iio:device0/buffer/enable
#cat /dev/iio:device0 | xxd-
0000000:01881a30 0000 0000 8312 68a8 c24f 5a14 ...0......h..0.
0000010:01881a30 0000 0000 192d 98a9 c24f 5a14  ..0.
[...]
```
下面来查看类型，以了解如何处理数据：
```bash
$ cat /sys/bus/iio/devices/iio:device0/scan_elements/involtage_type
be:s14/16>>2
```
电压处理：0x188 >> 2 = 98 * 250 = 24500 = 24.5v

# 工具
可以使用一些工具来简化和加速1I0设备应用程序的开发。这些可以使用的工具位于内核树内tools/iio下。

- lsiio.c：列举II0触发器、设备和通道。
- iio_event_monitor.c：为IIO事件监视IIO设备的ioctl接口。
- generic_buffer.c：检索、处理和打印从IIO设备缓冲区接收的数据。
- libiio：由模拟设备开发的功能强大的IIO设备接口

# 参考文献   
[https://blog.csdn.net/lickylin/article/details/108177756?spm=1001.2014.3001.5501](https://blog.csdn.net/lickylin/article/details/108177756?spm=1001.2014.3001.5501)   
《Linux设备驱动开发》  
《Linux内核文档》  
