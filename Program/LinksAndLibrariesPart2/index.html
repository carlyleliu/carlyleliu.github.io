<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>链接装载与库（二）目标文件 | Matrix</title><meta name="author" content="CarlyleLiu"><meta name="copyright" content="CarlyleLiu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="原图">
<meta property="og:type" content="article">
<meta property="og:title" content="链接装载与库（二）目标文件">
<meta property="og:url" content="https://carlyleliu.github.io/Program/LinksAndLibrariesPart2/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="原图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unsplash.it/1600/900?random&7011">
<meta property="article:published_time" content="2021-12-20T07:48:08.000Z">
<meta property="article:modified_time" content="2025-09-27T04:36:15.379Z">
<meta property="article:author" content="CarlyleLiu">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Links Libraries">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unsplash.it/1600/900?random&7011"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://carlyleliu.github.io/Program/LinksAndLibrariesPart2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '链接装载与库（二）目标文件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-27 12:36:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Matrix" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://unsplash.it/1600/900?random&amp;7011')"><nav id="nav"><span id="blog-info"><a href="/" title="Matrix"><span class="site-name">Matrix</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">链接装载与库（二）目标文件</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-20T07:48:08.000Z" title="发表于 2021-12-20 15:48:08">2021-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-27T04:36:15.379Z" title="更新于 2025-09-27 12:36:15">2025-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/">Technology Blog</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/Programming/">Programming</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/Programming/Principle/">Principle</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="链接装载与库（二）目标文件"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/ObjectFile.png" alt=""><br><a target="_blank" rel="noopener" href="https://www.processon.com/embed/623075e87d9c08076d09c802">原图</a></p>
<span id="more"></span>
<p>目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p>
<h1 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h1><p>现在 PC 平台流行的可执行文件格式主要是 Windows 下的 PE（Portable Executable）和 Linux 的 ELF（Executable Linkable Format），它们都是 COFF（Common fileformat）格式的变种。</p>
<p>ELF 文件标准里面把系统中采用 ELF 格式的文件归为如下表所列举的 4 类。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ELF 文件类型</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>可重定位文件 <bar> Relocatable File</bar></td>
<td>这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类</td>
<td>Linux 的。o <bar> Windows 的。obj</bar></td>
</tr>
<tr>
<td>可执行文件 <bar> Executable File</bar></td>
<td>这类文件包含了可以直接执行的程序，它的代表就是 ELF 可执行文件，它们一般都没有扩展名</td>
<td>比如/bin/bash 文件 <bar> Windows 的。exe</bar></td>
</tr>
<tr>
<td>共享目标文件 <bar> Shared Object File</bar></td>
<td>这种文件包含了代码和数据，可以在以下两种情况下使用。一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行</td>
<td>Linux 的。so，lib/glibc-2.5.so <bar> Windows 的 DLL</bar></td>
</tr>
<tr>
<td>核心转储文件 <bar> Core Dump File</bar></td>
<td>当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件</td>
<td>Linux 下的 core dump</td>
</tr>
</tbody>
</table>
</div>
<p>我们可以在 Linux 下使用 file 命令来查看相应的文件格式：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file foobar.o</span><br><span class="line">foobar.o:ELF 32-bit LSB relocatable,Intel 80386,version 1 (SYSV),notstripped</span><br><span class="line">file /bin/bash</span><br><span class="line">/bin/bash:ELF 32-bit LSB executable,Intel 80386,version 1 (SYSV),forGNU/Linux 2.6.8,dynamically linked (uses shared libs),stripped</span><br><span class="line"><span class="variable">$fi1e</span>/1ib/1d-2.6.1.8o</span><br><span class="line">/lib/libc-2.6.1.so:ELF 32-bit LSB shared object,Intel 80386,version 1(SYSV),<span class="keyword">for</span> GNU/Linux 2.6.8,stripped</span><br></pre></td></tr></tbody></table></figure>
<h1 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h1><p>目标文件中的内容至少有编译后的机器指令代码、数据。除了这些内容以外，目标文件中还包括了链接时所须要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以“段”（Segment）的形式存储。</p>
<p>让我们来看一个简单的程序被编译成目标文件后的结构，如图所示。<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/elf1.png" alt=""></p>
<p>假设图 3-1 的可执行文件（目标文件）的格式是 ELF，从图中可以看到，ELF 文件的开头是一个“文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息，文件头还包括一个段表（Section Table），段表其实是一个描述文件中各个段的数组。段表描述了文件中各个段在文件中的偏移位置及段的属性等。</p>
<blockquote>
<p>一般 C 语言的编译后执行语句都编译成机器代码，保存在。text 段；已初始化的全局变量和局部静态变量都保存在。data 段；未初始化的全局变量和局部静态变量一般放在一个叫“.bss”的段里。.bss 段只是为未初始化的全局变量和局部静态变量预留位置而已，它并没有内容，所以它在文件中也不占据空间。</p>
</blockquote>
<p>数据和指令分段的好处有很多，主要有如下几个方面：</p>
<ul>
<li>一方面是当程序被装载后，数据和指令分别被映射到两个虚存区域。这两个虚存区域的权限可以被分别设置成可读写和只读，这样可以防止程序的指令被有意或无意地改写。</li>
<li>另外一方面是对于现代的 CPU 来说，它们有着极为强大的缓存（Cache）体系。指令区和数据区的分离有利于提高程序的局部性，所以程序的指令和数据被分开存放对 CPU 的缓存命中率提高有好处。</li>
<li>第三个原因，其实也是最重要的原因，就是当系统中运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只须要保存一份该程序的指令部分。</li>
</ul>
<h1 id="挖掘-SimpleSection-o"><a href="#挖掘-SimpleSection-o" class="headerlink" title="挖掘 SimpleSection.o"></a>挖掘 SimpleSection.o</h1><p>我们就以 SimpleSection.c 编译出来的目标文件作为分析对象，这个程序是经过精心挑选的，具有一定的代表性而又不至于过于繁琐和复杂。图 3-1 中的程序代码如下所示：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">simpleSection.c</span></span><br><span class="line"><span class="comment">Linux:</span></span><br><span class="line"><span class="comment">gcc -c Simplesection.c</span></span><br><span class="line"><span class="comment">Windows:</span></span><br><span class="line"><span class="comment">cl Simplesection.c /c /Za</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*format,...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line">    <span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    func1(static_var + static_var2 + a + b );</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们使用 GCC 来编译这个文件（参数-c 表示只编译不链接）：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c Simplesection.c</span><br></pre></td></tr></tbody></table></figure>
<p>我们得到了一个 2.1k 字节的 SimpleSection.o 目标文件。我们可以使用 binutils 的工具 objdump 来查看 object 内部的结构，它可以用来查看各种目标文件的结构和内容。运行以下命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ objdump -h Simplesection.o</span><br><span class="line"></span><br><span class="line">Simplesection.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000005f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  0000000000000000  0000000000000000  000000a0  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000004  0000000000000000  0000000000000000  000000a8  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000004  0000000000000000  0000000000000000  000000a8  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000002b  0000000000000000  0000000000000000  000000ac  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d7  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></tbody></table></figure>
<p>Linux 还有一个很不错的工其叫 readelf，它是专门针对 ELF 文件格式的解析器，很多时候它对 ELF 文件的分析可以跟 objdump 相互对照，所以我们下面会经常用到这个工具。参数“-h”就是把 ELF 文件的各个段的基本信息打印出来。我们也可以使用“objdump -x”把更多的信息打印出来，但是“-x”输出的这些信息又多又复杂，对于不熟悉 ELF 和 objdump 的读者来说可能会很陌生。</p>
<p>从上面的结果来看，SimpleSection.o 的段的数量比我们想象中的要多，除了最基本的代码段、数据段和 BSS 段以外，还有 3 个段分别是只读数据段（.rodata）、注释信息段（.comment）和堆栈提示段（.note.GNU-stack），每个段的第 2 行中的“CONTENTS”、“ALLOC”等表示段的各种属性，“CONTENTS”表示该段在文件中存在。我们可以看到 BSS 段没有“CONTENTS”，表示它实际上在 ELF 文件中不存在内容。“.note.GNU-stack”段虽然有“CONTENTS”，但它的长度为 0，这是个很古怪的段，我们暂且忽略它，认为它在 ELF 文件中也不存在。那么 ELF 文件中实际存在的也就是“.text”、“.data”、“.rodata”和“.comment’”这 4 个段了。它们在 ELF 中的结构如图 3-3 所示：<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/elf2.png" alt=""></p>
<p>了解了这几个段在 SimpleSection.o 的基本分布，接着将逐个来看这几个段，看看它们包含了什么内容。有一个专门的命令叫做“size”，它可以用来查看 ELF 文件的代码段、数据段和 BSS 段的长度：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ size Simplesection.o</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">    219	      8	      4	    231	     e7	Simplesection.o</span><br></pre></td></tr></tbody></table></figure>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>objdump 的“-s”参数可以将所有段的内容以十六进制的方式打印出来，“-d”参数可以将所有包含指令的段反汇编。我们将 objdump 输出中关于代码段的内容提取出来，分析一下关于代码段的内容：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ objdump -x -s -d Simplesection.o</span><br><span class="line"></span><br><span class="line">Simplesection.o:     file format elf64-x86-64</span><br><span class="line">Simplesection.o</span><br><span class="line">architecture: i386:x86-64, flags 0x00000011:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address 0x0000000000000000</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000005f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  0000000000000000  0000000000000000  000000a0  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000004  0000000000000000  0000000000000000  000000a8  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000004  0000000000000000  0000000000000000  000000a8  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000002b  0000000000000000  0000000000000000  000000ac  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000d7  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000d8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .eh_frame     00000058  0000000000000000  0000000000000000  000000f8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    <span class="built_in">df</span> *ABS*	0000000000000000 Simplesection.c</span><br><span class="line">0000000000000000 l    d  .text	0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data	0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss	0000000000000000 .bss</span><br><span class="line">0000000000000000 l    d  .rodata	0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data	0000000000000004 static_var.2324</span><br><span class="line">0000000000000000 l     O .bss	0000000000000004 static_var2.2325</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .note.gnu.property	0000000000000000 .note.gnu.property</span><br><span class="line">0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment	0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data	0000000000000004 global_init_var</span><br><span class="line">0000000000000004       O *COM*	0000000000000004 global_uninit_var</span><br><span class="line">0000000000000000 g     F .text	0000000000000028 func1</span><br><span class="line">0000000000000000         *UND*	0000000000000000 _GLOBAL_OFFSET_TABLE_</span><br><span class="line">0000000000000000         *UND*	0000000000000000 <span class="built_in">printf</span></span><br><span class="line">0000000000000028 g     F .text	0000000000000037 main</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 f30f1efa 554889e5 4883ec10 897dfc8b  ....UH..H....}..</span><br><span class="line"> 0010 45fc89c6 488d3d00 000000b8 00000000  E...H.=.........</span><br><span class="line"> 0020 e8000000 0090c9c3 f30f1efa 554889e5  ............UH..</span><br><span class="line"> 0030 4883ec10 c745f801 0000008b 15000000  H....E..........</span><br><span class="line"> 0040 008b0500 00000001 c28b45f8 01c28b45  ..........E....E</span><br><span class="line"> 0050 fc01d089 c7e80000 00008b45 f8c9c3    ...........E...</span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 54000000 55000000                    T...U...</span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 25640a00                             %d..</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> 0000 00474343 3a202855 62756e74 7520392e  .GCC: (Ubuntu 9.</span><br><span class="line"> 0010 332e302d 31377562 756e7475 317e3230  3.0-17ubuntu1~20</span><br><span class="line"> 0020 2e303429 20392e33 2e3000             .04) 9.3.0.</span><br><span class="line">Contents of section .note.gnu.property:</span><br><span class="line"> 0000 04000000 10000000 05000000 474e5500  ............GNU.</span><br><span class="line"> 0010 020000c0 04000000 03000000 00000000  ................</span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span><br><span class="line"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span><br><span class="line"> 0020 00000000 28000000 00450e10 8602430d  ....(....E....C.</span><br><span class="line"> 0030 065f0c07 08000000 1c000000 3c000000  ._..........&lt;...</span><br><span class="line"> 0040 00000000 37000000 00450e10 8602430d  ....7....E....C.</span><br><span class="line"> 0050 066e0c07 08000000                    .n......</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func1&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64</span><br><span class="line">   4:	55                   	push   %rbp</span><br><span class="line">   5:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   8:	48 83 ec 10          	sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">   c:	89 7d <span class="built_in">fc</span>             	mov    %edi,-0x4(%rbp)</span><br><span class="line">   f:	8b 45 <span class="built_in">fc</span>             	mov    -0x4(%rbp),%eax</span><br><span class="line">  12:	89 c6                	mov    %eax,%esi</span><br><span class="line">  14:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        <span class="comment">#  1b &lt;func1+0x1b&gt;</span></span><br><span class="line">			17: R_X86_64_PC32	.rodata-0x4</span><br><span class="line">  1b:	b8 00 00 00 00       	mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  20:	e8 00 00 00 00       	callq  25 &lt;func1+0x25&gt;</span><br><span class="line">			21: R_X86_64_PLT32	printf-0x4</span><br><span class="line">  25:	90                   	nop</span><br><span class="line">  26:	c9                   	leaveq</span><br><span class="line">  27:	c3                   	retq</span><br><span class="line"></span><br><span class="line">0000000000000028 &lt;main&gt;:</span><br><span class="line">  28:	f3 0f 1e fa          	endbr64</span><br><span class="line">  2c:	55                   	push   %rbp</span><br><span class="line">  2d:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  30:	48 83 ec 10          	sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">  34:	c7 45 f8 01 00 00 00 	movl   <span class="variable">$0x1</span>,-0x8(%rbp)</span><br><span class="line">  3b:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        <span class="comment">#  41 &lt;main+0x19&gt;</span></span><br><span class="line">			3d: R_X86_64_PC32	.data</span><br><span class="line">  41:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        <span class="comment">#  47 &lt;main+0x1f&gt;</span></span><br><span class="line">			43: R_X86_64_PC32	.bss-0x4</span><br><span class="line">  47:	01 c2                	add    %eax,%edx</span><br><span class="line">  49:	8b 45 f8             	mov    -0x8(%rbp),%eax</span><br><span class="line">  4c:	01 c2                	add    %eax,%edx</span><br><span class="line">  4e:	8b 45 <span class="built_in">fc</span>             	mov    -0x4(%rbp),%eax</span><br><span class="line">  51:	01 d0                	add    %edx,%eax</span><br><span class="line">  53:	89 c7                	mov    %eax,%edi</span><br><span class="line">  55:	e8 00 00 00 00       	callq  5a &lt;main+0x32&gt;</span><br><span class="line">			56: R_X86_64_PLT32	func1-0x4</span><br><span class="line">  5a:	8b 45 f8             	mov    -0x8(%rbp),%eax</span><br><span class="line">  5d:	c9                   	leaveq</span><br><span class="line">  5e:	c3                   	retq</span><br></pre></td></tr></tbody></table></figure>
<p>“Contents of section.text”就是。text 的数据以十六进制方式打印出来的内容，最左面一列是偏移量，中间 4 列是十六进制内容，最右面一列是。text 段的 ASCII 码形式。对照下面的反汇编结果，可以很明显地看到，.text 段里所包含的正是 SimpleSection.c 里两个函数 func1() 和 main() 的指令。.text 段的第一个字节“55”就是“func1()”函数的第一条“push   %rbp”指令，而最后一个字节 0xc3 正是 main 函数的最后一条指令“retq”。</p>
<h2 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h2><p>.data 段保存的是那些已经初始化了的全局静态变量和局部静态变量。前面的 SimpleSection.c 代码里面一共有两个这样的变量，分别是 global_init_varabal 与 static_var。这两个变量每个 4 字节，一共刚好 8 个字节，所以“.data”这个段的大小为 8 个字节。<br>SimpleSection.c 里面我们在调用“printf”的时候，用到了一个字符串常量“%d\n”，它是一种只读数据，所以它被放到了“.rodata”段，我们可以从输出结果看到“.rodata”这个段的 4 个字节刚好是这个字符串常量的 ASCII 字节序，最后以、0 结尾。<br>单独设立“.rodata”段有很多好处，不光是在语义上支持了 C++的 const 关键字，而且操作系统在加载的时候可以将“.rodata”段的属性映射成只读，这样对于这个段的任何修改操作都会作为非法操作处理，保证了程序的安全性。<br>另外值得一提的是，有时候编译器会把字符串常量放到“.data”段，而不会单独放在“.rodata”段。</p>
<h2 id="BSS-段"><a href="#BSS-段" class="headerlink" title="BSS 段"></a>BSS 段</h2><p>.bss 段存放的是未初始化的全局变量和局部静态变量，如上述代码中 global_uninit_var 和 static_var2 就是被存放在。bss 段，其实更准确的说法是。bss 段为它们预留了空间。但是我们可以看到该段的大小只有 4 个字节，这与 global_uninit_var 和 static_var2 的大小的 8 个字节不符。<br>其实我们可以通过符号表（Symbol Table）看到，只有 static_var2 被存放在了。bss 段，而 global_uninit_var 却没有被存放在任何段，只是一个未定义的“COMMON 符号”。这其实是跟不同的语言与不同的编译器实现有关，有些编译器会将全局的未初始化变量存放在目标文件。bss 段，有些则不存放，只是预留一个未定义的全局变量符号，等到最终链接成可执行文件的时候再在。bss 段分配空间。</p>
<h2 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h2><p>除了。text、.data、.bss 这 3 个最常用的段之外，ELF 文件也有可能包含其他的段，用来保存与程序相关的其他信息。下表中列举了 ELF 的一些常见的段：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常用的段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.rodatal</td>
<td>Read only Data，这种段里存放的是只读数据，比如字符串常量、全局 const 变量。跟“.rodata”一样</td>
</tr>
<tr>
<td>.comment</td>
<td>存放的是编译器版本信息，比如字符串：”GCC：（GNU）4.2.0</td>
</tr>
<tr>
<td>.debug</td>
<td>调试信息</td>
</tr>
<tr>
<td>.dynamic</td>
<td>动态链接信息</td>
</tr>
<tr>
<td>.hash</td>
<td>符号哈希表</td>
</tr>
<tr>
<td>.line</td>
<td>调试时的行号表，即源代码行号与编译后指令的对应表</td>
</tr>
<tr>
<td>.note</td>
<td>额外的编译器信息。比如程序的公司名、发布版本号等</td>
</tr>
<tr>
<td>.strtab</td>
<td>String Table. 字符串表，用于存储 ELF 文件中用到的各种字符串</td>
</tr>
<tr>
<td>.symtab</td>
<td>Symbol Table. 符号表</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>Section String Table. 段名表</td>
</tr>
<tr>
<td>.plt <bar> .got</bar></td>
<td>动态链接的跳转表和全局入口表</td>
</tr>
<tr>
<td>.init <bar> .fini</bar></td>
<td>程序初始化与终结代码段</td>
</tr>
</tbody>
</table>
</div>
<p>这些段的名字都是由“.”作为前缀，表示这些表的名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名。比如我们可以在 ELF 文件中插入一个“music”的段，里面存放了一首 MP3 音乐，当 ELF 文件运行起来以后可以读取这个段播放这首 MP3。但是应用程序自定义的段名不能使用“.”作为前缀，否则容易跟系统保留段名冲突。</p>
<p>Q：如果我们要将一个二进制文件，比如图片、MP3 音乐、词典一类的东西作为目标文件中的一个段，该怎么做？<br>A：可以使用 objcopy 工具，比如我们有一个图片文件“image.jpg”，大小为 0x82100 字节：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objcopy -I binary -o elf32-1386 -B i386 image.jpg image.o</span><br><span class="line">objdump -ht image.o</span><br></pre></td></tr></tbody></table></figure>
<h1 id="ELF-文件结构描述"><a href="#ELF-文件结构描述" class="headerlink" title="ELF 文件结构描述"></a>ELF 文件结构描述</h1><p>下图描述的是 ELF 目标文件的总体结构，我们省去了 ELF-些繁琐的结构，把最重要的结构提取出来：<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/elf3.png" alt=""></p>
<h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><p>我们可以用 readelf 命令来详细查看 ELF 文件，</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ readelf -h Simplesection.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">'s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          1184 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         14</span></span><br><span class="line"><span class="string">  Section header string table index: 13</span></span><br></pre></td></tr></tbody></table></figure>
<p>从上面输出的结果可以看到，ELF 的文件头中定义了 ELF 魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI 版本、ELF 重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。这些数值中有关描述 ELF 目标平台的部分，与我们常见的 32 位 Intel 的硬件平台基本上一样。</p>
<h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><p>前文中我们使用了“objudump -h”来查看 ELF 文件中包含的段，结果是 SimpleSection 里面看到了总共有 6 个段，分别是“.code”、“.data”、“.bss”、“.rodata”、“.comment’”和“.note.GNU-stack”。实际上的情况却有所不同，“objdump -h”命令只是把 ELF 文件中关键的段显示了出来，而省略了其他的辅助性的段，比如：符号表、字符串表、段名字符串表、重定位表等。我们可以使用 readelf 工具来查看 ELF 文件的段，它显示出来的结果才是真正的段表结构：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ readelf -S Simplesection.o</span><br><span class="line">There are 14 section headers, starting at offset 0x4a0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000005f  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000380</span><br><span class="line">       0000000000000078  0000000000000018   I      11     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000a0</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000a8</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000004  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000ac</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000d7</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .note.gnu.propert NOTE             0000000000000000  000000d8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .eh_frame         PROGBITS         0000000000000000  000000f8</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [10] .rela.eh_frame    RELA             0000000000000000  000003f8</span><br><span class="line">       0000000000000030  0000000000000018   I      11     9     8</span><br><span class="line">  [11] .symtab           SYMTAB           0000000000000000  00000150</span><br><span class="line">       00000000000001b0  0000000000000018          12    12     8</span><br><span class="line">  [12] .strtab           STRTAB           0000000000000000  00000300</span><br><span class="line">       000000000000007c  0000000000000000           0     0     1</span><br><span class="line">  [13] .shstrtab         STRTAB           0000000000000000  00000428</span><br><span class="line">       0000000000000074  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></tbody></table></figure>
<p>对于 SimpleSection.o 来说，段表就是有 11 个元素的数组。ELF 段表的这个数组的第一个元素是无效的段描述符，它的类型为“NULL”，除此之外每个段描述符都对应一个段。也就是说 SimpleSection.o 共有 13 个有效的段。</p>
<h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>我们注意到，SimpleSection.o 中有一个叫做“.rela.text”的段，它的类型（sh_type）为“RELA”，也就是说它是一个重定位表（Relocation Table）。正如我们最开始所说的，链接器在处理目标文件时，须要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。</p>
<p>比如 SimpleSection.o 中的“.rela.text”就是针对“.text”段的重定位表，因为“.text”段中至少有一个绝对地址的引用，那就是对“printf”函数的调用；而“.data”段则没有对绝对地址的引用，它只包含了几个常量，所以 SimpleSection.o 中没有针对“.data”段的重定位表“.rela.data”。</p>
<h2 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h2><p>ELF 文件中用到了很多字符串，比如段名、变量名等，比如下表这个字符串表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>偏移</th>
<th>+0</th>
<th>+1</th>
<th>+2</th>
<th>+3</th>
<th>+4</th>
<th>+5</th>
<th>+6</th>
<th>+7</th>
<th>+8</th>
<th>+9</th>
</tr>
</thead>
<tbody>
<tr>
<td>+0</td>
<td>\0</td>
<td>h</td>
<td>e</td>
<td>l</td>
<td>l</td>
<td>o</td>
<td>w</td>
<td>o</td>
<td>r</td>
<td>l</td>
</tr>
<tr>
<td>+10</td>
<td>d</td>
<td>\0</td>
<td>M</td>
<td>y</td>
<td>v</td>
<td>a</td>
<td>r</td>
<td>i</td>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td>+20</td>
<td>l</td>
<td>e</td>
<td>\0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>常见的段名为“.strtab”或“.shstrtab”。这两个字符串表分别为字符串表（String Table）和段表字符串表（Section Header String Table）。</p>
<h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><p>在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p>
<p>链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。除了函数和变量之外，还存在其他几种不常用到的符号，我们将符号表中所有的符号进行分类，它们有可能是下面这些类型中的一种：</p>
<ul>
<li>定义在本目标文件的全局符号，可以被其他目标文件引用。比如 SimpleSection.o 里面的“func1”、“main”和“global_init_var”。</li>
<li>在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做外部符号（External Symbol），也就是我们前面所讲的符号引用。比如 SimpleSection.o 里面的“printf”。</li>
<li>段名，这种符号往往由编译器产生，它的值就是该段的起始地址。比如 SimpleSection.o 里面的“.text”、“.data”等。</li>
<li>局部符号，这类符号只在编译单元内部可见。比如 SimpleSection.o 里面的“static_var”和“static_var2”。调试器可以使用这些符号来分析程序或崩溃时的核心转储文件。这些局部符号对于链接过程没有作用，链接器往往也忽略它们。</li>
<li>行号信息，即目标文件指令与源代码中代码行的对应关系，它也是可选的。</li>
</ul>
<p>对于我们来说，最值得关注的就是全局符号，即上面分类中的第一类和第二类。因为链接过程只关心全局符号的相互“粘合”，局部符号、段名、行号等都是次要的，它们对于其他目标文件来说是“不可见”的，在链接过程中也是无关紧要的。我们可以使用很多工具来查看 ELF 文件的符号表，比如 readelf、objdump、nm 等，比如使用“nm”来查看“SimpleSection.o”的符号结果如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ nm Simplesection.o</span><br><span class="line">                 U _GLOBAL_OFFSET_TABLE_</span><br><span class="line">0000000000000000 T func1</span><br><span class="line">0000000000000000 D global_init_var</span><br><span class="line">0000000000000004 C global_uninit_var</span><br><span class="line">0000000000000028 T main</span><br><span class="line">                 U <span class="built_in">printf</span></span><br><span class="line">0000000000000004 d static_var.2324</span><br><span class="line">0000000000000000 b static_var2.2325</span><br></pre></td></tr></tbody></table></figure>
<h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p>当我们使用 ld 作为链接器来链接生产可执行文件时，它会为我们定义很多特殊的符号，这些符号并没有在你的程序中定义，但是你可以直接声明并且引用它，我们称之为特殊符号。其实这些符号是被定义在 ld 链接器的链接脚本中的，链接器会在将程序最终链接成可执行文件的时候将其解析成正确的值，注意，只有使用 ld 链接生产最终可执行文件的时候这些符号才会存在。</p>
<ul>
<li>_executable_start，该符号为程序起始地址，注意，不是入口地址，是程序的最开始的地址。</li>
<li>etext 或_etext 或 etext，该符号为代码段结束地址，即代码段最末尾的地址。</li>
<li>_edata 或 edata，该符号为数据段结束地址，即数据段最末尾的地址。</li>
<li>_end 或 end，该符号为程序结束地址。</li>
<li>以上地址都为程序被装载时的虚拟地址。</li>
</ul>
<p>我们可以在程序中直接使用这些符号。</p>
<h2 id="符号修饰与函数签名"><a href="#符号修饰与函数签名" class="headerlink" title="符号修饰与函数签名"></a>符号修饰与函数签名</h2><p><strong>C++符号修饰</strong><br>C++允许多个不同参数类型的函数拥有一样的名字，就是所谓的函数重载；另外 C++还在语言级别支持名称空间，即允许在不同的名称空间有多个同样名字的符号。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">func</span><span class="params">(<span class="type">float</span>)</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> {</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C2</span> {</span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    };</span><br><span class="line">};</span><br><span class="line">namespace N {</span><br><span class="line">    <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> {</span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们引入一个术语叫做函数签名（Function Signature），函数签名包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息，函数签名用于识别不同的函数。C++编译器和链接器都使用符号来识别和处理函数和变量，所以对于不同函数签名的函数，即使函数名相同，编译器和链接器都认为它们是不同的函数。上面的 6 个函数签名在 GCC 编译器下，相对应的修饰后名称如下表所示。<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Principle/elf6.png" alt=""></p>
<p>GCC 的基本 C++名称修饰方法如下：所有的符号都以“_Z”开头，对于嵌套的名字（在名称空间或在类里面的），后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以“E”结尾。比如 N::C::func 经过名称修饰以后就是_ZN1N1C4funcE。对于一个函数来说，它的参数列表紧跟在“E”后面，对于 int 类型来说，就是字母“i”。所以整个 N::C::func（int）函数签名经过修饰为_ZN1N1C4funcEi。binutils 里面提供了一个叫“c++filt”的工具可以用来解析被修饰过的名称，比如：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c++filt _ZN1N1C4funcEi</span><br><span class="line">N:C:func(int)</span><br></pre></td></tr></tbody></table></figure>
<p>签名和名称修饰机制不光被使用到函数上，C++中的全局变量和静态变量也有同样的机制。对于全局变量来说，它跟函数一样都是一个全局可见的名称，它也遵循上面的名称修饰机制。</p>
<p>由于不同的编译器采用不同的名字修饰方法，必然会导致由不同编译器编译产生的目标文件无法正常相互链接，这是导致不同编译器之间不能互操作的主要原因之一。</p>
<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span> <span class="params">(<span class="type">void</span> *<span class="type">int</span>, <span class="type">size_t</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在 C++语言中，编译器会认为这个 memset 函数是一个 C++函数，将 memset 的符号修饰成_ZmemsetPvii，这样链接器就无法与 C 语言库中的 memset 符号进行链接。所以对于 C++来说，必须使用 extern“C”来声明 memset 这个函数。但是 C 语言又不支持 extern“C”语法。幸好我们有一种很好的方法可以解决上述问题，就是使用 C++的宏“_cplusplus”，C++编译器会在编译 C++的程序时默认定义这个宏，具体代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>{</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span> <span class="params">(<span class="type">void</span> *<span class="type">int</span>,<span class="type">size_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>上面这段代码中的技巧几乎在所有的系统头文件里面都被用到。</p>
<h2 id="弱符号与强符号"><a href="#弱符号与强符号" class="headerlink" title="弱符号与强符号"></a>弱符号与强符号</h2><p>对于 C/C++语言来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。我们也可以通过 GCC 的“<strong>attribute</strong>（weak）”来定义任何一个强符号为弱符号。注意，强符号和弱符号都是针对定义来说的，不是针对符号的引用。比如我们有下面这段程序：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> weak;</span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>:</span><br><span class="line">__attribute__((weak) weak2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面这段程序中，“weak”和“weak2”是弱符号，“strong”和“main”是强符号，而“ext”既非强符号也非弱符号，因为它是一个外部变量的引用。针对强弱符号的概念，链接器就会按如下规则处理与选择被多次定义的全局符号：</p>
<ul>
<li>规则 1：不允许强符号被多次定义。</li>
<li>规则 2：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</li>
<li>规则 3：如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。</li>
</ul>
<p>弱引用和强引用：</p>
<ul>
<li>目前我们所看到的对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们须要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为强引用（Strong Reference）。</li>
<li>与之相对应还有一种弱引用（Weak Reference），在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对于该引用不报错。</li>
</ul>
<p>在 GCC 中，我们可以通过使用“<strong>attribute</strong>（weakref）”这个扩展关键字来声明对一个外部函数的引用为弱引用，比如下面这段代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((weakref))<span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    foo():</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以将它编译成一个可执行文件，GCC 并不会报链接错误。但是当我们运行这个可执行文件时，会发生运行错误。因为当 main 函数试图调用 foo 函数时，foo 函数的地址为 0，于是发生了非法地址访问的错误。一个改进的例子是：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((weakref) <span class="type">void</span> foo();</span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(foo)</span><br><span class="line">        foo();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这种弱符号和弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的库函数。</p>
<h1 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h1><p>如果我们在 GCC 编译时加上“-g”参数，编译器就会在产生的目标文件里面加上调试信息，我们通过 readelf 等工具可以看到，目标文件里多了很多“debug”相关的段：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">vooxle@liushuai:~$ gcc -c -g Simplesection.c</span><br><span class="line">vooxle@liushuai:~$ <span class="built_in">ls</span></span><br><span class="line">Document  Simplesection.c  Simplesection.o  nfs_rootfs  workspace</span><br><span class="line">vooxle@liushuai:~$ readelf -S Simplesection.o</span><br><span class="line">There are 22 section headers, starting at offset 0x1570:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000005f  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000d40</span><br><span class="line">       0000000000000078  0000000000000018   I      19     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000a0</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000a8</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000004  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .debug_info       PROGBITS         0000000000000000  000000ac</span><br><span class="line">       00000000000003a0  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .rela.debug_info  RELA             0000000000000000  00000db8</span><br><span class="line">       0000000000000678  0000000000000018   I      19     6     8</span><br><span class="line">  [ 8] .debug_abbrev     PROGBITS         0000000000000000  0000044c</span><br><span class="line">       0000000000000130  0000000000000000           0     0     1</span><br><span class="line">  [ 9] .debug_aranges    PROGBITS         0000000000000000  0000057c</span><br><span class="line">       0000000000000030  0000000000000000           0     0     1</span><br><span class="line">  [10] .rela.debug_arang RELA             0000000000000000  00001430</span><br><span class="line">       0000000000000030  0000000000000018   I      19     9     8</span><br><span class="line">  [11] .debug_line       PROGBITS         0000000000000000  000005ac</span><br><span class="line">       000000000000012e  0000000000000000           0     0     1</span><br><span class="line">  [12] .rela.debug_line  RELA             0000000000000000  00001460</span><br><span class="line">       0000000000000018  0000000000000018   I      19    11     8</span><br><span class="line">  [13] .debug_str        PROGBITS         0000000000000000  000006da</span><br><span class="line">       0000000000000314  0000000000000001  MS       0     0     1</span><br><span class="line">  [14] .comment          PROGBITS         0000000000000000  000009ee</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [15] .note.GNU-stack   PROGBITS         0000000000000000  00000a19</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [16] .note.gnu.propert NOTE             0000000000000000  00000a20</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [17] .eh_frame         PROGBITS         0000000000000000  00000a40</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [18] .rela.eh_frame    RELA             0000000000000000  00001478</span><br><span class="line">       0000000000000030  0000000000000018   I      19    17     8</span><br><span class="line">  [19] .symtab           SYMTAB           0000000000000000  00000a98</span><br><span class="line">       0000000000000228  0000000000000018          20    17     8</span><br><span class="line">  [20] .strtab           STRTAB           0000000000000000  00000cc0</span><br><span class="line">       000000000000007c  0000000000000000           0     0     1</span><br><span class="line">  [21] .shstrtab         STRTAB           0000000000000000  000014a8</span><br><span class="line">       00000000000000c3  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></tbody></table></figure>
<p>这些段中保存的就是调试信息。现在的 ELF 文件采用一个叫 DWARF（Debug With Arbitrary Record Format）的标准的调试信息格式，现在该标准已经发展到了第三个版本，即 DWARF3，由 DWARF 标准委员会由 2006 年颁布。在 Linux 下，我们可以使用“strip”命令来去掉 ELF 文件中的调试信息：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strip foo</span><br></pre></td></tr></tbody></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《程序员的自我修养》</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Programming/">Programming</a><a class="post-meta__tags" href="/tags/Links-Libraries/">Links Libraries</a></div><div class="post_share"><div class="social-share" data-image="https://unsplash.it/1600/900?random&amp;7011" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Program/LinksAndLibrariesPart3/" title="链接装载与库（三）静态链接"><img class="cover" src="https://unsplash.it/1600/900?random&amp;8673" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">链接装载与库（三）静态链接</div></div></a></div><div class="next-post pull-right"><a href="/Program/LinksAndLibrariesPart1/" title="链接装载与库（一）编译和链接"><img class="cover" src="https://unsplash.it/1600/900?random&amp;7861" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">链接装载与库（一）编译和链接</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Program/LinksAndLibrariesPart3/" title="链接装载与库（三）静态链接"><img class="cover" src="https://unsplash.it/1600/900?random&8673" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-21</div><div class="title">链接装载与库（三）静态链接</div></div></a></div><div><a href="/Program/LinksAndLibrariesPart4/" title="链接装载与库（四）可执行文件的装载与进程"><img class="cover" src="https://unsplash.it/1600/900?random&6566" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-23</div><div class="title">链接装载与库（四）可执行文件的装载与进程</div></div></a></div><div><a href="/Program/LinksAndLibrariesPart1/" title="链接装载与库（一）编译和链接"><img class="cover" src="https://unsplash.it/1600/900?random&7861" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-19</div><div class="title">链接装载与库（一）编译和链接</div></div></a></div><div><a href="/Program/LinksAndLibrariesPart5/" title="链接装载与库（五）动态链接"><img class="cover" src="https://unsplash.it/1600/900?random&6782" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-24</div><div class="title">链接装载与库（五）动态链接</div></div></a></div><div><a href="/Debug/ApplicationDebug/" title="应用崩溃调试分析"><img class="cover" src="https://unsplash.it/1600/900?random&6742" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-26</div><div class="title">应用崩溃调试分析</div></div></a></div><div><a href="/Debug/CCMemLeakAsync/" title="C&#x2F;C++内存泄露分析过程"><img class="cover" src="https://unsplash.it/1600/900?random&2911" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-21</div><div class="title">C&#x2F;C++内存泄露分析过程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CarlyleLiu</div><div class="author-info__description">CarlyleLiu’s Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/carlyleliu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/carlyleliu" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yyliushuai@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://twitter.com/yyliushuai" target="_blank" title="Twitter"><i class="fab fa-twitter" style="color: #24292e;"></i></a><a class="social-icon" href="https://youtube.com/carlyleliu" target="_blank" title="YouTube"><i class="fab fa-youtube" style="color: #24292e;"></i></a><a class="social-icon" href="https://instagram.com/blurredliu" target="_blank" title="Instagram"><i class="fab fa-instagram" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">next主题站 https://carlyleliu.github.io/next</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">目标文件的格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">目标文件是什么样的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%96%E6%8E%98-SimpleSection-o"><span class="toc-number">3.</span> <span class="toc-text">挖掘 SimpleSection.o</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">3.1.</span> <span class="toc-text">代码段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%92%8C%E5%8F%AA%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">3.2.</span> <span class="toc-text">数据段和只读数据段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BSS-%E6%AE%B5"><span class="toc-number">3.3.</span> <span class="toc-text">BSS 段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%AE%B5"><span class="toc-number">3.4.</span> <span class="toc-text">其他段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ELF-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.</span> <span class="toc-text">ELF 文件结构描述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="toc-number">4.1.</span> <span class="toc-text">文件头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">4.2.</span> <span class="toc-text">段表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-number">4.3.</span> <span class="toc-text">重定位表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">字符串表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7"><span class="toc-number">5.</span> <span class="toc-text">符号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7"><span class="toc-number">5.1.</span> <span class="toc-text">特殊符号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">5.2.</span> <span class="toc-text">符号修饰与函数签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-%E2%80%9CC%E2%80%9D"><span class="toc-number">5.3.</span> <span class="toc-text">extern “C”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E7%AC%A6%E5%8F%B7%E4%B8%8E%E5%BC%BA%E7%AC%A6%E5%8F%B7"><span class="toc-number">5.4.</span> <span class="toc-text">弱符号与强符号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="toc-number">6.</span> <span class="toc-text">调试信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">7.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By CarlyleLiu</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><!-- hexo injector body_end end --></body></html>