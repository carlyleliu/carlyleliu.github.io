<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5txRYykRNG5Z1NrO_ZCLF1GZWnbFmCOLdJHGBVFuCIg">
  <meta name="baidu-site-verification" content="code-XfgDErPTZS">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Reddit+Mono:300,300italic,400,400italic,700,700italic%7CNoto+Sans:300,300italic,400,400italic,700,700italic%7COpen+Sans:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"carlyleliu.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":true,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="原图">
<meta property="og:type" content="article">
<meta property="og:title" content="C++（一）对象模型">
<meta property="og:url" content="https://carlyleliu.github.io/Program/CPPobjectModel/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="原图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/CPPObjectModle.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo3.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo4.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo5.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo6.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo7.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo8.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo9.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo10.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo11.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo12.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo13.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo15.png">
<meta property="og:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo16.png">
<meta property="article:published_time" content="2021-12-25T22:21:18.000Z">
<meta property="article:modified_time" content="2025-09-27T04:36:15.379Z">
<meta property="article:author" content="CarlyleLiu">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/CPPObjectModle.png">


<link rel="canonical" href="https://carlyleliu.github.io/Program/CPPobjectModel/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://carlyleliu.github.io/Program/CPPobjectModel/","path":"Program/CPPobjectModel/","title":"C++（一）对象模型"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++（一）对象模型 | Matrix</title>
  







<link rel="dns-prefetch" href="https://waline.carlyleliu.vip">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end -->
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Matrix" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Matrix</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">CarlyleLiu‘s Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-alist"><span class="exturl" data-url="aHR0cHM6Ly9hbGlzdC5jYXJseWxlbGl1LnZpcC8="><i class="fa-solid fa-cloud fa-fw"></i>网盘</span></li><li class="menu-item menu-item-books"><span class="exturl" data-url="aHR0cHM6Ly9jYWxpYnJlLmNhcmx5bGVsaXUudmlwLw=="><i class="fa-solid fa-book fa-fw"></i>书库</span></li><li class="menu-item menu-item-talk"><span class="exturl" data-url="aHR0cHM6Ly9tZW1vcy5jYXJseWxlbGl1LnZpcC9leHBsb3JlLw=="><i class="fas fa-comments fa-fw"></i>随笔</span></li><li class="menu-item menu-item-album"><span class="exturl" data-url="aHR0cHM6Ly9pbW1pY2guY2FybHlsZWxpdS52aXAvc2hhcmUvSmtSenVqZERfdWVJRnJRNHpvYnpfUW1EVndRZkdGS3ZyVTh0ZlJIYWN1ZG9ZMjV0Z2tFdDd6aS1Wck5oYUEzZUdpNC8="><i class="fa-solid fa-image fa-fw"></i>相册</span></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text"> 对象模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8Bthe-c-object-model"><span class="nav-text"> C对象模型（The C Object Model）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E4%B8%8A%E7%BB%A7%E6%89%BFadding-inheritance"><span class="nav-text"> 加上继承（Adding Inheritance）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89%E5%AD%A6"><span class="nav-text"> 构造函数语义学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#default-constructor-%E7%9A%84%E5%BB%BA%E6%9E%84%E6%93%8D%E4%BD%9C"><span class="nav-text"> Default Constructor 的建构操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89-default-constructor-%E7%9A%84-member-class-object"><span class="nav-text"> 带有 Default Constructor 的 Member Class Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89-default-constructor-%E7%9A%84-base-class"><span class="nav-text"> 带有 Default Constructor 的 Base Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E4%B8%80%E4%B8%AA-virtual-function-%E7%9A%84-class"><span class="nav-text"> 带有一个 Virtual Function 的 Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E4%B8%80%E4%B8%AA-virtual-base-class-%E7%9A%84-class"><span class="nav-text"> 带有一个 Virtual Base Class 的 Class</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#copy-constructor-%E7%9A%84%E5%BB%BA%E6%9E%84%E6%93%8D%E4%BD%9C"><span class="nav-text"> Copy Constructor 的建构操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#default-memberwise-initialization"><span class="nav-text"> Default Memberwise Initialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitwise-copy-semantics%E4%BD%8D%E9%80%90%E6%AC%A1%E6%8B%B7%E8%B4%9D"><span class="nav-text"> Bitwise Copy Semantics（位逐次拷贝）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81-bitwise-copy-semantics"><span class="nav-text"> 不要 Bitwise Copy Semantics！</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#data-%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="nav-text"> Data 语意学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E5%8F%97%E4%B8%89%E4%B8%AA%E5%9B%A0%E7%B4%A0%E5%BD%B1%E5%93%8D"><span class="nav-text"> 类对象大小受三个因素影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nonstatic-data-members"><span class="nav-text"> Nonstatic data members</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-static-data-members"><span class="nav-text"> 静态成员变量 static data members</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%B7%E6%89%BF%E4%B8%8E-data-member"><span class="nav-text"> “迷承”与 Data Member</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E8%A6%81%E7%BB%A7%E6%89%BF%E4%B8%8D%E8%A6%81%E5%A4%9A%E6%80%81inheritance-without-polymorphism"><span class="nav-text"> 只要继承不要多态（Inheritance without Polymorphism）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BFmultiple-inheritance"><span class="nav-text"> 多重继承（Multiple Inheritance）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF-vitual-inheritance"><span class="nav-text"> 虚拟继承 (Vitual Inheritance)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#function-%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="nav-text"> Function 语意学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%87%86%E5%88%99%E4%B9%8B%E4%B8%80nostatic-member-function-%E8%87%B3%E5%B0%91%E5%BF%85%E9%A1%BB%E5%92%8C%E4%B8%80%E8%88%AC%E7%9A%84-nonmember-function-%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%88%E7%8E%87"><span class="nav-text"> C++的设计准则之一：nostatic member function 至少必须和一般的 nonmember function 有相同的效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96override-%E9%87%8D%E5%86%99overload-%E9%9A%90%E8%97%8Fhide%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text"> 覆盖（override）、重写（overload）、隐藏（hide）的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#virtual-member-functions%E8%99%9A%E6%8B%9F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text"> Virtual Member Functions（虚拟成员函数）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84-virtual-functions"><span class="nav-text"> 多重继承下的 Virtual Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84-virtual-functions"><span class="nav-text"> 虚拟继承下的 Virtual Functions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-static-member-functions"><span class="nav-text"> 静态成员函数 static member functions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vtable-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%80%E5%AE%9A%E6%98%AF%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E8%8E%B7%E7%9F%A5%E7%9A%84%E5%85%B6%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0-%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%9C%B0%E5%9D%80%E6%98%AF%E5%9B%BA%E5%AE%9A%E4%B8%8D%E5%8F%98%E7%9A%84%E5%AE%8C%E5%85%A8%E7%94%B1%E7%BC%96%E8%AF%91%E5%99%A8%E6%8E%8C%E6%8E%A7%E6%89%A7%E8%A1%8C%E6%9C%9F%E9%97%B4%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BB%BB%E4%BD%95%E4%BF%AE%E6%94%B9"><span class="nav-text"> vtable 虚函数表一定是在编译期间获知的，其函数的个数、位置和地址是固定不变的，完全由编译器掌控，执行期间不允许任何修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-text"> 执行期虚函数调用步骤</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6"><span class="nav-text"> 执行期语意学</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AB%99%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B0%96%E7%AB%AF"><span class="nav-text"> 站在对象模型的尖端</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text"> 参考文献</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CarlyleLiu</p>
  <div class="site-description" itemprop="description">CarlyleLiu’s Blog</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">187</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhcmx5bGVsaXU=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;carlyleliu"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnl5bGl1c2h1YWlAZ21haWwuY29t" title="E-Mail → mailto:yyliushuai@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95eWxpdXNodWFp" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;yyliushuai"><i class="fab fa-twitter fa-fw"></i>Twitter</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly95b3V0dWJlLmNvbS9jYXJseWxlbGl1" title="YouTube → https:&#x2F;&#x2F;youtube.com&#x2F;carlyleliu"><i class="fab fa-youtube fa-fw"></i>YouTube</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL2JsdXJyZWRsaXU=" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;blurredliu"><i class="fab fa-instagram fa-fw"></i>Instagram</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://carlyleliu.github.io/Program/CPPobjectModel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CarlyleLiu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matrix">
      <meta itemprop="description" content="CarlyleLiu’s Blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++（一）对象模型 | Matrix">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++（一）对象模型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Technology-Blog/" itemprop="url" rel="index"><span itemprop="name">Technology Blog</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Technology-Blog/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Technology-Blog/Programming/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/Program/CPPobjectModel/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/Program/CPPobjectModel/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>29 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/CPPObjectModle.png" alt=""><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS9lbWJlZC82MjMxODNiYzBlM2U3NDA3ZGE0ZWE3ZGU=">原图<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h1 id="对象模式"><a class="markdownIt-Anchor" href="#对象模式"></a> 对象模式</h1>
<p>在 C++中，有两种 class data members：static 和 nonstatic，以及三种 class member functions：static、nonstatic 和 virtual。已知下面这个 class Point 声明：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">float</span> xval);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="type">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp;</span></span><br><span class="line"><span class="function">      <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="type">float</span> _x;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _point_count;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>这个 class Point 在机器中将会被怎么样表现呢？也就是说，我们如何模塑（modeling）出各种 data members 和 function members 呢？</p>
<h2 id="c对象模型the-c-object-model"><a class="markdownIt-Anchor" href="#c对象模型the-c-object-model"></a> C<ins>对象模型（The C</ins> Object Model）</h2>
<p>Stroustrup 当初设计的 C++对象模型是从简单对象模型派生而来的，并对内存空间和存取时间做了优化。在此模型中：</p>
<ul>
<li>Nonstatic datamembers 被配置于每一个 class object 之内。</li>
<li>static data members 则被存放在所有的 class object 之外（data 段或 bss 段）。</li>
<li>Static 和 nonstatic function members 也被放在所有的 class object 之外（代码段）。</li>
<li>Virtual functions 则以两个步骤支持之：
<ul>
<li>每一个 class 产生出一堆指向 virtual functions 的指针，放在表格之中。这个表格被称为 virtual table（vtbl）</li>
<li>每一个 class object 被添加了一个指针，指向相关的 virtual table。通常这个指针被称为 vptr。vptr 的设定（setting）和重置（resetting）都由每一个 class 的 constructor、destructor 和 copy assignment 运算符自动完成。每一个 class 所关联的 type_info object（用以支持：runtime type identifcation，RTTI）也经由 virtual table 被指出来，通常是放在表格的第一个 slot 处<br>
<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo3.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="加上继承adding-inheritance"><a class="markdownIt-Anchor" href="#加上继承adding-inheritance"></a> 加上继承（Adding Inheritance）</h2>
<p>单一继承：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Library_materials</span> {...}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> : <span class="keyword">public</span> Library_materials {..}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rental_book</span> : <span class="keyword">public</span> Book {..}</span><br></pre></td></tr></tbody></table></figure>
<p>多重继承：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原本的（更早于标准版的）iostream 实现方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iostream</span>:</span><br><span class="line">    <span class="keyword">public</span> istream,</span><br><span class="line">    <span class="keyword">public</span> ostream {..}</span><br></pre></td></tr></tbody></table></figure>
<p>甚至，继承关系也可以指定为虚拟（virtual，也就是共享的意思）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">istream</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ios {...}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ostream</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ios {...}</span><br></pre></td></tr></tbody></table></figure>
<p>在虚拟继承的情况下，base class 不管在继承串链中被派生（derived）多少次，永远只会存在一个实体（称为 subobject）。例如 iostream 之中就只有 virtual ios base class 的一个实体。<br>
<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo4.png" alt=""></p>
<p>base class table 被产生出来时，表格中的每一个 slot 内含一个相关的 base class 地址，这很像 virtual table 内含每一个 virtual function 的地址一样。每一个 class object 内含一个 bptr，它会被初始化，指向其 base class table。</p>
<ul>
<li>缺点：主要缺点是由于间接性而导致的空间和存取时间上的额外负担，</li>
<li>优点：
<ul>
<li>在每一个 class object 中对于继承都有一致的表现方式：每一个 class object 都应该在某个固定位置上安放一个 base table 指针，与 base classes 的大小或数目无关</li>
<li>不需要改变 class objects 本身，就可以放大、缩小、或更改 base class table<br>
<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo5.png" alt=""></li>
</ul>
</li>
</ul>
<p>需要多少内存才能够表现一个 class object？一般而言要有：</p>
<ul>
<li>其 nonstatic data members 的总和大小。</li>
<li>加上任何由于 alignment 的需求而填补（padding）上去的空间。</li>
<li>加上为了支持 virtual 而由内部产生的任何额外负担（overhead）。</li>
</ul>
<h1 id="构造函数语义学"><a class="markdownIt-Anchor" href="#构造函数语义学"></a> 构造函数语义学</h1>
<h2 id="default-constructor-的建构操作"><a class="markdownIt-Anchor" href="#default-constructor-的建构操作"></a> Default Constructor 的建构操作</h2>
<p>C++ Standard【ISO-C++95】的 Section12.1 这么说：<br>
对于 class X，如果没有任何 user-declared constructor，那么会有一个 default constructor 被暗中（implicitly）声明出来。一个被暗中声明出来的 default constructor 将是一个 trivial（浅薄而无能，没啥用的）constructor。</p>
<p>C++ Standard 然后开始叙述在什么样的情况下这个 implicit default constructor 会被视为 trivial。一个 nontrivial default constructor 在 ARM 的术语中就是编译器所需要的那种，必要的话会由编译器合成出来。下面分别讨论 nontrivial default constructor 的四种情况。</p>
<h3 id="带有-default-constructor-的-member-class-object"><a class="markdownIt-Anchor" href="#带有-default-constructor-的-member-class-object"></a> 带有 Default Constructor 的 Member Class Object</h3>
<p>如果一个 class 没有任何 constructor，但它内含一个 member object，而后者有 default constructor，那么这个 class 的 implicit default constructor 就是“nontrivial’”，编译器需要为此 class 合成出一个 default constructor。</p>
<ul>
<li>在 C++各个不同的编译模块中，编译器如何避免合成出多个 default constructor 呢？解决方法是把合成的 default constructor、copy constructor、destructor、assignment copy operator 都以 inline 方式完成。一个 inline 函数有静态链接（static linkage），不会被档案以外者看到。如果函数太复杂，不适合做成 inline，就会合成出一个 explicit non-inline static 实体</li>
<li>“如果 class A 内含一个或一个以上的 member class objects，那么 class A 的每一个 constructor 必须调用每一个 member classes 的 default constructor”。编译器会扩张已存在的 constructors，在其中安插一些代码，使得 user code 在被执行之前，先调用必要的 default constructors</li>
<li>如果有多个 class member objects 都要求 constructor 初始化操作，将如何呢？C++语言要求以“member objects 在 class 中的声明次序”来调用各个 constructors</li>
</ul>
<h3 id="带有-default-constructor-的-base-class"><a class="markdownIt-Anchor" href="#带有-default-constructor-的-base-class"></a> 带有 Default Constructor 的 Base Class</h3>
<p>类似的道理，如果一个没有任何 constructors 的 class 派生自一个“带有 default constructor’”的 base class，那么这个 derived class 的 default constructor 会被视为 nontrivial，并因此需要被合成出来。它将调用上一层 base classes 的 default constructor（根据它们的声明次序）。</p>
<p>如果设计者提供多个 constructors，但其中都没有 default constructor 呢？编译器会扩张现有的每一个 constructors，将“用以调用所有必要之 default constructors”的程序代码加进去。它不会合成一个新的 default constructor，这是因为其它“由 user 所提供的 constructors”存在的缘故。</p>
<p>如果同时亦存在着“带有 default constructors”的 member class objects，那些 default constructor 也会被调用-—在所有 base class constructor 都被调用之后。</p>
<h3 id="带有一个-virtual-function-的-class"><a class="markdownIt-Anchor" href="#带有一个-virtual-function-的-class"></a> 带有一个 Virtual Function 的 Class</h3>
<ul>
<li>class 声明（或继承）一个 virtual function</li>
<li>class 派生自一个继承串链，其中有一个或更多的 virtual base classes</li>
</ul>
<p>不管哪一种情况，由于缺乏由 user 声明的 constructors，编译器会详细记录合成一个 default constructor 的必要信息。</p>
<ul>
<li>一个 virtual function table（在 cfront 中被称为 vtbl）会被编译器产生出来，内放 class 的 virtual functions 地址</li>
<li>在每一个 class object 中，一个额外的 pointer member（也就是 vptr）会被编译器合成出来，内含相关的 class vtbl 的地址</li>
</ul>
<h3 id="带有一个-virtual-base-class-的-class"><a class="markdownIt-Anchor" href="#带有一个-virtual-base-class-的-class"></a> 带有一个 Virtual Base Class 的 Class</h3>
<p>Virtual base class 的实现法在不同的编译器之间有极大的差异。然而，每一种实现法的共通点在于必须使 virtual base class 在其每一个 derived class object 中的位置，能够于执行期准备妥当。例如下面这段程序代码中：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> {<span class="keyword">public</span>:<span class="type">int</span> i;};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X {<span class="keyword">public</span>:<span class="type">int</span> j;};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X {<span class="keyword">public</span>:<span class="type">double</span> d;};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A,<span class="keyword">public</span> B {<span class="keyword">public</span>:<span class="type">int</span> k;};</span><br><span class="line"></span><br><span class="line"><span class="comment">//无法在编译时期决定（resolve）出 pa-&gt;X::i 的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A *pa)</span> </span>{ pa-&gt;i = <span class="number">1024</span>;};</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> A);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> C);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>原先 cfront 的做法是靠“在 derived class object 的每一个 virtual base classes 中安插一个指针”完成。所有“经由 reference 或 pointer 来存取一个 virtual base class”的操作都可以通过相关指针完成。foo() 可以被改写如下，以符合这样的实现策略：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能的编译器转变操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A*pa)</span> </span>{pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>;}</span><br></pre></td></tr></tbody></table></figure>
<p>其中__vbcX 表示编译器所产生的指针，指向 virtual base class X。正如你所臆测的那样，__vbcX（或编译器所做出的某个什么东西）是在 class object 建构期间被完成的。对于 class 所定义的每一个 constructor，编译器会安插那些“允许每一个 virtual base class 的执行期存取操作”的码。如果 class 没有声明任何 constructors，编译器必须为它合成一个 default constructor。</p>
<h2 id="copy-constructor-的建构操作"><a class="markdownIt-Anchor" href="#copy-constructor-的建构操作"></a> Copy Constructor 的建构操作</h2>
<p>有三种情况，会以一个 object 的内容作为另一个 class object 的初值。最明显的一种情况当然就是对一个 object 做明确的初始化操作，另两种情况是当 object 被当作参数交给某个函数以及当函数传回一个 class object 时。</p>
<h3 id="default-memberwise-initialization"><a class="markdownIt-Anchor" href="#default-memberwise-initialization"></a> Default Memberwise Initialization</h3>
<p>如果 class 没有提供一个 explicit copy constructor 又当如何？当 class object 以“相同 class 的另一个 object”作为初值时，其内部是以所谓的 default memberwise initializatior 手法完成的，也就是把每一个内建的或派生的 datamember（例如一个指针或数目组）的值，从某个 object 拷贝一份到另一个 object 身上。不过它并不会拷贝其中的 member class object，而是以递归的方式施行 memberwise initializaon。</p>
<p>如果一个 String object 被声明为另一个 class 的 member，像这样：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Word</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//……没有 explicit copy constructorprivate:</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _occurs;</span><br><span class="line">    string _word；<span class="comment">//译注：String object 成为 class Word 的一个 member!</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>那么一个 Word object 的 default memberwise initialization 会拷贝其内建的 member _occurs，然后再于 String member object_word 身上递归实施 memberwise initialization</p>
<p>就像 default constructor 一样，C++ Standard 上说，如果 class 没有声明一个 copy constructor，就会有隐含的声明（implicitly declared）或隐含的定义（implicitlydefined）出现。和以前一样，C++Standard 把 copy constructor 区分为 trivial 和 nontrivial 两种。只有 nontrivial 的实体才会被合成于程序之中。决定一个 copy constructor 是否为 trivial 的标准在于 class 是否展现出所谓的“bitwise copysemantics’”。</p>
<h3 id="bitwise-copy-semantics位逐次拷贝"><a class="markdownIt-Anchor" href="#bitwise-copy-semantics位逐次拷贝"></a> Bitwise Copy Semantics（位逐次拷贝）</h3>
<p>在下面的程序片段中：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Word.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Word <span class="title">noun</span><span class="params">(<span class="string">"book"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Word verb = noun;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>很明显 verb 是根据 noun 来初始化。但是在尚未看过 class Word 的声明之前，我们不可能预测这个初始化操作的程序行为。如果 class Word 的设计者定义了一个 copy constructor，verb 的初始化操作会调用它。但如果该 class 没有定义 explicit copy constructor，那么是否会有一个编译器合成的实体被调用呢？这就得视该 class 是否展现"bitwise copy semantics’”而定。举个例子，已知下面的 class Word 声明：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下声明展现了 bitwise copy semantic</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Word</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Word</span>(<span class="type">const</span> <span class="type">char</span>*)</span><br><span class="line">    ~<span class="built_in">Word</span>() {<span class="keyword">delete</span>[] str;}</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>这种情况下并不需要合成出一个 default copy constructor，因为上述声明展现了“default copy semantics”，而 verb 的初始化操作也就不需要以一个函数调用收场。</p>
<p>一般来说，如果你的 class 仅包含了 POD（Plain Object Data) 这样的，是展现出了 Bitwise Copy Semantics，即编译器在内部可以一个字节一个字节的拷贝（如 memcpy）也不会出现问题。</p>
<p>然而，如果 class Word 是这样声明：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下声明并未展现出 bitwise copy semantics</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Word</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Word</span>(<span class="type">const</span> String&amp;)</span><br><span class="line">    ~<span class="built_in">Word</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    String str;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>其中 String 声明了一个 explicit copy constructor：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* );</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp;);</span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>在这个情况下，编译器必须合成出一个 copy constructor 以便调用 member class String object 的 copy constructor：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个被合成出来的 copy constructor</span></span><br><span class="line"><span class="comment">//C++伪码</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Word::Word</span><span class="params">(<span class="type">const</span> Word&amp; wd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    str.String::<span class="built_in">String</span>(wd.str);</span><br><span class="line">    cnt = wd.cnt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>有一点很值得注意：在这被合成出来的 copy constructor 中，如整数、指针、数组等等的 nonclass members 也都会被复制，正如我们所期待的一样。</p>
<h3 id="不要-bitwise-copy-semantics"><a class="markdownIt-Anchor" href="#不要-bitwise-copy-semantics"></a> 不要 Bitwise Copy Semantics！</h3>
<p>什么时候一个 class 不展现出“bitwise copy semantics”呢？有四种情况：</p>
<ul>
<li>当 class 内含一个 member object 而后者的 class 声明有一个 copy constructor 时（不论是被 class 设计者明确地声明，就像前面的 String 那样；或是被编译器合成，像 class Word 那样）。</li>
<li>当 class 继承自一个 base class 而后者存在有一个 copy constructor 时（再次强调，不论是被明确声明或是被合成而得）。</li>
<li>当 class 声明了一个或多个 virtual functions 时。</li>
<li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时。</li>
</ul>
<p>前两种情况中，编译器必须将 member 或 base class 的“copy constructors 调用操作”安插到被合成的 copy constructor 中。前一节 class Word 的“合成而得的 copy constructor”正足以说明情况 1,2。情况 3 和 4 有点复杂，是我接下来要讨论的题目。</p>
<p><strong>重新设定 Virtual Table 的指针</strong><br>
回忆编译期间的两个程序扩张操作（只要有一个 class 声明了一个或多个 virtual functions 就会如此）：</p>
<ul>
<li>增加一个 virtual function table（vtbl），内含每一个有作用的 virtual function 的地址。</li>
<li>将一个指向 virtual function table 的指针（vptr），安插在每一个 class object 内。</li>
</ul>
<p>很显然，如果编译器对于每一个新产生的 class object 的 vptr 不能成功而正确地设好其初值，将导致可怕的后果。因此，当编译器导入一个 vptr 到 class 之中时，该 class 就不再展现 bitwise semantics 了。现在，编译器需要合成出一个 copy constructor，以求将 vptr 适当地初始化。<br>
<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo6.png" alt=""></p>
<p>yogi 会被 default Bear constructor 初始化。而在 constructor 中，yogi 的 vptr 被设定指向 Bear class 的 virtual table（靠编译器安插的码完成）。因此，把 yogi 的 vptr 值拷贝给 winnie 的 vptr 是安全的。</p>
<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo7.png" alt=""><br>
合成出来的 ZooAnimal copy constructor 会明确设定 object 的 vptr 指向 ZooAnimal class 的 virtual table，而不是直接从右手边的 class object 中将其 vptr 现值拷贝过来。</p>
<h1 id="data-语意学"><a class="markdownIt-Anchor" href="#data-语意学"></a> Data 语意学</h1>
<h2 id="类对象大小受三个因素影响"><a class="markdownIt-Anchor" href="#类对象大小受三个因素影响"></a> 类对象大小受三个因素影响</h2>
<ul>
<li>virtual base 和 virtual function 带来的 vptr 影响</li>
<li>EBO（Empty Base class Optimize）空基类优化处理，EBC（Empty Base Class）占用一个字节，其他含有数据成员的从 EBC 派生的派生类，只会算自己数据成员的大小，不受 EBC 一字节的影响</li>
<li>alignment 字节对齐</li>
</ul>
<h2 id="nonstatic-data-members"><a class="markdownIt-Anchor" href="#nonstatic-data-members"></a> Nonstatic data members</h2>
<ul>
<li>Nonstatic data members 在 class object 中的排列顺序将和其被声明顺序一样，任何中间介入的 static data members 都不会被放进布局之中</li>
<li>每一个 nonstatic data member 的偏移量在编译时即可获知，不管其有多么复杂的派生，都是一样的。通过对象存取一个 nonstatic data member，其效率和存取一个 C struct member 是一样的</li>
<li>从对象存取 obj.x 和指针存取 pt-&gt;x 有和差异？<br>
当继承链中有虚基类时，查找虚基类的成员变量时延迟到了执行期，根据 virtual class offset 查找到虚基类的部分，效率稍低</li>
</ul>
<h2 id="静态成员变量-static-data-members"><a class="markdownIt-Anchor" href="#静态成员变量-static-data-members"></a> 静态成员变量 static data members</h2>
<ul>
<li>存放在程序的 data segment 之中</li>
<li>通过指针和对象来存取 member，完全一样，不管继承或者是虚拟继承得来，全局也只存在唯一一个实例</li>
<li>静态常量成员可以在类定义时直接初始化，而普通静态常量成员只能在。o 编译单元的全局范围内初始化</li>
</ul>
<h2 id="迷承与-data-member"><a class="markdownIt-Anchor" href="#迷承与-data-member"></a> “迷承”与 Data Member</h2>
<h4 id="只要继承不要多态inheritance-without-polymorphism"><a class="markdownIt-Anchor" href="#只要继承不要多态inheritance-without-polymorphism"></a> 只要继承不要多态（Inheritance without Polymorphism）</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">    <span class="type">char</span> c3;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo8.png" alt=""></p>
<p>在一部 32 位机器中，每一个 Concrete class object 的大小都是 8 bytes，细分如下：</p>
<ul>
<li>val 占用 4 bytes</li>
<li>c1、c2 和 c3 各占用 1 bytes</li>
<li>alignment（调整到 word 边界）需要 1 bytes</li>
</ul>
<p>现在假设，经过某些分析之后，我们决定了一个更逻辑的表达方式，把 Concrete 分裂为三层结构：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete1</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//.…</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">char</span> bit1;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete2</span> : <span class="keyword">public</span> Concrete1</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> bit2;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Concrete3</span> : <span class="keyword">public</span> Concrete2</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> bit3;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>Concrete1 内含两个 members：val 和 bit1，加起来是 5 bytes。而一个 Concrete.object 实际用掉 8 bytes，包括填补用的 3 bytes，以使 object 能够符合一部机器的 word 边界。不论是 C 或 C++都是这样。一般而言，边界调整（alignment）是由处理器（processor）来决定的。</p>
<p>Concrete2 的 bit2 实际上被放在填补空间所用的 3 bytes 之后。于是其大小变成 12 bytes，不是 8 bytes。其中有 6 bytes 浪费在填补空间上。相同的道理使得 Concrete3 object 的大小是 16 bytes，其中 9 bytes 用于填补空间。<br>
<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo9.png" alt=""></p>
<h4 id="多重继承multiple-inheritance"><a class="markdownIt-Anchor" href="#多重继承multiple-inheritance"></a> 多重继承（Multiple Inheritance）</h4>
<p>多重继承既不像单一继承，也不容易模塑出其模型。例如，考虑下面这个多重继承所获得的 class Vertex3d：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point2d</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...（译注：拥有 virtual 接口。所以 Point2d 对象之中会有 Vptr）</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _x,_y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span> : <span class="keyword">public</span> Point2d</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vertex</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...（译注：拥有 virtual 接口。所以 Point2d 对象之中会有 Vptr）</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    Vertex *next;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex3d</span> : <span class="keyword">public</span> Point3d ，<span class="keyword">public</span> vertex</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> mumble;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>其继承关系如下：<br>
<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo10.png" alt=""></p>
<p>内存布局如下：<br>
<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo11.png" alt=""></p>
<h4 id="虚拟继承-vitual-inheritance"><a class="markdownIt-Anchor" href="#虚拟继承-vitual-inheritance"></a> 虚拟继承 (Vitual Inheritance)</h4>
<p>一般的实现方法如下所述。Class 如果内含一个或多个 virtual base class subobjects，将被分割为两部分：一个不变局部和一个共享局部。不变局部中的数据，不管后继如何衍化，总是拥有固定的 offset（从 object 的开头算起），所以这一部分数据可以被直接存取。至于共享局部，所表现的就是 virtual base class subobject。这一部分的数据，其位置会因为每次的派生操作而有变化，所以它们只可以被间接存取。各家编译器实现技术之间的差异就在于间接存取的方法不同。下面是 Vertex3d 虚拟继承的层次结构：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point2d</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...（译注：拥有 virtual 接口。所以 Point2d 对象之中会有 Vptr）</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _x,_y;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span> : <span class="keyword">public</span> vitrual Point2d</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _z;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vertex</span> : <span class="keyword">public</span> vitrual Point2d</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//，·.（译注：拥有 virtual 接口。所以 Vertex 对象之中会有 vptr）</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    Vertex *next;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex3d</span>:: <span class="keyword">public</span> Point3d ，<span class="keyword">public</span> vertex</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> mumble;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>其继承关系如下：<br>
<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo12.png" alt=""></p>
<p>内存布局如下：<br>
<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo13.png" alt=""></p>
<h1 id="function-语意学"><a class="markdownIt-Anchor" href="#function-语意学"></a> Function 语意学</h1>
<h2 id="c的设计准则之一nostatic-member-function-至少必须和一般的-nonmember-function-有相同的效率"><a class="markdownIt-Anchor" href="#c的设计准则之一nostatic-member-function-至少必须和一般的-nonmember-function-有相同的效率"></a> C++的设计准则之一：nostatic member function 至少必须和一般的 nonmember function 有相同的效率</h2>
<ul>
<li>改写函数原型，在参数中增加 this 指针。</li>
<li>对每一个"nonstatic data member 的存取操作"改为由 this 指针来存取。</li>
<li>将 member function 重写为一个外部函数，经过"mangling"处理。</li>
</ul>
<h2 id="覆盖override-重写overload-隐藏hide的区别"><a class="markdownIt-Anchor" href="#覆盖override-重写overload-隐藏hide的区别"></a> 覆盖（override）、重写（overload）、隐藏（hide）的区别</h2>
<ul>
<li>重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。</li>
<li>覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样。</li>
<li>隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。</li>
</ul>
<h2 id="virtual-member-functions虚拟成员函数"><a class="markdownIt-Anchor" href="#virtual-member-functions虚拟成员函数"></a> Virtual Member Functions（虚拟成员函数）</h2>
<p>我们已经看过了 virtual function 的一般实现模型：每一个 class 有一个 virtual table，内含该 class 之中有作用的 virtual function 的地址，然后每个 object 有一个 vptr，指向 virtual table 的所在。在这一节中，我要走访一组可能的设计，然后根据单一继承、多重继承和虚拟继承等各种情况，从细部上探究这个模型、为了支持 virtual function 机制，必须首先能够对于多态对象有某种形式的“执行期类型判断法（runtime type resolution）”。也就是说，以下的调用操作将需要 ptr 在执行期的某些相关信息，</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>如此一来才能够找到并调用 z() 的适当实体。或许最直接了当但是成本最高的解决方法就是把必要的信息加在 ptr 身上。在这样的策略之下，一个指针（或是一个 reference）含有两项信息：</p>
<ul>
<li>它所参考到的对象的地址。</li>
<li>对象类型的某种编码，或是某个结构的地址。</li>
</ul>
<p>这个方法带来两个问题</p>
<ul>
<li>第一，它明显增加了空间负担，即使程序并不使用多态（polymorphism）。</li>
<li>第二，它打断了与 C 程序间的链接兼容性。如果这份额外信息不能够和指针放在一起，下一个可以考虑的地方就是把它放在对象本身。</li>
</ul>
<p>欲鉴定哪些 classes 展现多态特性，我们需要额外的执行期信息。一如我所说，关键词 class 和 struct 并不能够帮助我们。由于没有导入如 polymorphic 之类的新关键词，因此识别一个 class 是否支持多态，唯一适当的方法就是看看它是否有任何 virtual function。只要 class 拥有一个 virtual function，它就需要这份额外的执行期信息。</p>
<p>下一个明显的问题是，什么样的额外信息是我们需要存储起来的？也就是说，如果我有这样的调用：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>其中 z() 是一个 virtual function，那么什么信息才能让我们在执行期调用正确的 z() 实体？我需要知道：</p>
<ul>
<li>ptr 所指对象的真实类型。这可使我们选择正确的 z() 实体。</li>
<li>z() 实体位置，以便我能够调用它。</li>
</ul>
<p>那么，我如何有足够的知识在编译时期设定 virtual function 的调用呢？</p>
<ul>
<li>一般而言，我并不知道 ptr 所指对象的真正类型，然而我知道，经由 ptr 可以存取到该对象的 virtual table。虽然我不知道哪一个 z() 函数实体会被调用，但我知道每一个 z() 函数地址都被放在 slot4。这些信息使得编译器可以将该调用转化为：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*ptr-&gt;vptr[<span class="number">4</span>]) (ptr );</span><br></pre></td></tr></tbody></table></figure>
<p>在这个转化中，ptr 表示编译器所安的指针，指向 virtual table；4 表示 z() 被赋值的 slot 编号（关联到 Point 体系的 virtual table）唯一个在执行期才能知道的东西是：slot4 所指的到底是哪一个 z() 函数实体？</p>
<p>在一个单一继承体系中，virtual function 机制的行为十分良好，不但有效率而且很容易塑造出模型来。但是在多重继承和虚拟继承之中，对 virtual functions 的支持就没有那么美好了。</p>
<h3 id="多重继承下的-virtual-functions"><a class="markdownIt-Anchor" href="#多重继承下的-virtual-functions"></a> 多重继承下的 Virtual Functions</h3>
<p>在多重继承中支持 virtual functions，其复杂度围绕在第二个及后继的 base classes 身上，以及“必须在执行期调整 this 指针”这一点。以下面的 class 体系为例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class 体系，用来描述多重继承（MI）情况下支持 virtual function 时的复杂度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base1</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speakclearly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base1 *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> data_Base1;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base2</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mumble</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base2 *<span class="title">clone</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> data_Base2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived *<span class="title">clone</span> <span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> data_Derived;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo15.png" alt=""></p>
<p>“Derived 支持 virtual functions”的困难度，统统落在 Base2 subobject 身上。有三个问题需要解决，以此例而言分别是</p>
<ul>
<li>virtual destructor。</li>
<li>被继承下来的 Base2：mumble()。</li>
<li>一组 clone() 函数实体。</li>
</ul>
<p>让我依次解决每一个问题</p>
<p><strong>第一种情况：</strong><br>
我把一个从 heap 中配置而得的 Derived 对象的地址，指定给一个 Base2 指针：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</span><br></pre></td></tr></tbody></table></figure>
<p>新的 Derived 对象的地址必须调整，以指向其 Base2 subobject。编译时期会产生以下代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转移以支持第二个 base class</span></span><br><span class="line">Derived *temp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2 *pbase2 = temp ? temp + <span class="built_in">sizeof</span> ( Base1 ) : <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>如果没有这样的调整，指针的任何“非多态运用”（像下面那样）都将失败：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即使 pbase2 被指定一个 Derived 对象，这也应该没有问题</span></span><br><span class="line">pbase2-&gt;data_Base2;</span><br></pre></td></tr></tbody></table></figure>
<p>当程序员要删除 pbase2 所指的对象时：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须首先调用正确的 virtual destructor 函数实体</span></span><br><span class="line"><span class="comment">//然后施行 delete 运算符。</span></span><br><span class="line"><span class="comment">//pbase2 可能需要调整，以指出完整对象的起始点</span></span><br><span class="line"><span class="keyword">delete</span> pbase2;</span><br></pre></td></tr></tbody></table></figure>
<p>指针必须被再一次调整，以求再一次指向 Derived 对象的起始处（推测它还指向 Derived 对象）。然而上述的 offset 加法却不能够在编译时期直接设定，因为 pbase2 所指的真正对象只有在执行期才能确定。</p>
<p>一般规则是，经由指向“第二或后继之 base class”的指针（或 reference）来调用 derived class virtual function。泽注就像本例的：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">delete</span> pbase2; <span class="comment">//invoke derived class's destructor (virtual)</span></span><br></pre></td></tr></tbody></table></figure>
<p>该调用操作所连带的“必要的 this 指针调整”操作，必须在执行期完成。也就是说，offset 的大小，以及把 offset 加到 this 指针上头的那一小段程序代码必须由编译器在某个地方插人。问题是，在哪个地方？</p>
<p><strong>offset</strong><br>
Bjarne 原先实施于 cfront 编译器中的方法是将 virtual table 加大，使它容纳此处所需的 this 指针，调整相关事物。每一个 virtual table slot，不再只是一个指针，而是一个聚合体，内含可能的 offset 以及地址。于是 virtual function 的调用操作由：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*pbase2-&gt;vptr [<span class="number">1</span>])(pbase2 )</span><br></pre></td></tr></tbody></table></figure>
<p>改变为：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*pbase2-&gt;vptr[<span class="number">1</span>].faddr)</span><br><span class="line">    pbase2 + pbase2-&gt;vptr[<span class="number">1</span>].offset )</span><br></pre></td></tr></tbody></table></figure>
<p>其中 faddr 内含 virtual function 地址，offset 内含 this 指针调整值。</p>
<p>这个做法的缺点是，它相当于连带处罚了所有的 virtual function 调用操作。不管它们是否需要 offset 的调整我所谓的处罚，包括 offset 的额外存取及其加法，以及每一个 virtual table slot 的大小改变。</p>
<p>比较有效率的解决方法是利用所谓的 thunk。Thunk 技术初次引进到编译器技术中，我相信是为了支持 ALGOL 独一无二的 pass-by-name 语意。所谓 thunk 是一小段 assembly 码，用来以适当的 offset 值调整 this 指针，跳到 virtual function 去。例如，经由一个 Base？指针调用 Derived destructor，其相关的 thunk 可能看起来是这个样子：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚拟 C++码</span></span><br><span class="line">pbase2_dtor_thunk:</span><br><span class="line">    <span class="keyword">this</span> += <span class="built_in">sizeof</span> (base1)</span><br><span class="line">    Derived::~<span class="built_in">Derived</span> (<span class="keyword">this</span> )</span><br></pre></td></tr></tbody></table></figure>
<p>Bjarne 并不是不知道 thunk 技术，问题是 thunk 只有以 assembly 码完成才有效率可言。由于 cfront 使用 C 作为其程序代码产生语言，所以无法提供一个有效率的 thunk 编译器。<br>
Thunk 技术允许 virtual table slot 继续内含一个简单的指针，因此多重继承不需要任何空间上的额外负担。Slots 中的地址可以直接指向 virtual function，也可以指向一个相关的 thunk（如果需要调整 this 指针的话）。于是，对于那些不需要调整 this 指针的 virtual function（相信大部分是如此，虽然我手上没有数据）而言，也就不需承载效率上的额外负担。<br>
调整 this 指针的第二个额外负担就是，由于两种不同的可能：</p>
<ul>
<li>经由 derived class 调用，经由第二个 base class 调用，同一函数在 virtual table 中可能需要多笔对应的 slots。例如：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base1 *pbase1 = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">delete</span> pbase1;</span><br><span class="line"><span class="keyword">delete</span> pbase2;</span><br></pre></td></tr></tbody></table></figure>
<p>虽然两个 delete 操作导致相同的 Derived destructor，但它们需要两个不同的 virtual table slots:</p>
<ul>
<li>pbase1 不需要调整 this 指针（因为 Base1 是最左端 base class 之故，它已经指向 Derived 对象的起始处）。其 virtual table slot 需放置真正的 destructor 地址。</li>
<li>pbase2 需要调整 this 指针。其 virtual table slot 需要相关的 thunk 地址。</li>
</ul>
<p>在多重继承之下，一个 derived class 内含 n-1 个额外的 virtual tables，n 表示其上一层 base classes 的数目（因此，单一继承将不会有额外的 virtual tables）。对于本例之 Derived 而言，会有两个 virtual tables 被编译器产生出来：</p>
<ul>
<li>一个主要实体，与 Basel（最左端 base class）共享。</li>
<li>一个次要实体，与 Base2（第二个 base class）有关。</li>
</ul>
<p>针对每一个 virtual tables，Derived 对象中有对应的 vptr。图 4.2 说明了这一点。vptrs 将在 constructor（s）中被设立初值（经由编译器所产生出来的码）<br>
<img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Program/Language/oo16.png" alt=""></p>
<p>用以支持“一个 class 拥有多个 virtual tables’”的传统方法是，将每一个 tables 以外部对象的形式产生出来，并给予独一无二的名称。例如，Derived 所关联的两个 tables 可能有这样的名称：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vtbl Derived;  <span class="comment">//主要表格</span></span><br><span class="line">vtbl Base2_Derived;  <span class="comment">//次要表格</span></span><br></pre></td></tr></tbody></table></figure>
<p>于是当你将一个 Derived 对象地址指定给一个 Base1 指针或 Derived 指针时，被处理的 virtual table 是主要表格 vtbl Derived。而当你将一个 Derived 对象地址指定给一个 Base2 指针时，被处理的 virtual table 是次要表格 vtbl Base2 Derived。</p>
<p>由于执行期链接器（runtime linkers）的降临，符号名称的链接可能变得非常缓慢。为了调节执行期链接器的效率，Sun 编译器将多个 virtual tables 连锁为一个；指向次要表格的指针，可由主要表格名称加上一个 offset 获得。在这样的策略下，每一个 class 只有一个具名的 virtual table。“对于许多 Sun 项目程序代码而言，速度的提升十分明显。</p>
<p>稍早我曾写道，有三种情况，第二或后继的 base class 会影响对 virtual functions 的支持。第一种情况是，通过一个“指向第二个 base class”的指针，调用 derived class virtual function。例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base2 *ptr = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//调用 Derived：~Derived</span></span><br><span class="line"><span class="comment">//ptr 必须被向后调整 sizeof（Basel）个 bytes</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></tbody></table></figure>
<p>从图 4.2 之中，你可以看到这个调用操作的重点：ptr 指向 Derived 对象中的 Base2 subobject；为了能够正确执行，ptr 必须调整指向 Derived 对象的起始处。</p>
<p><strong>第二种情况：</strong><br>
是第一种情况的变化，通过一个“指向 derived class”的指针，调用第二个 base class 中一个继承而来的 virtual function。在此情况下，derived class 指针必须再次调整，以指向第二个 base subobject。例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Derived *pder = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//调用 Base2：mumble()</span></span><br><span class="line"><span class="comment">//per 必须被向前调整 sizeof（zaael）个 bytes</span></span><br><span class="line">pder-&gt;<span class="built_in">munble</span>();</span><br></pre></td></tr></tbody></table></figure>
<p><strong>第三种情况：</strong><br>
发生于一个语言扩充性质之下：允许一个 virtual function 的返回值类型有所变化，可能是 base type，也可能是 publicly derived type。这一点可以通过 Derivea：clone() 函数实体来说明。clone 函数的 Derived 版本传回一个 Derived class 指针，默默地改写了它的两个 base class 函数实体。当我们通过“指向第二个 base class’”的指针来调用 clone() 时，this 指针的 offset 问题于是诞生：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pb1 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">//调用 Derived*Derived：clone()</span></span><br><span class="line"><span class="comment">//返回值必须被调整，以指向 Base2 subobject</span></span><br><span class="line">Base2 *pb2 = pb1-&gt;<span class="built_in">clone</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>当进行 pb1-&gt;clone() 时，pb1 会被调整指向 Derived 对象的起始地址，于是 clone() 的 Derived 版会被调用：它会传回一个指针，指向一个新的 Derived 对象；该对象的地址在被指定给 pb2 之前，必须先经过调整，以指向 Base2 subobject。</p>
<p>当函数被认为“足够小”的时候，Sun 编译器会提供一个所谓的“splitfunctions”技术：以相同算法产生出两个函数，其中第二个在返回之前，为指针加上必要的 offset。于是不论通过 Base1 指针或 Derived 指针调用函数，都不需要调整返回值；而通过 Base2 指针所调用的，是另一个函数。</p>
<p>如果函数并不小，“split function”策略会给予此函数中的多个进入点（entrypoints）中的一个。每一个进人点需要三个指令，然而 OO 程序员都会尽量使用小规模的 virtual function 将操作“局部化”。通常，virtual function 的平均大小是 8 行。</p>
<p>函数如果支持多重进入点，就可以不必有许多“thunks’”。如 IBM 就是把 thunk 搂抱在真正被调用的 virtual function 中。函数一开始先调整 this 指针，然后才执行程序员所写的函数码：至于不需调整的函数调用操作，就直接进人的部分。</p>
<h3 id="虚拟继承下的-virtual-functions"><a class="markdownIt-Anchor" href="#虚拟继承下的-virtual-functions"></a> 虚拟继承下的 Virtual Functions</h3>
<p>两者之间的转换也就需要调整 this 指针。至于在虚拟继承的情况下要消除 thunks，一般而言已经被证明是一项高难度技术。</p>
<p>当一个 virtual base class 从另一个 virtual base class 派生而来，并且两者都支持 virtual functions 和 nonstatic data members 时，编译器对于 virtual base class 的支持简直就像进了迷宫一样。我的建议是：</p>
<blockquote>
<p>不要在一个 virtual base class 中声明 nonstatic data members</p>
</blockquote>
<h2 id="静态成员函数-static-member-functions"><a class="markdownIt-Anchor" href="#静态成员函数-static-member-functions"></a> 静态成员函数 static member functions</h2>
<ul>
<li>不能访问非静态成员。</li>
<li>不能声明为 const、volatile 或 virtual。</li>
<li>参数没有 this。</li>
<li>可以不用对象访问，直接 类名：: 静态成员函数访问。</li>
</ul>
<h2 id="vtable-虚函数表一定是在编译期间获知的其函数的个数-位置和地址是固定不变的完全由编译器掌控执行期间不允许任何修改"><a class="markdownIt-Anchor" href="#vtable-虚函数表一定是在编译期间获知的其函数的个数-位置和地址是固定不变的完全由编译器掌控执行期间不允许任何修改"></a> vtable 虚函数表一定是在编译期间获知的，其函数的个数、位置和地址是固定不变的，完全由编译器掌控，执行期间不允许任何修改</h2>
<p>vtable 的内容：</p>
<ul>
<li>virtual class offset（有虚基类才有）。</li>
<li>topoffset。</li>
<li>typeinfo。</li>
<li>继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数。</li>
<li>新的虚函数（或者是纯虚函数占位）。</li>
</ul>
<h2 id="执行期虚函数调用步骤"><a class="markdownIt-Anchor" href="#执行期虚函数调用步骤"></a> 执行期虚函数调用步骤</h2>
<ul>
<li>通过 vptr 找到 vtbl。</li>
<li>通过 thunk 技术以及 topoffset 调整 this 指针（因为成员函数里面可能调用了成员变量）。</li>
<li>通过 virtual class offset 找到虚基类共享部分的成员。</li>
<li>执行 vtbl 中对应 slot 的函数。</li>
<li>多重继承中，一个派生类会有 n-1 个额外的 vtbl（也可能有 n 或者 n 以上个 vtbl，看是否有虚基类），它与第一父类共享 vtbl，会修改其他父类的 vtbl。</li>
</ul>
<blockquote>
<p>最后：Inline 对编译器只是请求，并非命令。inline 中的局部变量+有表达式参数–&gt;大量临时变量–&gt;程序规模暴涨</p>
</blockquote>
<h1 id="执行期语意学"><a class="markdownIt-Anchor" href="#执行期语意学"></a> 执行期语意学</h1>
<ul>
<li>尽量推迟变量定义，避免不必要的构造和析构（虽然 C++编译器会尽量保证在调用变量的时候才进行构造，推迟变量定义会使得代码好阅读）.</li>
<li>全局类变量在编译期间被放置于 data 段中并被置为 0.
<ul>
<li>GOOGLE C++编程规范：禁止使用 class 类型的静态或全局变量，只允许使用 POD 型静态变量 (Plain Old Data) 和原生数据类型。因为它们会导致很难发现的 bug 和不确定的构造和析构函数调用顺序</li>
<li>解决：改成在 static 函数中，产生局部 static 对象</li>
</ul>
</li>
<li>如果有表达式产生了临时对象，那么应该对完整表达式求值结束之后才摧毁这些创建的临时对象。有两个例外：
<ul>
<li>该临时对象被 refer 为另外一个对象的引用；</li>
<li>该对象作为另一对象的一部分被使用，而另一对象还没有被释放。</li>
</ul>
</li>
</ul>
<h1 id="站在对象模型的尖端"><a class="markdownIt-Anchor" href="#站在对象模型的尖端"></a> 站在对象模型的尖端</h1>
<ul>
<li>对于 RTTI 的支持，在 vtbl 中增加一个 type_info 的 slot。</li>
<li>dynamic_cast 比 static_cast 要花费更多的性能（检查 RTTI 释放匹配、指针 offset 等），但是安全性更好。</li>
<li>对引用施加 dynamic_cast：1）成功；或 2）抛出 bad_cast 异常；对指针施加：1）成功；2）返回 0 指针。</li>
<li>使用** typeid() **进行判断，合法之后再进行 dynamic_cast，这样就能够避免对引用操作导致的 bad_cast 异常： if(typeid(rt) == typeid(rt2)) …。但是如果 rt 和 rt2 本身就是合法兼容的话，就会损失了一次 typeid 的操作性能。</li>
</ul>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pmZW5nemhlbi9CbG9nL2Jsb2IvbWFzdGVyL2FydGljbGUvJUUzJTgwJThBJUU2JUI3JUIxJUU1JTg1JUE1JUU2JThFJUEyJUU3JUI0JUEyQyUyQiUyQiVFNSVBRiVCOSVFOCVCMSVBMSVFNiVBOCVBMSVFNSU5RSU4QiVFMyU4MCU4QiVFOCVBRiVCQiVFNCVCOSVBNiVFNyVBQyU5NCVFOCVBRSVCMC5tZA==">https://github.com/zfengzhen/Blog/blob/master/article/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md<i class="fa fa-external-link-alt"></i></span><br>
《深入探索 C++对象模型》</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <span class="social-link">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </span>

          <img class="social-item-img" src="/picture/qrcode_for_gh_ef4ee2392948_258.jpg">
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Programming/" rel="tag"><i class="fa fa-tag"></i> Programming</a>
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Program/LinksAndLibrariesPart5/" rel="prev" title="链接装载与库（五）动态链接">
                  <i class="fa fa-angle-left"></i> 链接装载与库（五）动态链接
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Program/CPPEffectivePart1/" rel="next" title="C++（二） Effective C++（上）">
                  C++（二） Effective C++（上） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">CarlyleLiu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">469k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">28:24</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhcmx5bGVsaXU=" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline.carlyleliu.vip","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"(发表评论)","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":["nick"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/Program/CPPobjectModel/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
