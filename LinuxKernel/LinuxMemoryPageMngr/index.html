<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 内存管理（四）虚拟内存管理 | Matrix</title><meta name="author" content="CarlyleLiu"><meta name="copyright" content="CarlyleLiu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="页表寻址过程 这里就是 cpu 将一个虚拟地址转换为物理地址的过程，整个过程是比较繁琐耗时的，因此这个过程一般在一个专门的硬件中完成就是 MMU、MMU 中为了可以加快速度引入了 TLB cache 快速查找 pte。我们需要注意到一点就是到了 PTE 这一级需要提供的是物理地址的页起始地址，这个地址是以 page size 为单位的，对于 4k 的 page，那么 pte 的低 12bit 就是">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内存管理（四）虚拟内存管理">
<meta property="og:url" content="https://carlyleliu.github.io/LinuxKernel/LinuxMemoryPageMngr/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="页表寻址过程 这里就是 cpu 将一个虚拟地址转换为物理地址的过程，整个过程是比较繁琐耗时的，因此这个过程一般在一个专门的硬件中完成就是 MMU、MMU 中为了可以加快速度引入了 TLB cache 快速查找 pte。我们需要注意到一点就是到了 PTE 这一级需要提供的是物理地址的页起始地址，这个地址是以 page size 为单位的，对于 4k 的 page，那么 pte 的低 12bit 就是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unsplash.it/1600/900?random&2084">
<meta property="article:published_time" content="2021-11-19T17:47:50.000Z">
<meta property="article:modified_time" content="2025-09-27T04:36:15.355Z">
<meta property="article:author" content="CarlyleLiu">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Kernel">
<meta property="article:tag" content="Memory">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unsplash.it/1600/900?random&2084"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://carlyleliu.github.io/LinuxKernel/LinuxMemoryPageMngr/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 内存管理（四）虚拟内存管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-27 12:36:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Matrix" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://unsplash.it/1600/900?random&amp;2084')"><nav id="nav"><span id="blog-info"><a href="/" title="Matrix"><span class="site-name">Matrix</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux 内存管理（四）虚拟内存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-19T17:47:50.000Z" title="发表于 2021-11-20 01:47:50">2021-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-27T04:36:15.355Z" title="更新于 2025-09-27 12:36:15">2025-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/">Technology Blog</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/Linux/Kernel/">Kernel</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux 内存管理（四）虚拟内存管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="页表寻址过程"><a href="#页表寻址过程" class="headerlink" title="页表寻址过程"></a>页表寻址过程</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/pagefindAddress.png" alt=""></p>
<p>这里就是 cpu 将一个虚拟地址转换为物理地址的过程，整个过程是比较繁琐耗时的，因此这个过程一般在一个专门的硬件中完成就是 MMU、MMU 中为了可以加快速度引入了 TLB cache 快速查找 pte。我们需要注意到一点就是到了 PTE 这一级需要提供的是物理地址的页起始地址，这个地址是以 page size 为单位的，对于 4k 的 page，那么 pte 的低 12bit 就是没有使用的，而这 12bit 就正好用来作为 page 的权限控制位，对于 ARM64（39bit va）其高位 [40-63] 也没有使用因此也可以用来做一些其他事情。这里来看看 arm-v8 对低 12bit 的定义：</p>
<span id="more"></span>
<p>《Architecture Reference Manual ARMv8, for ARMv8-A architecture profile》里的 D4.3.2 ARMv8 translation table level 3 descriptor formats 一节中有相关描述：<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/VMSAV8-64.png" alt=""></p>
<p>ARM-v8 支持 5 种 L3 页表格式，其中我们关心的是 Page 4K granule 这一种，对此有如下说明：</p>
<ul>
<li><strong>Bit 0：</strong> Value bit，1 is valued and 0 is invaled</li>
<li><p><strong>Bit 1：</strong>  identifies the descriptor type； 0 is Reserved, invalid and 1 is Page</p>
<ul>
<li><p><strong>4KB translation granule</strong></p>
<p>  Bits[47:12] are bits[47:12] of the output address for a page of memory.</p>
</li>
<li><p><strong>16KB translation granule</strong></p>
<p>  Bits[47:14] are bits[47:14] of the output address for a page of memory.</p>
</li>
<li><p><strong>64KB translation granule</strong></p>
<p>  Bits[47:16] are bits[47:16] of the output address for a page of memory.</p>
</li>
</ul>
</li>
<li><p><strong>Lower attributes：</strong>（Attribute fields in stage 1 VMSAv8-64 Block and Page descriptors）<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/AttributeFieldsForVMSAv8.png" alt=""></p>
</li>
<li><p><strong>UXN or XN, bit[54] （</strong>页面在用户模式下不能执行<strong>）</strong></p>
<p>  This bit is called UXN (Unprivileged execute never) in the EL1&amp;0 translation regime, where it only<br>  determines whether execution at EL0 of instructions fetched from the region is permitted. In the<br>  other translation regimes the bit is called XN (Execute never).</p>
</li>
<li><p><strong>PXN, bit[53](</strong>该页面在特权模式下不能执行)</p>
<p>  The Privileged execute-never bit. Determines whether the region is executable at EL1。</p>
</li>
<li><p><strong>Contiguous, bit[52] （</strong>表示当前页表项处在一个连续物理页面集合中，可以使用一个单一的 TLB 表项进行优化<strong>）</strong></p>
<p>  A hint bit indicating that the translation table entry is one of a contiguous set or entries, that might<br>  be cached in a single TLB entry。</p>
</li>
<li><p><strong>nG, bit[11](非全局比特位，</strong>用于 TLB 管理。TLB 的表项分成全局的和进程持有的。当设置该比特位时表示这个页面对应的 TLB 表项是进程持有的<strong>)</strong></p>
<p>  The not global bit. Determines whether the TLB entry applies to all ASID values, or only to the<br>  current ASID value。</p>
</li>
<li><p><strong>AF, bit[10](</strong>当第一次访问页面时硬件会自动设置这个访问比特位)</p>
<p>  The Access flag。</p>
</li>
<li><p><strong>SH 内存缓存共享属性</strong></p>
<p>  Shareability field</p>
<ul>
<li>00：没有共享</li>
<li>01：保留</li>
<li>10：Outer Shareable</li>
<li>11：Inner Shareable</li>
</ul>
</li>
<li><p><strong>AP[2:1]</strong></p>
<ul>
<li>AP[1]: 表示该内存允许用户权限 (EL0) 还是更高权限的特权异常等级 (EL1) 来访问。<ul>
<li>1：表示可以被 EL0 以及更高特权的异常等级访问</li>
<li>0：表示不能被 EL0 访问，但是可以被 EL1 访问</li>
</ul>
</li>
<li><p>AP[2]: 只读权限还是可读可写权限</p>
<ul>
<li>1：表示只读</li>
<li>0：表示可读可写</li>
</ul>
<p>Data Access Permissions bits</p>
</li>
</ul>
</li>
<li><p><strong>NS, bit[5] （</strong>非安全比特位。当处于安全模式时用来指定访问的内存地址是安全映射的还是非安全映射的<strong>）</strong></p>
<p>  Non-secure bit. For memory accesses from Secure state, specifies whether the output address is in<br>  the Secure or Non-secure address map</p>
</li>
<li><p><strong>AttrIndx[2:0], bits<a href="内存的属性、设备内存、普通内存等">4:2</a></strong></p>
<p>  Stage 1 memory attributes index field</p>
<ul>
<li>0：DEVICE_nGnRnE</li>
<li>1：DEVICE_nGnRE</li>
<li>2：DEVICE_GRE</li>
<li>3：NORMAL_NC</li>
<li>4：NORMAL</li>
<li>5：NORMAL_WT</li>
</ul>
</li>
</ul>
<h1 id="在-linux-下的定义"><a href="#在-linux-下的定义" class="headerlink" title="在 linux 下的定义"></a>在 linux 下的定义</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/pgtable-hwdef.h&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Level 3 descriptor (PTE).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_VALID		(_AT(pteval_t, 1) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_TYPE_MASK		(_AT(pteval_t, 3) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_TYPE_PAGE		(_AT(pteval_t, 3) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_TABLE_BIT		(_AT(pteval_t, 1) &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_USER		(_AT(pteval_t, 1) &lt;&lt; 6)		<span class="comment">/* AP[1] */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_RDONLY		(_AT(pteval_t, 1) &lt;&lt; 7)		<span class="comment">/* AP[2] */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_SHARED		(_AT(pteval_t, 3) &lt;&lt; 8)		<span class="comment">/* SH[1:0], inner shareable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_AF			(_AT(pteval_t, 1) &lt;&lt; 10)	<span class="comment">/* Access Flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_NG			(_AT(pteval_t, 1) &lt;&lt; 11)	<span class="comment">/* nG */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_GP			(_AT(pteval_t, 1) &lt;&lt; 50)	<span class="comment">/* BTI guarded */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_DBM			(_AT(pteval_t, 1) &lt;&lt; 51)	<span class="comment">/* Dirty Bit Management */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_CONT		(_AT(pteval_t, 1) &lt;&lt; 52)	<span class="comment">/* Contiguous range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PXN			(_AT(pteval_t, 1) &lt;&lt; 53)	<span class="comment">/* Privileged XN */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_UXN			(_AT(pteval_t, 1) &lt;&lt; 54)	<span class="comment">/* User XN */</span></span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="整体初始化流程"><a href="#整体初始化流程" class="headerlink" title="整体初始化流程"></a>整体初始化流程</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/VMMstartKernel.png" alt=""></p>
<h1 id="idmp-映射（恒等映射，为了开启-MMU）"><a href="#idmp-映射（恒等映射，为了开启-MMU）" class="headerlink" title="idmp 映射（恒等映射，为了开启 MMU）"></a>idmp 映射（恒等映射，为了开启 MMU）</h1><p>text：<strong>idmap_text_start~</strong>idmap_text_end</p>
<p>data：idmap_pg_dir~idmap_pg_end</p>
<p>一旦启动 MMU 就需要使用虚拟地址，现代处理器大多数是多级流水线，处理器会提前预取多条指令到流水线中，打开 MMU 时，这些指令都是物理地址预取的；在 MMU 开启后，将以虚拟地址访问，这样就会出错，所以引入了“恒等映射”，即在过渡阶段的代码，虚拟地址和物理地址相等。恒等映射完成后，就启动 MMU，进入虚拟地址访问阶段。恒等映射的代码在 <strong>idmap_text_start~</strong>idmap_text_end，可以从 System.map 文件中查询到。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ffffffc081206000 T __idmap_text_start</span><br><span class="line">ffffffc081206000 t enter_vhe</span><br><span class="line">ffffffc081206038 T cpu_resume</span><br><span class="line">ffffffc081206068 T primary_entry</span><br><span class="line">ffffffc0812060a8 T init_kernel_el</span><br><span class="line">ffffffc0812060b8 t init_el1</span><br><span class="line">ffffffc0812060e0 t init_el2</span><br><span class="line">ffffffc0812062f0 T secondary_holding_pen</span><br><span class="line">ffffffc081206318 t pen</span><br><span class="line">ffffffc081206330 T secondary_entry</span><br><span class="line">ffffffc081206340 t secondary_startup</span><br><span class="line">ffffffc081206368 T __enable_mmu</span><br><span class="line">ffffffc0812063b0 T __cpu_secondary_check52bitva</span><br><span class="line">ffffffc0812063b8 t __no_granule_support</span><br><span class="line">ffffffc0812063e0 t __relocate_kernel</span><br><span class="line">ffffffc081206430 t __primary_switch</span><br><span class="line">ffffffc0812064a0 T idmap_cpu_replace_ttbr1</span><br><span class="line">ffffffc0812064d0 T idmap_kpti_install_ng_mappings</span><br><span class="line">ffffffc08120667c t __idmap_kpti_secondary</span><br><span class="line">ffffffc0812066c8 T __cpu_setup</span><br><span class="line">ffffffc0812067bc T __idmap_text_end</span><br></pre></td></tr></tbody></table></figure>
<p>恒等映射目的就是为<strong>idmap_text_start~</strong>idmap_text_end 这段代码创建一个映射页表，使其虚拟地址和物理地址是相等的。在 vmlinux.lds.S 中，事先已经分配了 IDMAP_DIR_SIZE 的空间用于存储页表，通常页表为 3 个连续的 4KB 页面，分别对于 PGD,PUD,PMD 页表，这里没有使用 PTE，所以粒度是 2MB 的大小。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init_idmap_pg_dir = .;</span><br><span class="line">. += INIT_IDMAP_DIR_SIZE;</span><br><span class="line">init_idmap_pg_end = .;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="粗粒度的内核映像映射（为了进入内核空间）"><a href="#粗粒度的内核映像映射（为了进入内核空间）" class="headerlink" title="粗粒度的内核映像映射（为了进入内核空间）"></a>粗粒度的内核映像映射（为了进入内核空间）</h1><p>text: kernel_text </p>
<p>data：init_pg_dir~init_pg_end（定义在 arch/arm64/kernel/vmlinux.lds.S 链接文件中）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">init_pg_dir = .;</span><br><span class="line">. += INIT_DIR_SIZE;</span><br><span class="line">init_pg_end = .;</span><br><span class="line">/* end of zero-init region */</span><br></pre></td></tr></tbody></table></figure>
<p>之所以要创建第二个页表，是因为 cpu 刚启动时，物理内存一般都在低地址（不会超过 256TB），恒等映射的地址实际也在用户空间，即 MMU 启用后 idmap_pg_dir 会填入 TTBR0，而内核空间链接地址（虚拟地址）都是在高地址，需要填入 TTBR1，因此需要再创建一张表，映射整个内核镜像，且虚拟地址空间是在高地址 0xffff xxxx xxxx xxxxarch/arm64/kernel/head.S:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adrp x1, _text</span><br><span class="line">adrp x2, init_pg_dir</span><br><span class="line">adrp x3, init_pg_end</span><br><span class="line">bic x4, x2, #SWAPPER_BLOCK_SIZE - 1</span><br><span class="line">mov_q x5, SWAPPER_RW_MMUFLAGS</span><br><span class="line">mov x6, #SWAPPER_BLOCK_SHIFT</span><br><span class="line">bl remap_region</span><br></pre></td></tr></tbody></table></figure>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/primaryEntry.png" alt=""></p>
<h1 id="fixmap-映射"><a href="#fixmap-映射" class="headerlink" title="fixmap 映射"></a>fixmap 映射</h1><p>Linux 内核要访问物理内存，一旦开启 MMU 后，就只能通过虚拟地址查询页表找到物理地址进行访问，上一章节中建立恒等映射和粗粒度内核映像映射的页表，因此只能保证内核镜像正常访问。如果要解析 DTB，访问设备 I/O 等依然是无法访问的，因为查询不到对应的页表。因此内核引入了 fixmap 机制，就是事先分配一段虚拟地址空间，然后给定其虚拟地址创建好页表，页表中的表项最后一级指向的物理页帧号先不填充，等到实际要访问那段物理内存后再将其填充，然后通过 fixmap 这段虚拟地址范围就可以通过查询页表访问到物理内存。<br>Fixmap 最关键要实现的目的就是将一段空间的虚拟地址与物理地址对应上，linux 内核通过虚拟地址访问到物理空间，那既然是通过虚拟地址访问到物理地址，那必须构建填充这段虚拟地址到物理地址的页表，这样 Linux 内核经过 MMU 利用查找页表找到对应的物理地址进行访问。</p>
<p>fixmap 虚拟地址空间又被平均分成两个部分 permanent fixed addresses 和 temporary fixed addresses。permanent fixed addresses 是永久映射，temporary fixed addresses 是临时映射。永久映射是指在建立的映射关系在 kernel 阶段不会改变，仅供特定模块一直使用。临时映射就是模块使用前创建映射，使用后解除映射。</p>
<p>fixmap 区域又被继续细分，分配给不同模块使用。kernel 中定义枚举类型作为 index，根据 index 可以计算该模拟在 fixmap 区域的虚拟地址。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fixed_addresses</span> {</span></span><br><span class="line">	FIX_HOLE,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reserve a virtual window for the FDT that is a page bigger than the</span></span><br><span class="line"><span class="comment">	 * maximum supported size. The additional space ensures that any FDT</span></span><br><span class="line"><span class="comment">	 * that does not exceed MAX_FDT_SIZE can be mapped regardless of</span></span><br><span class="line"><span class="comment">	 * whether it crosses any page boundary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	FIX_FDT_END,</span><br><span class="line">	FIX_FDT = FIX_FDT_END + DIV_ROUND_UP(MAX_FDT_SIZE, PAGE_SIZE) + <span class="number">1</span>, <span class="comment">// 映射设备树使用。在 ARM64 架构，大小是 4M</span></span><br><span class="line"></span><br><span class="line">	FIX_EARLYCON_MEM_BASE, <span class="comment">// console 使用，大小 1 页。1 页虚拟地址空间完全够了</span></span><br><span class="line">	FIX_TEXT_POKE0,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ACPI_APEI_GHES</span></span><br><span class="line">	<span class="comment">/* Used for GHES mapping from assorted contexts */</span></span><br><span class="line">	FIX_APEI_GHES_IRQ,</span><br><span class="line">	FIX_APEI_GHES_SEA,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM_SDE_INTERFACE</span></span><br><span class="line">	FIX_APEI_GHES_SDEI_NORMAL,</span><br><span class="line">	FIX_APEI_GHES_SDEI_CRITICAL,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_ACPI_APEI_GHES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UNMAP_KERNEL_AT_EL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RELOCATABLE</span></span><br><span class="line">	FIX_ENTRY_TRAMP_TEXT4,	<span class="comment">/* one extra slot for the data page */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	FIX_ENTRY_TRAMP_TEXT3,</span><br><span class="line">	FIX_ENTRY_TRAMP_TEXT2,</span><br><span class="line">	FIX_ENTRY_TRAMP_TEXT1,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMP_VALIAS		(__fix_to_virt(FIX_ENTRY_TRAMP_TEXT1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_UNMAP_KERNEL_AT_EL0 */</span></span></span><br><span class="line">	__end_of_permanent_fixed_addresses,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Temporary boot-time mappings, used by early_ioremap(),</span></span><br><span class="line"><span class="comment">	 * before ioremap() is functional.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_FIX_BTMAPS		(SZ_256K / PAGE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIX_BTMAPS_SLOTS	7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_FIX_BTMAPS	(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)</span></span><br><span class="line"></span><br><span class="line">	FIX_BTMAP_END = __end_of_permanent_fixed_addresses,</span><br><span class="line">	FIX_BTMAP_BEGIN = FIX_BTMAP_END + TOTAL_FIX_BTMAPS - <span class="number">1</span>, <span class="comment">// early_ioremap() 接口使用，这部分属于动态映射。大小是 7 × 256KB</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Used for kernel page table creation, so unmapped memory may be used</span></span><br><span class="line"><span class="comment">	 * for tables.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	FIX_PTE,</span><br><span class="line">	FIX_PMD,</span><br><span class="line">	FIX_PUD,</span><br><span class="line">	FIX_P4D,</span><br><span class="line">	FIX_PGD,</span><br><span class="line"></span><br><span class="line">	__end_of_fixed_addresses</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="Fixmap-映射流程"><a href="#Fixmap-映射流程" class="headerlink" title="Fixmap 映射流程"></a>Fixmap 映射流程</h2><p>fixmap 初始化操作在 early_fixmap_init 函数中完成。主要是建立 PGD/PUD/PMD 页表。fixmap 映射调用栈如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">	--&gt;setup_arch</span><br><span class="line">		--&gt;early_fixmap_init</span><br><span class="line">			--&gt;early_fixmap_init_pud <span class="comment">// 页表存在 bm_pud</span></span><br><span class="line">				--&gt;early_fixmap_init_pmd <span class="comment">// 页表存在 bm_pmd</span></span><br><span class="line">					--&gt;early_fixmap_init_pte <span class="comment">// 页表存在 bm_pte</span></span><br><span class="line">		--&gt;early_ioremap_init <span class="comment">// kernel 启动早期不能使用 ioremap 操作，我们必须借助 early_ioremap 接口</span></span><br><span class="line">			--&gt;early_ioremap_setup</span><br><span class="line">				--&gt;slot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i)</span><br></pre></td></tr></tbody></table></figure>
<p>early ioremap 利用 slot 管理映射，最多支持 FIX_BTMAPS_SLOTS 个映射，每个映射最大支持映射 256KB。slot_virt 数组存储每个 slot 的虚拟地址首地址。prev_map 数组用来记录已经分配出去的虚拟地址，数组值为 0 代表没有分配。prev_size 记录映射的 size。<br>其中 bm_pud、bm_pmd 和 bm_pte 都在内核 image 的全局数组中，也就是在。data 段中，在 idmp 映射阶段对内核做一个粗粒度的映射，在这个映射后就可以通过 mmu 访问内核数据了。这里正好利用这个建立 fixmap 映射。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_index(a)  (((a) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD - 1)) <span class="comment">// PGDIR_SHIFT = 30  PTRS_PER_PGD = 512</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pgd_t</span> *<span class="title function_">pgd_offset_pgd</span><span class="params">(<span class="type">pgd_t</span> *pgd, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> (pgd + pgd_index(address));</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_offset(mm, address)		pgd_offset_pgd((mm)-&gt;pgd, (address))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> <span class="title">init_mm</span> =</span> {</span><br><span class="line">	.mm_mt		= MTREE_INIT_EXT(mm_mt, MM_MT_FLAGS, init_mm.mmap_lock),</span><br><span class="line">	.pgd		= swapper_pg_dir,</span><br><span class="line">	.mm_users	= ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">	.mm_count	= ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">	.write_protect_seq = SEQCNT_ZERO(init_mm.write_protect_seq),</span><br><span class="line">	MMAP_LOCK_INITIALIZER(init_mm)</span><br><span class="line">	.page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),</span><br><span class="line">	.arg_lock	=  __SPIN_LOCK_UNLOCKED(init_mm.arg_lock),</span><br><span class="line">	.mmlist		= LIST_HEAD_INIT(init_mm.mmlist),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PER_VMA_LOCK</span></span><br><span class="line">	.mm_lock_seq	= <span class="number">0</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.user_ns	= &amp;init_user_ns,</span><br><span class="line">	.cpu_bitmap	= CPU_BITS_NONE,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IOMMU_SVA</span></span><br><span class="line">	.pasid		= IOMMU_PASID_INVALID,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	INIT_MM_CONTEXT(init_mm)</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_offset_k(address)		pgd_offset(&amp;init_mm, (address))</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Fixmap-虚拟地址空间视图"><a href="#Fixmap-虚拟地址空间视图" class="headerlink" title="Fixmap 虚拟地址空间视图"></a>Fixmap 虚拟地址空间视图</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/FixmapAddress.png" alt=""></p>
<h2 id="Fixmap-寻址流程"><a href="#Fixmap-寻址流程" class="headerlink" title="Fixmap 寻址流程"></a>Fixmap 寻址流程</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/FixmapAddressFind.png" alt=""><br>以上就是 Fixmap 的地址空间和寻址流程。其中比较重要的是 BITMAP 区域始于 IO 映射区域，而 FDT 属于设备树映射区域，经过 FixedMap 映射后就 kernel 就可以访问 dtb 和 io 了。</p>
<h1 id="线性映射"><a href="#线性映射" class="headerlink" title="线性映射"></a>线性映射</h1><h2 id="构建-PGD-映射表"><a href="#构建-PGD-映射表" class="headerlink" title="构建 PGD 映射表"></a>构建 PGD 映射表</h2><p>页目录直接使用的是 swapper_pg_dir，一个条目映射的空间本身就很大，一个 entry 对应范围有 512GB。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arch/arm64/kernel/vmlinux.lds.S</span><br><span class="line">    swapper_pg_dir = .;</span><br><span class="line">. += PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">swapper_pg_dir 是实现分配的一段空间，处于内核镜像的 data 段。</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/pgtable.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __fix_to_virt(x)	(FIXADDR_TOP - ((x) &lt;&lt; PAGE_SHIFT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __virt_to_fix(x)	((FIXADDR_TOP - ((x)&amp;PAGE_MASK)) &gt;&gt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">fix_to_virt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> idx)</span></span><br><span class="line">{</span><br><span class="line">	BUILD_BUG_ON(idx &gt;= __end_of_fixed_addresses);</span><br><span class="line">	<span class="keyword">return</span> __fix_to_virt(idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a pointer with offset calculated */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __set_fixmap_offset(idx, phys, flags)				\</span></span><br><span class="line"><span class="meta">({									\</span></span><br><span class="line"><span class="meta">	unsigned long ________addr;					\</span></span><br><span class="line"><span class="meta">	__set_fixmap(idx, phys, flags);					\</span></span><br><span class="line"><span class="meta">	________addr = fix_to_virt(idx) + ((phys) &amp; (PAGE_SIZE - 1));	\</span></span><br><span class="line"><span class="meta">	________addr;							\</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fixmap_offset(idx, phys) \</span></span><br><span class="line"><span class="meta">	__set_fixmap_offset(idx, phys, FIXMAP_PAGE_NORMAL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_set_fixmap(addr)	((pgd_t *)set_fixmap_offset(FIX_PGD, addr))</span></span><br><span class="line"></span><br><span class="line"><span class="type">pgd_t</span> *pgdp = pgd_set_fixmap(__pa_symbol(swapper_pg_dir));</span><br></pre></td></tr></tbody></table></figure>
<p>fixmap 区域可以想象成一块内存以页为单位被平均分成<strong>end_of_permanent_fixed_addresses 块。而这些枚举值就是这块内存的 index。因此虚拟地址可以根据 index 进行计算。<br>通过</strong>pa_symbol 先将 swapper_pg_dir 转化为物理地址，然后通过 pgd_set_fixmap 对其进行映射，映射工作主要在__set_fixmap 里，映射完成后返回 FIX_PGD 的虚拟地址+swapper_pg_dir 物理地址的 offset 部分作为 pgdp。</p>
<p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/LineMapAddressFind.png" alt=""><br>有了 pgdp 之后就可以对 kernel、memblock 等进行下一步的映射了。</p>
<h2 id="两个重要的宏pa-和va"><a href="#两个重要的宏pa-和va" class="headerlink" title="两个重要的宏pa 和va"></a>两个重要的宏<strong>pa 和</strong>va</h2><h3 id="pa-宏分析"><a href="#pa-宏分析" class="headerlink" title="__pa 宏分析"></a>__pa 宏分析</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/memory.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __virt_to_phys_nodebug(x) ({					\</span></span><br><span class="line"><span class="meta">	phys_addr_t __x = (phys_addr_t)(__tag_reset(x));		\</span></span><br><span class="line"><span class="meta">	__is_lm_address(__x) ? __lm_to_phys(__x) : __kimg_to_phys(__x);	\</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __virt_to_phys(x)	__virt_to_phys_nodebug(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pa(x)			__virt_to_phys((unsigned long)(x))</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="tag-reset-宏"><a href="#tag-reset-宏" class="headerlink" title="__tag_reset 宏"></a>__tag_reset 宏</h4><p>__tag_reset(x) 是去掉虚拟地址中的 tag（如果有 tag 的话）.</p>
<h4 id="is-lm-address（用于判断虚拟地址-addr-是否在-arm64-的虚拟地址空间的线性地址区域）"><a href="#is-lm-address（用于判断虚拟地址-addr-是否在-arm64-的虚拟地址空间的线性地址区域）" class="headerlink" title="__is_lm_address（用于判断虚拟地址 addr 是否在 arm64 的虚拟地址空间的线性地址区域）"></a>__is_lm_address（用于判断虚拟地址 addr 是否在 arm64 的虚拟地址空间的线性地址区域）</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check whether an arbitrary address is within the linear map, which</span></span><br><span class="line"><span class="comment"> * lives in the [PAGE_OFFSET, PAGE_END) interval at the bottom of the</span></span><br><span class="line"><span class="comment"> * kernel's TTBR1 address range.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __is_lm_address(addr)	(((u64)(addr) - PAGE_OFFSET) &lt; (PAGE_END - PAGE_OFFSET)</span></span><br></pre></td></tr></tbody></table></figure>
<p>先看 PAGE_OFFSET 定义：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.config 里</span><br><span class="line">CONFIG_ARM64_VA_BITS=<span class="number">39</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_BITS			(CONFIG_ARM64_VA_BITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_OFFSET(va)	(-(UL(1) &lt;&lt; (va)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET		(_PAGE_OFFSET(VA_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开就是</span></span><br><span class="line">PAGE_OFFSET		= (UL(<span class="number">-1</span>) &lt;&lt; <span class="number">39</span>) <span class="comment">// 0xFFFFFF80 00000000</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>再看 PAGE_END 定义：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_ARM64_VA_BITS=<span class="number">39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_BITS			(CONFIG_ARM64_VA_BITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VA_BITS_MIN		(VA_BITS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_END(va)		(-(UL(1) &lt;&lt; ((va) - 1)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_END		(_PAGE_END(VA_BITS_MIN))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开就是</span></span><br><span class="line">PAGE_END		= (UL(<span class="number">-1</span>) &lt;&lt; (<span class="number">39</span> - <span class="number">1</span>)) <span class="comment">// 0xFFFFFFC0 00000000</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>线性地址空间为 [0xFFFFFF80 00000000, 0xFFFFFFC0 00000000].</p>
<h4 id="lm-to-phys（线性地址空间内虚拟地址转物理地址）"><a href="#lm-to-phys（线性地址空间内虚拟地址转物理地址）" class="headerlink" title="__lm_to_phys（线性地址空间内虚拟地址转物理地址）"></a>__lm_to_phys（线性地址空间内虚拟地址转物理地址）</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __lm_to_phys(addr)	(((addr) - PAGE_OFFSET) + PHYS_OFFSET)</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里主要是 PHYS_OFFSET 宏的定义：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PHYS_OFFSET		({ VM_BUG_ON(memstart_addr &amp; 1); memstart_addr; })</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>memstart_addr 在 arch/arm64/mm/init.c 里设置 (DRAM 的起始地址）：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">arm64_memblock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	...</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Select a suitable value for the base of physical memory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	memstart_addr = round_down(memblock_start_of_DRAM(),</span><br><span class="line">				   ARM64_MEMSTART_ALIGN);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* 如果线性地址空间小于实际物理地址需要调整 memstart_addr */</span></span><br><span class="line">	<span class="keyword">if</span> (memstart_addr + linear_region_size &lt; memblock_end_of_DRAM()) {</span><br><span class="line">		<span class="comment">/* ensure that memstart_addr remains sufficiently aligned */</span></span><br><span class="line">		memstart_addr = round_up(memblock_end_of_DRAM() - linear_region_size,</span><br><span class="line">					 ARM64_MEMSTART_ALIGN);</span><br><span class="line">		memblock_remove(<span class="number">0</span>, memstart_addr);</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这里打印出来就是 0. 到这里就是分析清楚。</p>
<h4 id="kimg-to-phys（内核-image-物理地址转虚拟地址）"><a href="#kimg-to-phys（内核-image-物理地址转虚拟地址）" class="headerlink" title="__kimg_to_phys（内核 image 物理地址转虚拟地址）"></a>__kimg_to_phys（内核 image 物理地址转虚拟地址）</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the offset between the kernel virtual and physical mappings */</span></span><br><span class="line"><span class="keyword">extern</span> u64			kimage_voffset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __kimg_to_phys(addr)	((addr) - kimage_voffset)</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里知道 kimage_voffset 是内核镜像的虚拟地址和物理地址之间的偏移就可以了，暂时用不到不用分析，基本上就是内核加载到内存中后在内存的物理地址与链接地址之间的偏差。</p>
<h3 id="va-宏分析"><a href="#va-宏分析" class="headerlink" title="__va 宏分析"></a>__va 宏分析</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __phys_to_virt(x)	((unsigned long)((x) - PHYS_OFFSET) | PAGE_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __va(x)			((void *)__phys_to_virt((phys_addr_t)(x)))</span></span><br></pre></td></tr></tbody></table></figure>
<p>分析完<strong>pa 之后看</strong>va 就简单多了，这里只做线性区域的映射，且 PHYS_OFFSET 和 PAGE_OFFSET 都已经分析过了，这里不做过多说明了</p>
<h2 id="映射过程（mem-map）"><a href="#映射过程（mem-map）" class="headerlink" title="映射过程（mem_map）"></a>映射过程（mem_map）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map_mem(pgdp)</span><br><span class="line">	--&gt;__map_memblock(pgdp, start, __phys_to_virt(start), end - start,</span><br><span class="line">			     prot, early_pgtable_alloc, flags)</span><br><span class="line">		--&gt;__create_pgd_mapping(pgdp, start, __phys_to_virt(start), end - start,</span><br><span class="line">			     prot, early_pgtable_alloc, flags)</span><br></pre></td></tr></tbody></table></figure>
<p>其中__create_pgd_mapping 的调用流程如下：<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/createpgdMappingLocked.png" alt=""></p>
<p>通过<strong>create_pgd_mapping 函数建立线性映射的页表，其中参数虚拟地址通过 </strong>phys_to_virt(start) 来转换，而 <strong>phys_to_virt 就是</strong>va 宏的实现对物理地址做一个固定的偏移 PAGE_OFFSET（ 0xFFFFFF80 00000000）。有了虚拟地址和物理地址后剩下的就是建立虚拟地址到物理地址的映射就可以了，就是填充 pud、pmd、pte 页表。</p>
<h2 id="线性映射地址空间"><a href="#线性映射地址空间" class="headerlink" title="线性映射地址空间"></a>线性映射地址空间</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/LineMapSpace.png" alt=""><br>整个 ddr 空间中除了 secmon、kernel image 外其他都是线性映射范围。</p>
<h1 id="VMALLOC-映射"><a href="#VMALLOC-映射" class="headerlink" title="VMALLOC 映射"></a>VMALLOC 映射</h1><h2 id="vmalloc-函数"><a href="#vmalloc-函数" class="headerlink" title="vmalloc() 函数"></a>vmalloc() 函数</h2><ul>
<li>vmalloc 用于分配虚拟地址连续（物理地址不连续）的内存空间，vzmalloc 相对于 vmalloc 多了个 0 初始化</li>
<li>vmalloc/vzmalloc 分配的虚拟地址范围在 VMALLOC_START/VMALLOC_END 之间</li>
<li>linux 管理 vmalloc 分别有两个数据结构：vm_struct, vm_area_struct；前者是内核虚拟地址空间的映射，后者是应用进程虚拟地址空间映射</li>
<li>内核 vmalloc 区具体地址空间的管理是通过 vmap_area 管理的，该结构体记录整个区间的起始和结束</li>
<li>vmalloc 在申请内存时逐页分配，确保在物理内存有严重碎片的情况下，vmalloc 仍然可以工作</li>
<li>vmalloc () 函数的工作方式与 kmalloc() 类似，只不过它分配的内存只是虚拟连续的，而不一定物理连续。用户空间分配函数的工作方式如下：malloc() 返回的页面在处理器的虚拟地址空间中是连续的，但不能保证它们在物理 RAM 中实际上是连续的。kmalloc () 函数保证页面在物理上是连续的（并且虚拟连续）。vmalloc () 函数仅确保页面在虚拟地址空间中是连续的。它通过分配可能不连续的物理内存块并“修复”页表以将内存映射到逻辑地址空间的连续块来实现这一点。</li>
</ul>
<h2 id="数据组织形式"><a href="#数据组织形式" class="headerlink" title="数据组织形式"></a>数据组织形式</h2><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/vmapAreaList.png" alt=""></p>
<p>初始化流程如下：<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/mmCoreInit.png" alt=""></p>
<h1 id="vmap-和-vmalloc"><a href="#vmap-和-vmalloc" class="headerlink" title="vmap() 和 vmalloc()"></a>vmap() 和 vmalloc()</h1><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Linux/vmapmap.png" alt=""><br>vmalloc 流程与 vmap 差不多，只是 page 结构体在 vmap 中是通过参数传递过去的，而 vmalloc 是通过 page_alloc 巷 buddy system 申请的。</p>
<h1 id="VMEMMAP-映射"><a href="#VMEMMAP-映射" class="headerlink" title="VMEMMAP 映射"></a>VMEMMAP 映射</h1><p>vmemmap 是内核中 page 数据的虚拟地址，针对 sparse 内存模型。内核申请 page 获取的 page 地址从此开始。vmemmap 区域是一块起始地址是 VMEMMAP_START，范围是 2TB 的虚拟地址区域，位于 kernel space。以 section 为单位来存放 strcut page 结构的虚拟地址空间，然后线性映射到物理内存。详细过程可参考如下连接：</p>
<h1 id="附录一：宏定义快查"><a href="#附录一：宏定义快查" class="headerlink" title="附录一：宏定义快查"></a>附录一：宏定义快查</h1><h2 id="config-配置"><a href="#config-配置" class="headerlink" title="config 配置"></a>config 配置</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_PGTABLE_LEVELS=<span class="number">3</span></span><br><span class="line">CONFIG_ARM64_VA_BITS_39=y</span><br><span class="line">CONFIG_ARM64_VA_BITS=<span class="number">39</span></span><br><span class="line">CONFIG_ARM64_PA_BITS_48=y</span><br><span class="line">CONFIG_ARM64_PA_BITS=<span class="number">48</span></span><br><span class="line">CONFIG_ARM64_4K_PAGES=y</span><br><span class="line">CONFIG_HZ_250=y</span><br><span class="line">CONFIG_HZ=<span class="number">250</span></span><br><span class="line">CONFIG_ARM64_PAGE_SHIFT=<span class="number">12</span></span><br><span class="line">CONFIG_ARM64_CONT_PTE_SHIFT=<span class="number">4</span></span><br><span class="line">CONFIG_ARM64_CONT_PMD_SHIFT=<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="PAGE-定义"><a href="#PAGE-定义" class="headerlink" title="PAGE 定义"></a>PAGE 定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/page-def.h&gt;</span><br><span class="line"><span class="comment">/* PAGE_SHIFT determines the page size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT		CONFIG_ARM64_PAGE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE		(_AC(1, UL) &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MASK		(~(PAGE_SIZE-1))</span></span><br></pre></td></tr></tbody></table></figure>
<p>PAGE 占 12bit，一页大小是 2^12=4096 = 4k</p>
<h2 id="PTE-定义："><a href="#PTE-定义：" class="headerlink" title="PTE 定义："></a>PTE 定义：</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTRS_PER_PTE		(1 &lt;&lt; (PAGE_SHIFT - 3))</span></span><br></pre></td></tr></tbody></table></figure>
<p>PTRS_PER_PTE = 1 &lt;&lt; (12 - 3) = 512</p>
<h2 id="PMD-定义"><a href="#PMD-定义" class="headerlink" title="PMD 定义"></a>PMD 定义</h2><p>因为 CONFIG_PGTABLE_LEVELS 定义为 3 所以有如下定义：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PMD_SHIFT determines the size a level 2 page table entry can map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_SHIFT		ARM64_HW_PGTABLE_LEVEL_SHIFT(2) <span class="comment">//21</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_SIZE		(_AC(1, UL) &lt;&lt; PMD_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_MASK		(~(PMD_SIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRS_PER_PMD		(1 &lt;&lt; (PAGE_SHIFT - 3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p></p>
<ul>
<li>PMD_SHIFT = (PAGE_SHIFT - 3) * (4 - 2) + 3 = 21</li>
<li>PTRS_PER_PMD = 1 &lt;&lt; (12 - 3) = 512</li>
</ul>
<h2 id="PUD-定义"><a href="#PUD-定义" class="headerlink" title="PUD 定义"></a>PUD 定义</h2><p>只有 4 级页表才有 PUD，三级页表没有 PUD:<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PUD_SHIFT determines the size a level 1 page table entry can map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_SHIFT		ARM64_HW_PGTABLE_LEVEL_SHIFT(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_SIZE		(_AC(1, UL) &lt;&lt; PUD_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_MASK		(~(PUD_SIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRS_PER_PUD		(1 &lt;&lt; (PAGE_SHIFT - 3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p></p>
<ul>
<li>PUD_SHIFT = (PAGE_SHIFT - 3) * (4 - 1) + 3 = 30</li>
<li>PTRS_PER_PUD = 1 &lt;&lt; (12 - 3) = 512</li>
</ul>
<h2 id="PGD-定义"><a href="#PGD-定义" class="headerlink" title="PGD 定义"></a>PGD 定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PGDIR_SHIFT determines the size a top-level page table entry can map</span></span><br><span class="line"><span class="comment"> * (depending on the configuration, this level can be 0, 1 or 2).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGDIR_SHIFT		ARM64_HW_PGTABLE_LEVEL_SHIFT(4 - CONFIG_PGTABLE_LEVELS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGDIR_SIZE		(_AC(1, UL) &lt;&lt; PGDIR_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGDIR_MASK		(~(PGDIR_SIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRS_PER_PGD		(1 &lt;&lt; (VA_BITS - PGDIR_SHIFT))</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>PGDIR_SHIFT = (PAGE_SHIFT - 3) * (4 - 1) + 3 = 30</li>
<li>PTRS_PER_PGD = 1 &lt;&lt; (39 - 30) = 512</li>
</ul>
<h1 id="附录二：相关数据类型定义"><a href="#附录二：相关数据类型定义" class="headerlink" title="附录二：相关数据类型定义"></a>附录二：相关数据类型定义</h1><h2 id="表项数据类型定义"><a href="#表项数据类型定义" class="headerlink" title="表项数据类型定义"></a>表项数据类型定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/include/<span class="keyword">asm</span>/pgtable-types.h&gt;</span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">pteval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">pmdval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">pudval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">p4dval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">pgdval_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are used to make use of C type-checking..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span> <span class="type">pteval_t</span> pte; } <span class="type">pte_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_val(x)	((x).pte)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pte(x)	((pte_t) { (x) } )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span> <span class="type">pmdval_t</span> pmd; } <span class="type">pmd_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pmd_val(x)	((x).pmd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pmd(x)	((pmd_t) { (x) } )</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span> <span class="type">pudval_t</span> pud; } <span class="type">pud_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pud_val(x)	((x).pud)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pud(x)	((pud_t) { (x) } )</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span> <span class="type">pgdval_t</span> pgd; } <span class="type">pgd_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_val(x)	((x).pgd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pgd(x)	((pgd_t) { (x) } )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span> <span class="type">pteval_t</span> pgprot; } <span class="type">pgprot_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_val(x)	((x).pgprot)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pgprot(x)	((pgprot_t) { (x) } )</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="获取表项索引值"><a href="#获取表项索引值" class="headerlink" title="获取表项索引值"></a>获取表项索引值</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;include/linux/pgtable.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_index(a)  (((a) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_PGD - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> pud_index</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pud_index</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> (address &gt;&gt; PUD_SHIFT) &amp; (PTRS_PER_PUD - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pud_index pud_index</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> pmd_index</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pmd_index</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> (address &gt;&gt; PMD_SHIFT) &amp; (PTRS_PER_PMD - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pmd_index pmd_index</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pte_index</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="获取表项地址"><a href="#获取表项地址" class="headerlink" title="获取表项地址"></a>获取表项地址</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pgd_t</span> *<span class="title function_">pgd_offset_pgd</span><span class="params">(<span class="type">pgd_t</span> *pgd, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> (pgd + pgd_index(address));</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a shortcut to get a pgd_t in a given mm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> pgd_offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_offset(mm, address)		pgd_offset_pgd((mm)-&gt;pgd, (address))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find an entry in the second-level page table.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> pmd_offset</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pmd_t</span> *<span class="title function_">pmd_offset</span><span class="params">(<span class="type">pud_t</span> *pud, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> pud_pgtable(*pud) + pmd_index(address);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pmd_offset pmd_offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> pud_offset</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pud_t</span> *<span class="title function_">pud_offset</span><span class="params">(<span class="type">p4d_t</span> *p4d, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> p4d_pgtable(*p4d) + pud_index(address);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pud_offset pud_offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>通过 pgd_offset_pgd 就可以找到一个虚拟内存地址在 PGD 中的页目录项了。</p>
<blockquote>
<p>说明：这里的 PGD、PUD、PMD 为什么都是使用 9bit，这个是因为在 64bit 系统下，每个地址要占 8 字节，而对于 page size=4k 大小的页面，一个页面所能容纳的地址数量正好是 4096 / 8 = 512，而要寻址这 512 个索引需要 2^9=512 也就是需要 9bit。这里也是使用 9bit 的原因，如果用更大的 page size 则更合理的做法是相应的增大 PGD、PUD、PMD 占的 bit 数，这样可以更充分的利用空间。</p>
</blockquote>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《奔跑吧 Linux 内核》</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Kernel/">Kernel</a><a class="post-meta__tags" href="/tags/Memory/">Memory</a></div><div class="post_share"><div class="social-share" data-image="https://unsplash.it/1600/900?random&amp;2084" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/LinuxKernel/LinuxMemoryPageAllocate/" title="Linux 内存管理（五）页面分配器"><img class="cover" src="https://unsplash.it/1600/900?random&amp;4232" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux 内存管理（五）页面分配器</div></div></a></div><div class="next-post pull-right"><a href="/LinuxKernel/LinuxMemoryBasic/" title="Linux 内存管理（三）物理地址管理"><img class="cover" src="https://unsplash.it/1600/900?random&amp;6831" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux 内存管理（三）物理地址管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/LinuxKernel/LinuxMemoryARM64linux/" title="Linux 内存管理（二）ARM64 的虚拟地址转换在 linux 中的实现"><img class="cover" src="https://unsplash.it/1600/900?random&3657" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-14</div><div class="title">Linux 内存管理（二）ARM64 的虚拟地址转换在 linux 中的实现</div></div></a></div><div><a href="/LinuxKernel/LinuxMemoryBasic/" title="Linux 内存管理（三）物理地址管理"><img class="cover" src="https://unsplash.it/1600/900?random&6831" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-14</div><div class="title">Linux 内存管理（三）物理地址管理</div></div></a></div><div><a href="/LinuxKernel/LinuxMemoryCache/" title="Linux 内存管理（一）Cache"><img class="cover" src="https://unsplash.it/1600/900?random&5511" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-10</div><div class="title">Linux 内存管理（一）Cache</div></div></a></div><div><a href="/LinuxKernel/LinuxMemoryDebug/" title="Linux 内存管理（十一）调试信息"><img class="cover" src="https://unsplash.it/1600/900?random&3776" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">Linux 内存管理（十一）调试信息</div></div></a></div><div><a href="/LinuxKernel/LinuxMemoryKSM/" title="Linux 内存管理（十）KSM"><img class="cover" src="https://unsplash.it/1600/900?random&5561" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-04</div><div class="title">Linux 内存管理（十）KSM</div></div></a></div><div><a href="/LinuxKernel/LinuxMemoryOptimization/" title="Linux 内存管理（十二）内存调优"><img class="cover" src="https://unsplash.it/1600/900?random&1621" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-05</div><div class="title">Linux 内存管理（十二）内存调优</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CarlyleLiu</div><div class="author-info__description">CarlyleLiu’s Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/carlyleliu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/carlyleliu" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yyliushuai@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://twitter.com/yyliushuai" target="_blank" title="Twitter"><i class="fab fa-twitter" style="color: #24292e;"></i></a><a class="social-icon" href="https://youtube.com/carlyleliu" target="_blank" title="YouTube"><i class="fab fa-youtube" style="color: #24292e;"></i></a><a class="social-icon" href="https://instagram.com/blurredliu" target="_blank" title="Instagram"><i class="fab fa-instagram" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">next主题站 https://carlyleliu.github.io/next</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%AF%BB%E5%9D%80%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">页表寻址过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8-linux-%E4%B8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">在 linux 下的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">整体初始化流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#idmp-%E6%98%A0%E5%B0%84%EF%BC%88%E6%81%92%E7%AD%89%E6%98%A0%E5%B0%84%EF%BC%8C%E4%B8%BA%E4%BA%86%E5%BC%80%E5%90%AF-MMU%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">idmp 映射（恒等映射，为了开启 MMU）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B2%97%E7%B2%92%E5%BA%A6%E7%9A%84%E5%86%85%E6%A0%B8%E6%98%A0%E5%83%8F%E6%98%A0%E5%B0%84%EF%BC%88%E4%B8%BA%E4%BA%86%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">粗粒度的内核映像映射（为了进入内核空间）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fixmap-%E6%98%A0%E5%B0%84"><span class="toc-number">5.</span> <span class="toc-text">fixmap 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Fixmap-%E6%98%A0%E5%B0%84%E6%B5%81%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">Fixmap 映射流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fixmap-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E8%A7%86%E5%9B%BE"><span class="toc-number">5.2.</span> <span class="toc-text">Fixmap 虚拟地址空间视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fixmap-%E5%AF%BB%E5%9D%80%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">Fixmap 寻址流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84"><span class="toc-number">6.</span> <span class="toc-text">线性映射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-PGD-%E6%98%A0%E5%B0%84%E8%A1%A8"><span class="toc-number">6.1.</span> <span class="toc-text">构建 PGD 映射表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%8Fpa-%E5%92%8Cva"><span class="toc-number">6.2.</span> <span class="toc-text">两个重要的宏pa 和va</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pa-%E5%AE%8F%E5%88%86%E6%9E%90"><span class="toc-number">6.2.1.</span> <span class="toc-text">__pa 宏分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tag-reset-%E5%AE%8F"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">__tag_reset 宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#is-lm-address%EF%BC%88%E7%94%A8%E4%BA%8E%E5%88%A4%E6%96%AD%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80-addr-%E6%98%AF%E5%90%A6%E5%9C%A8-arm64-%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E5%8C%BA%E5%9F%9F%EF%BC%89"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">__is_lm_address（用于判断虚拟地址 addr 是否在 arm64 的虚拟地址空间的线性地址区域）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lm-to-phys%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%86%85%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">__lm_to_phys（线性地址空间内虚拟地址转物理地址）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kimg-to-phys%EF%BC%88%E5%86%85%E6%A0%B8-image-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="toc-number">6.2.1.4.</span> <span class="toc-text">__kimg_to_phys（内核 image 物理地址转虚拟地址）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#va-%E5%AE%8F%E5%88%86%E6%9E%90"><span class="toc-number">6.2.2.</span> <span class="toc-text">__va 宏分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B%EF%BC%88mem-map%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">映射过程（mem_map）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">6.4.</span> <span class="toc-text">线性映射地址空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VMALLOC-%E6%98%A0%E5%B0%84"><span class="toc-number">7.</span> <span class="toc-text">VMALLOC 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vmalloc-%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">vmalloc() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">数据组织形式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vmap-%E5%92%8C-vmalloc"><span class="toc-number">8.</span> <span class="toc-text">vmap() 和 vmalloc()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VMEMMAP-%E6%98%A0%E5%B0%84"><span class="toc-number">9.</span> <span class="toc-text">VMEMMAP 映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95%E4%B8%80%EF%BC%9A%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%9F%A5"><span class="toc-number">10.</span> <span class="toc-text">附录一：宏定义快查</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#config-%E9%85%8D%E7%BD%AE"><span class="toc-number">10.1.</span> <span class="toc-text">config 配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PAGE-%E5%AE%9A%E4%B9%89"><span class="toc-number">10.2.</span> <span class="toc-text">PAGE 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PTE-%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">10.3.</span> <span class="toc-text">PTE 定义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PMD-%E5%AE%9A%E4%B9%89"><span class="toc-number">10.4.</span> <span class="toc-text">PMD 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PUD-%E5%AE%9A%E4%B9%89"><span class="toc-number">10.5.</span> <span class="toc-text">PUD 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PGD-%E5%AE%9A%E4%B9%89"><span class="toc-number">10.6.</span> <span class="toc-text">PGD 定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95%E4%BA%8C%EF%BC%9A%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">11.</span> <span class="toc-text">附录二：相关数据类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%A1%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">11.1.</span> <span class="toc-text">表项数据类型定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%A1%A8%E9%A1%B9%E7%B4%A2%E5%BC%95%E5%80%BC"><span class="toc-number">11.2.</span> <span class="toc-text">获取表项索引值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%A1%A8%E9%A1%B9%E5%9C%B0%E5%9D%80"><span class="toc-number">11.3.</span> <span class="toc-text">获取表项地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">12.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By CarlyleLiu</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><!-- hexo injector body_end end --></body></html>