<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 内核调试（一）ftrace | Matrix</title><meta name="author" content="CarlyleLiu"><meta name="copyright" content="CarlyleLiu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="原图">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内核调试（一）ftrace">
<meta property="og:url" content="https://carlyleliu.github.io/LinuxKernel/LinuxKernelDebugftrace/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="原图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unsplash.it/1600/900?random&7944">
<meta property="article:published_time" content="2021-12-12T01:07:40.000Z">
<meta property="article:modified_time" content="2025-09-27T04:36:15.351Z">
<meta property="article:author" content="CarlyleLiu">
<meta property="article:tag" content="Debug">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unsplash.it/1600/900?random&7944"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://carlyleliu.github.io/LinuxKernel/LinuxKernelDebugftrace/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 内核调试（一）ftrace',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-27 12:36:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Matrix" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://unsplash.it/1600/900?random&amp;7944')"><nav id="nav"><span id="blog-info"><a href="/" title="Matrix"><span class="site-name">Matrix</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux 内核调试（一）ftrace</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-12T01:07:40.000Z" title="发表于 2021-12-12 09:07:40">2021-12-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-27T04:36:15.351Z" title="更新于 2025-09-27 12:36:15">2025-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/">Technology Blog</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology-Blog/Linux/Kernel/">Kernel</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux 内核调试（一）ftrace"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/Debugftrace.png" alt=""><br><a target="_blank" rel="noopener" href="https://www.processon.com/embed/6239b035e401fd070bba0eba">原图</a></p>
<span id="more"></span>
<h1 id="位置无关码"><a href="#位置无关码" class="headerlink" title="位置无关码"></a>位置无关码</h1><ul>
<li>加载地址：存储代码的物理地址。如 ARM64 处理器上电复位后是从 0x0 地址开始第一条指令的，所以通常这个地方存放代码最开始的部分，如异常向量表的处理地址</li>
<li>运行地址：指程序运行时的地址</li>
<li>链接地址：在编译链接时指定的地址，编程人员设想将来程序要运行的地址。程序所有标号的地址在链接后便确定了，不管程序在哪里运行都不会改变。aarch64-linux-gnu-obidump (objdump) 工具进行反汇编查看的就接地链接地址</li>
</ul>
<p>链接地址和运行地址可以相同，也可以不同。那什么时候运行地址和链接地址不相同，什么时候相同呢？我们以一块 ARM64 开发板为例，芯片内部有 SRAM，起始地址为 0x0，DDR 内存的起始地址为 0x4000 0000。</p>
<p>通常代码存储在 Nor Flash 存储器或者 Nand Flash 存储器中，芯片内部的 BOOT ROM 会把开始的小部分代码装载到 SRAM 中运行。芯片上电复位之后，从 SRAM 中取指令。由于 Uboot 的镜像太大了，SRAM 放不下，因此必须要放在 DDR 内存中。通常 Uboot 编译时链接地址都设置到 DDR 内存中，也就是 0x4000 0000 地址处。那这时运行地址和链接地址就不一样了。运行地址为 0x0，链接地址变成了 0x4000 0000 那么程序为什么还能运行呢个重要问题，就是位置无关代码和位置有关代码。</p>
<ul>
<li>位置无关代码：从字面意思看，该指令的执行是与内存地址无关的；无论运行地址和链接地址相等或者不相等，该指令都能正常运行。在汇编语言中，像 BL、B、MOV 指令属于位置无关指令，不管程序装载在哪个位置，它们都能正确地运行，它们的地址域是基于 PC 值的相对偏移寻址，相当于 [pc+offset]</li>
<li>位置有关代码：从字面意思看，该指令的执行是与内存地址有关的，和当前 PC 值无关。ARM 汇编里面通过绝对跳转修改 PC 值为当前链接地址的值</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr pc, = on_sdram ; 跳到 SDRAM 中继续执行</span><br></pre></td></tr></tbody></table></figure>
<p>因此，当通过 LDR 指令跳转到链接地址处执行时，运行地址就等于链接地址了。这个过程叫作“重定位”。在重定位之前，程序只能执行和位置无关的一些汇编代码。为什么要刻意设置加载地址、运行地址以及链接地址不一样呢？<br>如果所有代码都在 ROM（或 Nor Flash 存储器）中执行，那么链接地址可以与加载地址相同；而在实际项目应用中，往往想要把程序加载到 DDR 内存中，DDR 内存的访问速度比 ROM 要快很多，而且容量也大。但是碍于加载地址的影响，不可能直接达到这一步，所以思路就是让程序的加载地址等于 ROM 起始地址，而链接地址等于 DDR 内存中某一处的起始地址（暂且称为 ram start）。程序先从 ROM 中启动，最先启动的部分要实现代码复制功能（把整个 ROM 代码复制到 DDR 内存中），并通过 LDR 指令来跳转到 DDR 内存中，也就是在链接地址里运行 B 指令没法实现这个跳转）。上述重定位过程在 U-Boot 中实现，如图所示。<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/relocation.png" alt=""></p>
<p>当跳转到 Linux 内核中时，U-Boot 需要把 Linux 内核映像内容复制到 DDR 内存中，然后跳转到内核入口地址处（ stext 函数）。当跳转到内核入口地址（ stext 函数）时，程序运行在运行地址，即 DDR 内存的地址。但是我们从 vmlinux 看到的 stext 函数的链接地址是虚拟地址（内核启动汇编代码也需要一个重定位过程。这个重定位过程在<strong>primary_switch() 汇编函数中完成。启动 MMU 之后，通过 ldr 指令把 </strong>primary_switched() 函数的链接地址加载到 x8 寄存器，然后通过 br 指令跳转到 __primary_switched() 函数的链接地址处，从而实现了重定位，如图所示<br><img src="https://lsky.carlyleliu.vip/carlyleliu/ImageHosting/TechnologyBlog/Kernel/kernspace.png" alt=""></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;arch/arm64/kernel/head.S&gt;</span><br><span class="line">/*</span><br><span class="line"> * The following fragment of code is executed with the MMU enabled.</span><br><span class="line"> *</span><br><span class="line"> *   x0 = __PHYS_OFFSET</span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_LOCAL(__primary_switched)</span><br><span class="line">	adr_l	x4, init_task</span><br><span class="line">	init_cpu_task x4, x5, x6</span><br><span class="line"></span><br><span class="line">	adr_l	x8, vectors			// load VBAR_EL1 with virtual</span><br><span class="line">	msr	vbar_el1, x8			// vector table address</span><br><span class="line">	isb</span><br><span class="line"></span><br><span class="line">	stp	x29, x30, [sp, #-16]!</span><br><span class="line">	mov	x29, sp</span><br><span class="line"></span><br><span class="line">	str_l	x21, __fdt_pointer, x5		// Save FDT pointer</span><br><span class="line"></span><br><span class="line">	ldr_l	x4, kimage_vaddr		// Save the offset between</span><br><span class="line">	sub	x4, x4, x0			// the kernel virtual and</span><br><span class="line">	str_l	x4, kimage_voffset, x5		// physical mappings</span><br><span class="line"></span><br><span class="line">	// Clear BSS</span><br><span class="line">	adr_l	x0, __bss_start</span><br><span class="line">	mov	x1, xzr</span><br><span class="line">	adr_l	x2, __bss_stop</span><br><span class="line">	sub	x2, x2, x0</span><br><span class="line">	bl	__pi_memset</span><br><span class="line">	dsb	ishst				// Make zero page visible to PTW</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)</span><br><span class="line">	bl	kasan_early_init</span><br><span class="line">#endif</span><br><span class="line">	mov	x0, x21				// pass FDT address in x0</span><br><span class="line">	bl	early_fdt_map			// Try mapping the FDT early</span><br><span class="line">	bl	init_feature_override		// Parse cpu feature overrides</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">	tst	x23, ~(MIN_KIMG_ALIGN - 1)	// already running randomized?</span><br><span class="line">	b.ne	0f</span><br><span class="line">	bl	kaslr_early_init		// parse FDT for KASLR options</span><br><span class="line">	cbz	x0, 0f				// KASLR disabled? just proceed</span><br><span class="line">	orr	x23, x23, x0			// record KASLR offset</span><br><span class="line">	ldp	x29, x30, [sp], #16		// we must enable KASLR, return</span><br><span class="line">	ret					// to __primary_switch()</span><br><span class="line">0:</span><br><span class="line">#endif</span><br><span class="line">	bl	switch_to_vhe			// Prefer VHE if possible</span><br><span class="line">	ldp	x29, x30, [sp], #16</span><br><span class="line">	bl	start_kernel</span><br><span class="line">	ASM_BUG()</span><br><span class="line">SYM_FUNC_END(__primary_switched)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="ftrace"><a href="#ftrace" class="headerlink" title="ftrace"></a>ftrace</h1><p>frace 最早出现在 Linux2.6.27 内核中，其设计目标简单，基于静态代码插桩（stub）技术，不需要用户通过额外的编程来定义 trace 行为。静态代码插桩技术比较可靠，不会因为用户使用不当而导致内核崩溃。 ftrace 的名字源于 function trace 利用 GCC 的 profile 特性在所有函数入口处添加一段插桩代码， ftrace 重载这段代码来实现 trace 功能。GCC 的-pg 选项会在每个函数入口处加入 mcount 的调用代码，原本 mcount 有 libc 实现，而内核不会链接 libc 库，因此 frace 编写了自己的 mcount stub 函数。<br>在使用 ftrace 之前，需要确保内核编译配置选项。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FTRACE=y</span><br><span class="line">ONIFIG_HAVE_FUNCTION_TRACE=y</span><br><span class="line">CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y</span><br><span class="line">CONFIG_HAVE_DYNAMIC_FTRACE=y</span><br><span class="line">CONFIG_FUNCTIONL_TRACER=y</span><br><span class="line">CONFIG_IRQSOFE_TRACER=Y</span><br><span class="line">CONEIG_SCHED_TRACER=y</span><br><span class="line">CONFIG_ENABLE_DEFAULT_TRACERS=y</span><br><span class="line">CONFIG_FTRACE_SYSCALLS=y</span><br><span class="line">CONFIG_PREEMPT_TRACER=y</span><br></pre></td></tr></tbody></table></figure>
<p>ftrace 的相关配置选项比较多，针对不同的跟踪器有各自对应的配置选项。 ftrace 通过 debugfs 文件系统向用户空间提供访间接口，因此需要在系统启动时挂载 debugfs，可以修改系统的 /etc/fstab 文件或手动挂载。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t debugfs debugfs/sys/kernel/debug</span><br></pre></td></tr></tbody></table></figure>
<p>在 sys/kernel/debug/trace 目录下提供了各种跟踪器（ tracer）和事件（ event），一些常用的选项如下。</p>
<ul>
<li>available_tracers：列出当前系统支持的跟踪器</li>
<li>available_events：列出当前系统支持的事件</li>
<li>current_tracer：设置和显示当前正在使用的跟踪器。使用 echo 命令把跟踪器的名字写入该文件，即可切换不同的跟踪器。默认为 nop，即不做任何跟踪操作</li>
<li>trace: 读取跟踪信息。通过 cat 命令查看 ftrace 记录下来的眼踪信息</li>
<li>tracing_on：用于开始或暂停跟踪</li>
<li>trace_options：设置 ftrace 的一些相关选项</li>
</ul>
<p>ftrace 当前包含多个跟踪器，方便用户跟踪不同类型的信息，如进程睡眠、唤醒、抢占、延迟的信息。查看 available_tracers 可以知道当前系统支持哪些跟踪器，如果系统支持的跟踪器上没有用户想要的。那就必须在配置内核时打开，然后重新编译内核。常用的 ftrace 跟踪器如下所示：</p>
<ul>
<li>nop：不跟踪任何信息。将 nop 写入 current_tracer 文件可以清空之前收集到的跟踪信息</li>
<li>function：跟踪内核函数执行情况</li>
<li>function_graph：可以显示类似于 C 语言的函数调用关系图，比较直观</li>
<li>hwlat：用来跟踪与硬件相关的延时</li>
<li>blk：跟踪块设备的函数</li>
<li>mmiotrace：用于跟踪内存映射 I/O 操作</li>
<li>wakeup：跟踪普通优先级的进程从获得调度到被唤醒的最长延迟时间</li>
<li>weakup_rt：跟踪 RT 类型的任务从获得调度到被唤醒的最长延迟时间</li>
<li>irqoff：跟踪关闭中断的信息，并记录关闭的最大时长</li>
<li>preemptoff：跟踪关闭禁止抢占的信息，并记录关闭的最大时长</li>
</ul>
<h1 id="irqs-跟踪器"><a href="#irqs-跟踪器" class="headerlink" title="irqs 跟踪器"></a>irqs 跟踪器</h1><p>当中断关闭（俗称关中断）后，CPU 就不能响应其他的事件。如果这时有一个鼠标中断，要在下一次开中断时才能响应这个中断，这段延时称为中断延迟。向 current_tracer 文件写入 irqsoff 字符串即可打开 irqsoff 来跟踪中断延迟。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/kernel/debug/tracing/</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; options/function-trace //关闭 funct-trace 可以减少一些延退</span><br><span class="line"><span class="built_in">echo</span> irqsoff &gt; current_trace</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; tracing_on</span><br><span class="line">[...] //停顿一会儿</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; tracing_on</span><br><span class="line"><span class="built_in">cat</span> trace</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Function-tracing-no-modification-necessary"><a href="#Function-tracing-no-modification-necessary" class="headerlink" title="Function tracing - no modification necessary"></a>Function tracing - no modification necessary</h1><p>Ftrace 最强大的追踪器之一是函数追踪器。它使用 gcc 的-pg 选项让内核中的每个函数调用一个特殊的函数“ mcount() ”。该函数必须在汇编中实现，因为调用不遵循正常的 C ABI。</p>
<p>当配置 CONFIG_DYNAMIC_FTRACE 时，调用会在启动时转换为 NOP，以保持系统以 100% 的性能运行。在编译过程中，记录了 mcount() 调用站点。该列表在启动时用于将这些站点转换为 NOP。由于 NOP 对跟踪毫无用处，因此当启用函数（或函数图）跟踪器时，保存该列表以将调用站点转换回跟踪调用。</p>
<p>由于此性能增强，强烈建议启用 CONFIG_DYNAMIC_FTRACE。此外，CONFIG_DYNAMIC_FTRACE 提供了筛选应跟踪哪个函数的能力。请注意，即使 NOP 在基准测试中没有显示任何影响，但已知添加-pg 选项附带的帧指针会导致轻微的开销。</p>
<p>要找出哪些跟踪器可用，只需在跟踪目录中查找 available_tracers 文件即可 ：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat available_tracers</span></span><br><span class="line">function_graph <span class="keyword">function</span> sched_switch nop</span><br></pre></td></tr></tbody></table></figure>
<p>要启用函数跟踪器，只需将“function” echo 到 current_tracer 文件中。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo function &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># cat current_tracer</span></span><br><span class="line"><span class="keyword">function</span></span><br><span class="line"></span><br><span class="line">[tracing]<span class="comment"># cat trace | head -10</span></span><br><span class="line"><span class="comment"># tracer: function</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |          |         |</span></span><br><span class="line">            bash-16939 [000]  6075.461561: mutex_unlock &lt;-tracing_set_tracer</span><br><span class="line">          &lt;idle&gt;-0     [001]  6075.461561: _spin_unlock_irqrestore &lt;-hrtimer_get_next_event</span><br><span class="line">          &lt;idle&gt;-0     [001]  6075.461562: rcu_needs_cpu &lt;-tick_nohz_stop_sched_tick</span><br><span class="line">            bash-16939 [000]  6075.461563: inotify_inode_queue_event &lt;-vfs_write</span><br><span class="line">          &lt;idle&gt;-0     [001]  6075.461563: mwait_idle &lt;-cpu_idle</span><br><span class="line">            bash-16939 [000]  6075.461563: __fsnotify_parent &lt;-vfs_write</span><br></pre></td></tr></tbody></table></figure>
<p>标题很好地解释了输出的格式。前两项是跟踪的任务名称和 PID。执行跟踪的 CPU 位于括号内。时间戳是自启动以来的时间，后跟函数名称。在这种情况下，函数是被跟踪的函数，其父函数跟在“ &lt;- ”符号之后。</p>
<p>这些信息非常强大，并且很好地显示了函数的流程。但这可能有点难以遵循。由 Frederic Weisbecker 创建的函数图跟踪器跟踪函数的进入和退出，这使跟踪器能够了解被调用函数的深度。函数图跟踪器可以使人眼更容易跟踪内核中的执行流程：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># cat trace | head -20</span></span><br><span class="line"><span class="comment"># tracer: function_graph</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># CPU  DURATION                  FUNCTION CALLS</span></span><br><span class="line"><span class="comment"># |     |   |                     |   |   |   |</span></span><br><span class="line"> 1)   1.015 us    |        _spin_lock_irqsave();</span><br><span class="line"> 1)   0.476 us    |        internal_add_timer();</span><br><span class="line"> 1)   0.423 us    |        wake_up_idle_cpu();</span><br><span class="line"> 1)   0.461 us    |        _spin_unlock_irqrestore();</span><br><span class="line"> 1)   4.770 us    |      }</span><br><span class="line"> 1)   5.725 us    |    }</span><br><span class="line"> 1)   0.450 us    |    mutex_unlock();</span><br><span class="line"> 1) + 24.243 us   |  }</span><br><span class="line"> 1)   0.483 us    |  _spin_lock_irq();</span><br><span class="line"> 1)   0.517 us    |  _spin_unlock_irq();</span><br><span class="line"> 1)               |  <span class="function"><span class="title">prepare_to_wait</span></span>() {</span><br><span class="line"> 1)   0.468 us    |    _spin_lock_irqsave();</span><br><span class="line"> 1)   0.502 us    |    _spin_unlock_irqrestore();</span><br><span class="line"> 1)   2.411 us    |  }</span><br><span class="line"> 1)   0.449 us    |  kthread_should_stop();</span><br><span class="line"> 1)               |  <span class="function"><span class="title">schedule</span></span>() {</span><br></pre></td></tr></tbody></table></figure>
<p>这给出了一个函数的开始和结束，用类似 C 的注释“ { ”来启动一个函数，“ } ”在末尾。叶函数不调用其他函数，只是以“ ; ”结尾。DURATION 列显示在相应函数中花费的时间。函数图跟踪器记录函数进入和退出的时间，并将差异报告为持续时间。这些数字只出现在叶函数和“ }” 符号。注意，这次还包括嵌套函数内所有函数的开销以及函数图跟踪器本身的开销。函数图跟踪器劫持了函数的返回地址，以便为函数插入跟踪回调函数退出。这会破坏 CPU 的分支预测并导致比函数跟踪器更多的开销。最接近的真实时序仅发生在叶函数中。</p>
<p>孤独的“ + ”是有一个注释标记。当持续时间大于 10 微秒时，显示“ + ”。如果持续时间大于 100 微秒，将显示“ ！ ”。</p>
<h1 id="Using-trace-printk"><a href="#Using-trace-printk" class="headerlink" title="Using trace_printk()"></a>Using trace_printk()</h1><p>printk() 是所有调试器之王，但它有一个问题。如果您正在调试诸如定时器中断、调度程序或网络之类的大容量区域，printk() 可能会导致系统陷入困境，甚至可能会创建实时锁。添加一些 printk() 时，看到错误“消失”也很常见。这是由于 printk() 引入的绝对开销。</p>
<p>Ftrace 引入了一种新形式的 printk() 称为 trace_printk()。它可以像 printk() 一样使用，也可以在任何上下文中使用（中断代码、NMI 代码和调度程序代码）。是什么样的好的 trace_printk() 是，它不会输出到控制台。相反，它写入 Ftrace 环形缓冲区，并且可以通过跟踪文件读取。</p>
<p>使用 trace_printk() 写入环形缓冲区只需要大约十分之一微秒左右。但是使用 printk()，尤其是在写入串行控制台时，每次写入可能需要几毫秒。trace_printk() 的性能优势 使您可以记录内核中最敏感的区域，而几乎没有影响。</p>
<p>例如，您可以将这样的内容添加到内核或模块中：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace_printk(<span class="string">"read foo %d out of bar %p\n"</span>, bar-&gt;foo, bar);</span><br></pre></td></tr></tbody></table></figure>
<p>然后通过查看跟踪文件，您可以看到您的输出。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat trace</span></span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |          |         |</span></span><br><span class="line">           &lt;...&gt;-10690 [003] 17279.332920: : <span class="built_in">read</span> foo 10 out of bar ffff880013a5bef8</span><br></pre></td></tr></tbody></table></figure>
<p>上面的示例是通过添加一个实际上具有 foo 和 bar 构造的模块来完成的 。</p>
<p>trace_printk() 输出将出现在任何跟踪器中，甚至是函数和函数图跟踪器。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># insmod ~/modules/foo.ko</span></span><br><span class="line">[tracing]<span class="comment"># cat trace</span></span><br><span class="line"><span class="comment"># tracer: function_graph</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># CPU  DURATION                  FUNCTION CALLS</span></span><br><span class="line"><span class="comment"># |     |   |                     |   |   |   |</span></span><br><span class="line"> 3) + 16.283 us   |      }</span><br><span class="line"> 3) + 17.364 us   |    }</span><br><span class="line"> 3)               |    <span class="function"><span class="title">do_one_initcall</span></span>() {</span><br><span class="line"> 3)               |      /* <span class="built_in">read</span> foo 10 out of bar ffff88001191bef8 */</span><br><span class="line"> 3)   4.221 us    |    }</span><br><span class="line"> 3)               |    <span class="function"><span class="title">__wake_up</span></span>() {</span><br><span class="line"> 3)   0.633 us    |      _spin_lock_irqsave();</span><br><span class="line"> 3)   0.538 us    |      __wake_up_common();</span><br><span class="line"> 3)   0.563 us    |      _spin_unlock_irqrestore();</span><br></pre></td></tr></tbody></table></figure>
<p>是的，trace_printk() 输出看起来像函数图跟踪器中的注释。</p>
<h1 id="Starting-and-stopping-the-trace"><a href="#Starting-and-stopping-the-trace" class="headerlink" title="Starting and stopping the trace"></a>Starting and stopping the trace</h1><p>显然，有时您只想跟踪特定的代码路径。也许您只想跟踪运行特定测试时发生的情况。文件 tracing_on 用于禁止环形缓冲区记录数据：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; tracking_on</span></span><br></pre></td></tr></tbody></table></figure>
<p>这将禁用 Ftrace 环形缓冲区的记录。其他所有事情仍然发生在跟踪器上，它们仍然会产生大部分开销。他们确实注意到环形缓冲区没有记录，也不会尝试写入任何数据，但仍会执行跟踪器发出的调用。</p>
<p>要重新启用环形缓冲区，只需将“1”写入该文件：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 1 &gt;tracing_on</span></span><br></pre></td></tr></tbody></table></figure>
<p>请注意，在数字和大于号“ &gt; ”之间有一个空格非常重要。否则，您可能正在将标准输入或输出写入该文件。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0&gt;tracing_on /* 这行不通！*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>一个常见的运行可能是：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; tracing_on</span></span><br><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># echo 1 &gt; tracing_on; run_test; echo 0 &gt; tracing_on</span></span><br></pre></td></tr></tbody></table></figure>
<p>第一行禁止环形缓冲区记录任何数据。接下来启用函数图跟踪器。函数图跟踪器的开销仍然存在，但不会将任何内容记录到跟踪缓冲区中。最后一行启用环形缓冲区，运行测试程序，然后禁用环形缓冲区。这缩小了函数图跟踪器存储的数据范围，以仅包括 run_test 程序积累的数据 。</p>
<h1 id="Trace-Markers"><a href="#Trace-Markers" class="headerlink" title="Trace Markers"></a>Trace Markers</h1><p>查看内核内部发生的事情可以让用户更好地了解他们的系统是如何工作的。但有时需要在用户空间发生的事情和内核内部发生的事情之间进行协调。跟踪中显示的时间戳都与跟踪中发生的事情有关，但它们与墙时间不太对应。</p>
<p>为了帮助同步用户空间和内核空间中的操作，创建了 trace_marker 文件。它提供了一种从用户空间写入 Ftrace 环形缓冲区的方法。该标记随后将出现在轨迹中，以给出轨迹中特定事件发生的位置。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo hello world &gt; trace_marker</span></span><br><span class="line">[tracing]<span class="comment"># cat trace</span></span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |          |         |</span></span><br><span class="line">           &lt;...&gt;-3718  [001]  5546.183420: 0: hello world</span><br></pre></td></tr></tbody></table></figure>
<p>在&lt;…&gt;表示该写的标记任务的名字没有记录。未来的版本可能会解决这个问题。</p>
<h1 id="Starting-Stopping-and-Recording-in-a-Program"><a href="#Starting-Stopping-and-Recording-in-a-Program" class="headerlink" title="Starting, Stopping and Recording in a Program"></a>Starting, Stopping and Recording in a Program</h1><p>该 tracing_on 和 trace_marker 文件的工作很好地跟踪应用程序的活动，如果应用程序的源可用。如果应用程序中存在问题并且您需要找出应用程序特定位置的内核内部发生了什么，这两个文件就派上用场了。</p>
<p>在应用程序启动时，您可以打开这些文件以准备好文件描述符：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> trace_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> marker_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">{</span><br><span class="line"> <span class="type">char</span> *debugfs;</span><br><span class="line"> <span class="type">char</span> path[<span class="number">256</span>];</span><br><span class="line"> [...]</span><br><span class="line"></span><br><span class="line"> debugfs = find_debugfs();</span><br><span class="line"> <span class="keyword">if</span> (debugfs) {</span><br><span class="line">  <span class="built_in">strcpy</span>(path, debugfs);  <span class="comment">/* BEWARE buffer overflow */</span></span><br><span class="line">  <span class="built_in">strcat</span>(path,<span class="string">"/tracing/tracing_on"</span>);</span><br><span class="line">  trace_fd = open(path, O_WRONLY);</span><br><span class="line">  <span class="keyword">if</span> (trace_fd &gt;= <span class="number">0</span>)</span><br><span class="line">   write(trace_fd, <span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(path, debugfs);</span><br><span class="line">  <span class="built_in">strcat</span>(path,<span class="string">"/tracing/trace_marker"</span>);</span><br><span class="line">  marker_fd = open(path, O_WRONLY);</span><br></pre></td></tr></tbody></table></figure>
<p>然后，在代码中的某个关键位置，可以放置标记以显示应用程序当前所在的位置：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (marker_fd &gt;= <span class="number">0</span>)</span><br><span class="line"> write(marker_fd, <span class="string">"In critical area\n"</span>, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (critical_function() &lt; <span class="number">0</span>) {</span><br><span class="line"> <span class="comment">/* we failed! */</span></span><br><span class="line"> <span class="keyword">if</span> (trace_fd &gt;= <span class="number">0</span>)</span><br><span class="line">  write(trace_fd, <span class="string">"0"</span>, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在查看示例时，您首先会看到一个名为“find_debugfs()”的函数。挂载调试文件系统的正确位置是/sys/kernel/debug 但强大的工具不应依赖于挂载在那里的调试文件系统。find_debugfs() 的示例 位于此处。文件描述符被初始化为 -1 以允许此代码在启用和不启用跟踪的内核的情况下工作。</p>
<p>当检测到问题时，将 ASCII 字符“0”写入 trace_fd 文件描述符将停止跟踪。正如在第 1 部分中讨论的那样，这只会禁用记录到 Ftrace 环形缓冲区中，但跟踪器仍然会产生开销。</p>
<p>使用上面的初始化代码时，跟踪将在应用程序开始时启用，因为跟踪器以覆盖模式运行。也就是说，当跟踪缓冲区填满时，它将删除旧数据并用新数据替换它。由于在出现问题时只有最近的跟踪信息是相关的，因此在应用程序正常运行期间无需停止和启动跟踪。只有在检测到问题时才需要禁用跟踪器，以便跟踪记录导致错误的历史记录。如果应用程序中需要间隔跟踪，它可以将 ASCII“1”写入 trace_fd 以启用跟踪。</p>
<p>下面是一个名为 simple_trace.c 的简单程序示例， 它使用上述初始化过程：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">req.tv_sec = <span class="number">0</span>;</span><br><span class="line">req.tv_nsec = <span class="number">1000</span>;</span><br><span class="line">write(marker_fd, <span class="string">"before nano\n"</span>, <span class="number">12</span>);</span><br><span class="line">nanosleep(&amp;req, <span class="literal">NULL</span>);</span><br><span class="line">write(marker_fd, <span class="string">"after nano\n"</span>, <span class="number">11</span>);</span><br><span class="line">write(trace_fd, <span class="string">"0"</span>, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>（由于这是一个仅用于示例目的的简单程序，因此未添加错误检查。） 这是跟踪这个简单程序的过程：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; tracing_on</span></span><br><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># ~/simple_trace</span></span><br><span class="line">[tracing]<span class="comment"># cat trace</span></span><br></pre></td></tr></tbody></table></figure>
<p>第一行禁用跟踪，因为程序将在启动时启用它。接下来选择函数图跟踪器。程序被执行，结果如下。请注意，输出可能有点冗长，其中大部分内容已被删除并替换为 […]：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">  0)               |      <span class="function"><span class="title">__kmalloc</span></span>() {</span><br><span class="line">  0)   0.528 us    |        get_slab();</span><br><span class="line">  0)   2.271 us    |      }</span><br><span class="line">  0)               |      /* before nano */</span><br><span class="line">  0)               |      <span class="function"><span class="title">kfree</span></span>() {</span><br><span class="line">  0)   0.475 us    |        __phys_addr();</span><br><span class="line">  0)   2.062 us    |      }</span><br><span class="line">  0)   0.608 us    |      inotify_inode_queue_event();</span><br><span class="line">  0)   0.485 us    |      __fsnotify_parent();</span><br><span class="line"> [...]</span><br><span class="line">  1)   0.523 us    |          _spin_unlock();</span><br><span class="line">  0)   0.495 us    |    current_kernel_time();</span><br><span class="line">  1)               |          <span class="function"><span class="title">it_real_fn</span></span>() {</span><br><span class="line">  0)   1.602 us    |  }</span><br><span class="line">  1)   0.728 us    |            __rcu_read_lock();</span><br><span class="line">  0)               |  <span class="function"><span class="title">sys_nanosleep</span></span>() {</span><br><span class="line">  0)               |    <span class="function"><span class="title">hrtimer_nanosleep</span></span>() {</span><br><span class="line">  0)   0.526 us    |      hrtimer_init();</span><br><span class="line">  1)   0.418 us    |            __rcu_read_lock();</span><br><span class="line">  0)               |      <span class="function"><span class="title">do_nanosleep</span></span>() {</span><br><span class="line">  1)   1.114 us    |            _spin_lock_irqsave();</span><br><span class="line"> [...]</span><br><span class="line">  0)               |      <span class="function"><span class="title">__kmalloc</span></span>() {</span><br><span class="line">  1)   2.760 us    |  }</span><br><span class="line">  0)   0.556 us    |        get_slab();</span><br><span class="line">  1)               |  <span class="function"><span class="title">mwait_idle</span></span>() {</span><br><span class="line">  0)   1.851 us    |      }</span><br><span class="line">  0)               |      /* after nano */</span><br><span class="line">  0)               |      <span class="function"><span class="title">kfree</span></span>() {</span><br><span class="line">  0)   0.486 us    |        __phys_addr();</span><br></pre></td></tr></tbody></table></figure>
<p>请注意，对 trace_marker 的写入在函数图跟踪器中显示为注释。 这里的第一列代表 CPU。当我们像这样交错 CPU 跟踪时，可能很难读取跟踪。工具 grep 可以很容易地过滤它，或者可以使用 per_cpu 跟踪文件。 per_cpu 跟踪文件位于 per_cpu 下的 debugfs 跟踪目录中。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># ls per_cpu</span></span><br><span class="line">cpu0  cpu1  cpu2  cpu3  cpu4  cpu5  cpu6  cpu7</span><br></pre></td></tr></tbody></table></figure>
<p>在这些 CPU 目录中的每一个目录中都存在一个跟踪文件，仅显示该 CPU 的跟踪。 要在不受其他 CPU 干扰的情况下更好地了解函数图跟踪器，只需查看 per_cpu/cpu0/trace。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat per_cpu/cpu0/trace</span></span><br><span class="line"> 0)               |      <span class="function"><span class="title">__kmalloc</span></span>() {</span><br><span class="line"> 0)   0.528 us    |        get_slab();</span><br><span class="line"> 0)   2.271 us    |      }</span><br><span class="line"> 0)               |      /* before nano */</span><br><span class="line"> 0)               |      <span class="function"><span class="title">kfree</span></span>() {</span><br><span class="line"> 0)   0.475 us    |        __phys_addr();</span><br><span class="line"> 0)   2.062 us    |      }</span><br><span class="line"> 0)   0.608 us    |      inotify_inode_queue_event();</span><br><span class="line"> 0)   0.485 us    |      __fsnotify_parent();</span><br><span class="line"> 0)   0.488 us    |      inotify_dentry_parent_queue_event();</span><br><span class="line"> 0)   1.106 us    |      fsnotify();</span><br><span class="line">[...]</span><br><span class="line"> 0)   0.721 us    |    _spin_unlock_irqrestore();</span><br><span class="line"> 0)   3.380 us    |  }</span><br><span class="line"> 0)               |  <span class="function"><span class="title">audit_syscall_entry</span></span>() {</span><br><span class="line"> 0)   0.495 us    |    current_kernel_time();</span><br><span class="line"> 0)   1.602 us    |  }</span><br><span class="line"> 0)               |  <span class="function"><span class="title">sys_nanosleep</span></span>() {</span><br><span class="line"> 0)               |    <span class="function"><span class="title">hrtimer_nanosleep</span></span>() {</span><br><span class="line"> 0)   0.526 us    |      hrtimer_init();</span><br><span class="line"> 0)               |      <span class="function"><span class="title">do_nanosleep</span></span>() {</span><br><span class="line"> 0)               |        <span class="function"><span class="title">hrtimer_start_range_ns</span></span>() {</span><br><span class="line"> 0)               |          <span class="function"><span class="title">__hrtimer_start_range_ns</span></span>() {</span><br><span class="line"> 0)               |            <span class="function"><span class="title">lock_hrtimer_base</span></span>() {</span><br><span class="line"> 0)   0.866 us    |              _spin_lock_irqsave();</span><br><span class="line">[...]</span><br><span class="line"> 0)               |      <span class="function"><span class="title">__kmalloc</span></span>() {</span><br><span class="line"> 0)               |        <span class="function"><span class="title">get_slab</span></span>() {</span><br><span class="line"> 0)   1.851 us    |      }</span><br><span class="line"> 0)               |      /* after nano */</span><br><span class="line"> 0)               |      <span class="function"><span class="title">kfree</span></span>() {</span><br><span class="line"> 0)   0.486 us    |        __phys_addr();</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Disabling-the-Tracer-Within-the-Kernel"><a href="#Disabling-the-Tracer-Within-the-Kernel" class="headerlink" title="Disabling the Tracer Within the Kernel"></a>Disabling the Tracer Within the Kernel</h1><p>在内核驱动程序的开发过程中，可能会存在测试过程中出现的奇怪错误。也许驱动陷入睡眠状态，永远不会醒来。当内核事件发生时，试图从用户空间禁用跟踪器是很困难的，通常会导致缓冲区溢出和相关信息丢失，然后用户才能停止跟踪。</p>
<p>有两个在内核中运行良好的函数： tracing_on() 和 tracking_off()。这两个行为就像分别将“1”或“0” echo 到 tracing_on 文件中一样。如果内核中存在可以检查的某些条件，则可以通过添加如下内容来停止跟踪器：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test_for_error())</span><br><span class="line"> tracking_off();</span><br></pre></td></tr></tbody></table></figure>
<p>接下来，添加几个 trace_printk() s（参见第 1 部分），重新编译并引导内核。然后，您可以启用函数或函数图跟踪器，然后等待错误条件发生。检查 tracing_on 文件将让您知道错误条件何时发生。当内核调用 tracking_off() 时，它将从“1”切换到“0” 。</p>
<p>检查跟踪后，或将其保存在另一个文件中：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> trace &gt; ~/trace.sav</span><br></pre></td></tr></tbody></table></figure>
<p>您可以继续跟踪以检查另一个命中。为此，只需将“1” echo 到 tracing_on 中，跟踪将继续。如果可以合法触发触发 tracing_off() 调用的条件，这也很有用 。如果条件是由正常操作触发的，只需通过在 tracing_on 中 echo “1”来重新启动跟踪，希望下次遇到条件时将是因为异常。</p>
<h1 id="ftrace-dump-on-oops"><a href="#ftrace-dump-on-oops" class="headerlink" title="ftrace_dump_on_oops"></a>ftrace_dump_on_oops</h1><p>有时内核会崩溃，检查内存和崩溃状态更像是一门 CSI 科学，而不是程序调试科学。将 kdump / kexec 与 crash 实用程序一起使用是检查崩溃点系统状态的一种有价值的方法，但它不会让您看到在导致崩溃的事件之前发生了什么。</p>
<p>在内核引导参数中配置 Ftrace 并启用 ftrace_dump_on_oops，或者通过在/proc/sys/kernel/ftrace_dump_on_oops 中 echo “1” ，将使 Ftrace 能够在 oops 或 panic 时以 ASCII 格式将整个跟踪缓冲区转储到控制台。将控制台输出到串行日志使调试崩溃更容易。您现在可以追溯导致崩溃的事件。</p>
<p>转储到控制台可能需要很长时间，因为默认的 Ftrace 环形缓冲区每个 CPU 超过 1 兆字节。要缩小环形缓冲区的大小，请将希望环形缓冲区的千字节数写入 buffer_size_kb。请注意，该值是每个 CPU，而不是环形缓冲区的总大小。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 50 &gt; buffer_size_kb</span></span><br></pre></td></tr></tbody></table></figure>
<p>以上将把 Ftrace 环形缓冲区缩小到每个 CPU 50 KB。<br>您还可以使用 sysrq-z 将 Ftrace 缓冲区的转储触发到控制台 。</p>
<p>要为内核转储选择特定位置，内核可以直接调用 ftrace_dump()。请注意，这可能会永久禁用 Ftrace，可能需要重新启动才能再次启用它。这是因为 ftrace_dump() 读取缓冲区。缓冲区被写入所有上下文（中断、NMI、调度），但缓冲区的读取需要锁定。为了能够执行 ftrace_dump() 锁定被禁用并且缓冲区可能最终在输出后被破坏。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following code will lock up the box, so we dump out the</span></span><br><span class="line"><span class="comment"> * trace before we hit that location.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ftrace_dump();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* code that locks up */</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Stack-Tracing"><a href="#Stack-Tracing" class="headerlink" title="Stack Tracing"></a>Stack Tracing</h1><p>最后要讨论的主题是检查内核堆栈大小以及每个函数使用多少堆栈空间的能力。启用堆栈跟踪器 ( CONFIG_STACK_TRACER ) 将显示堆栈的最大使用发生在哪里。</p>
<p>堆栈跟踪器是从函数跟踪器基础结构构建的。它不使用 Ftrace 环形缓冲区，但确实使用函数跟踪器来挂钩每个函数调用。因为它使用函数跟踪器基础结构，所以在未启用时不会增加开销。要启用堆栈跟踪器，请将 1 echo 到 /proc/sys/kernel/stack_tracer_enabled 中。要查看启动期间的最大堆栈大小，请将“ stacktrace ”添加到内核​​启动参数。</p>
<p>堆栈跟踪器在每次函数调用时检查堆栈的大小。如果它大于最后记录的最大值，它会记录堆栈跟踪并使用新大小更新最大值。要查看当前最大值，请查看 stack_max_size 文件。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled</span></span><br><span class="line">[tracing]<span class="comment"># cat stack_max_size</span></span><br><span class="line">2928</span><br><span class="line">[tracing]<span class="comment"># cat stack_trace</span></span><br><span class="line">        Depth    Size   Location    (34 entries)</span><br><span class="line">        -----    ----   --------</span><br><span class="line">  0)     2952      16   mempool_alloc_slab+0x15/0x17</span><br><span class="line">  1)     2936     144   mempool_alloc+0x52/0x104</span><br><span class="line">  2)     2792      16   scsi_sg_alloc+0x4a/0x4c [scsi_mod]</span><br><span class="line">  3)     2776     112   __sg_alloc_table+0x62/0x103</span><br><span class="line">[...]</span><br><span class="line"> 13)     2072      48   __elv_add_request+0x98/0x9f</span><br><span class="line"> 14)     2024     112   __make_request+0x43e/0x4bb</span><br><span class="line"> 15)     1912     224   generic_make_request+0x424/0x471</span><br><span class="line"> 16)     1688      80   submit_bio+0x108/0x115</span><br><span class="line"> 17)     1608      48   submit_bh+0xfc/0x11e</span><br><span class="line"> 18)     1560     112   __block_write_full_page+0x1ee/0x2e8</span><br><span class="line"> 19)     1448      80   block_write_full_page_endio+0xff/0x10e</span><br><span class="line"> 20)     1368      16   block_write_full_page+0x15/0x17</span><br><span class="line"> 21)     1352      16   blkdev_writepage+0x18/0x1a</span><br><span class="line"> 22)     1336      32   __writepage+0x1a/0x40</span><br><span class="line"> 23)     1304     304   write_cache_pages+0x241/0x3c1</span><br><span class="line"> 24)     1000      16   generic_writepages+0x27/0x29</span><br><span class="line">[...]</span><br><span class="line"> 30)      424      64   bdi_writeback_task+0x3f/0xb0</span><br><span class="line"> 31)      360      48   bdi_start_fn+0x76/0xd7</span><br><span class="line"> 32)      312     128   kthread+0x7f/0x87</span><br><span class="line"> 33)      184     184   child_rip+0xa/0x20</span><br></pre></td></tr></tbody></table></figure>
<p>这不仅为您提供了找到的最大堆栈的大小，还显示了每个函数使用的堆栈大小的细分。请注意， write_cache_pages 的堆栈最大，使用了 304 个字节，其次是 generic_make_request，使用了 224 个字节的堆栈。</p>
<p>要重置最大值，请将“0”回显到 stack_max_size 文件中。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; stack_max_size</span></span><br></pre></td></tr></tbody></table></figure>
<p>保持运行一段时间将显示内核使用过多堆栈的位置。但请记住，堆栈跟踪器只有在未启用时才没有开销。当它运行时，您可能会注意到性能有所下降。</p>
<p>请注意，当内核使用单独的堆栈时，堆栈跟踪器不会跟踪最大堆栈大小。因为中断有自己的堆栈，它不会跟踪那里的堆栈使用情况。原因是当堆栈不是当前任务的堆栈时，目前没有简单的方法可以快速查看堆栈的顶部是什么。使用拆分堆栈时，进程堆栈可能是两页，而中断堆栈可能只有一页。这可能会在未来修复，但在使用堆栈跟踪器时请记住这一点。</p>
<h1 id="Function-filtering"><a href="#Function-filtering" class="headerlink" title="Function filtering"></a>Function filtering</h1><p>运行函数跟踪器可能会让人不知所措。数据量可能很大，人脑很难掌握。Ftrace 提供了一种方法来限制您看到的功能。存在两个文件，可让您限制跟踪的功能：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_ftrace_filter</span><br><span class="line">set_ftrace_notrace</span><br></pre></td></tr></tbody></table></figure>
<p>这些过滤功能取决于 CONFIG_DYNAMIC_FTRACE 选项。如前几篇文章所述，当启用此配置时，所有 mcount 调用者位置都将被存储，并在启动时转换为 NOP。这些位置被保存并用于在功能跟踪器被激活时启用跟踪。但这也有一个很好的副作用：并非所有功能都必须启用。上述文件将确定哪些功能被启用，哪些不启用。</p>
<p>当 set_ftrace_filter 中列出任何函数时，只会跟踪那些函数。当跟踪处于活动状态时，这将有助于系统的性能。跟踪每个函数会产生很大的开销，但是在使用 set_ftrace_filter 时，只有该文件中列出的那些函数才会更改 NOP 以调用跟踪器。根据正在跟踪的功能，仅启用几百个功能几乎不会引起注意。</p>
<p>该 set_ftrace_notrace 文件是相反 set_ftrace_filter。不是将跟踪限制为一组函数，而是不会跟踪 set_ftrace_notrace 中列出的函数。某些函数经常出现，跟踪这些函数不仅会减慢系统速度，还会填满跟踪缓冲区，并使分析您关心的函数变得更加困难。rcu_read_lock() 和 spin_lock() 等函数 属于这一类。</p>
<p>向这些文件添加函数的过程通常使用 bash 重定向。使用符号“&gt;”将删除文件中的所有现有函数并将正在回显的内容添加到文件中。使用“&gt;&gt;”附加到文件将保留现有功能并添加新功能。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo sys_read &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line">sys_read</span><br><span class="line">[tracing]<span class="comment"># echo sys_write &gt;&gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line">sys_write</span><br><span class="line">sys_read</span><br><span class="line">[tracing]<span class="comment"># echo sys_open &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line">sys_open</span><br></pre></td></tr></tbody></table></figure>
<p>要删除所有功能，只需在过滤器文件中回显一个空行即可。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo sys_read sys_open sys_write &gt; set_ftrace_notrace</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_notrace</span></span><br><span class="line">sys_open</span><br><span class="line">sys_write</span><br><span class="line">sys_read</span><br><span class="line">[tracing]<span class="comment"># echo &gt; set_ftrace_notrace</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_notrace</span></span><br><span class="line">[tracing]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure>
<p>这些文件中列出的函数也可以在内核命令行上设置。选项 ftrace_notrace 和 ftrace_filter 将通过列出逗号分隔的函数集来预设这些文件。</p>
<pre><code>ftrace_notrace=rcu_read_lock,rcu_read_unlock,spin_lock,spin_unlock
ftrace_filter=kfree,kmalloc,schedule,vmalloc_fault,spurious_fault
</code></pre><p>内核命令行添加的函数设置了相应过滤器文件中的内容。这些选项仅预加载文件，仍然可以使用如上所述的 bash 重定向来删除或添加功能。 set_ftrace_notrace 中列出的函数优先。也就是说，如果一个函数同时列在 set_ftrace_notrace 和 set_ftrace_filter 中，则不会跟踪该函数。</p>
<h1 id="Wildcard-filters"><a href="#Wildcard-filters" class="headerlink" title="Wildcard filters"></a>Wildcard filters</h1><p>可以添加到过滤器文件的函数列表显示在 available_filter_functions 文件中。这个函数列表源自前面提到的存储的 mcount 调用者列表。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat available_filter_functions | head -8</span></span><br><span class="line">_stext</span><br><span class="line">do_one_initcall</span><br><span class="line">run_init_process</span><br><span class="line">init_post</span><br><span class="line">name_to_dev_t</span><br><span class="line">create_dev</span><br><span class="line">T.627</span><br><span class="line">set_personality_64bit</span><br></pre></td></tr></tbody></table></figure>
<p>您可以 grep 此文件并将结果重定向到过滤器文件之一：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># grep sched available_filter_functions &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter | head -8</span></span><br><span class="line">save_stack_address_nosched</span><br><span class="line">mce_schedule_work</span><br><span class="line">smp_reschedule_interrupt</span><br><span class="line">native_smp_send_reschedule</span><br><span class="line">sys32_sched_rr_get_interval</span><br><span class="line">sched_avg_update</span><br><span class="line">proc_sched_set_task</span><br><span class="line">sys_sched_get_priority_max</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>不幸的是，向过滤文件添加大量函数很慢，您会注意到上面的 grep 需要几秒钟才能执行。这是因为写入过滤器文件的每个函数名称将被单独处理。上面的 grep 产生了 300 多个函数名。这 300 个名称中的每一个都将与内核中的每个函数名称进行比较（使用 strcmp()），这相当多。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># wc -l  available_filter_functions</span></span><br><span class="line">24331 available_filter_functions</span><br></pre></td></tr></tbody></table></figure>
<p>所以上面的 grep 导致 set_ftrace_filter 生成超过 300 * 24331 (7,299,300) 次比较！</p>
<p>幸运的是，这些文件也使用通配符；以下 glob 表达式是有效的：</p>
<p>value* - 选择所有以 value 开头的函数。<br>*value* - 选择所有包含文本 value 的函数。<br>*value - 选择所有以 value 结尾的函数。</p>
<p>内核包含一个相当简单的解析器，不会以预期的方式处理 value*value。它将忽略第二个 值并选择所有以 value 开头的函数，而不管它以什么结尾。传递给过滤器文件的通配符直接针对每个可用函数进行处理，这比在列表中传递单个函数要快得多。</p>
<p>因为 bash 也使用星号 (*)，所以最好用引号将输入括起来：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo set* &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line"><span class="comment">#### all functions enabled ####</span></span><br><span class="line">[tracing]<span class="comment"># echo 'set*' &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter | head -5</span></span><br><span class="line">set_personality_64bit</span><br><span class="line">set_intr_gate_ist</span><br><span class="line">set_intr_gate</span><br><span class="line">set_tsc_mode</span><br></pre></td></tr></tbody></table></figure>
<p>过滤器还可以通过在过滤器文件的输入中使用“mod”命令来仅选择属于特定模块的那些函数：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo ':mod:tg3' &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter |head -8</span></span><br><span class="line">tg3_write32</span><br><span class="line">tg3_read32</span><br><span class="line">tg3_write_flush_reg32</span><br><span class="line">tw32_mailbox_flush</span><br><span class="line">tg3_write32_tx_mbox</span><br><span class="line">tg3_read32_mbox_5906</span><br><span class="line">tg3_write32_mbox_5906</span><br><span class="line">tg3_disable_ints</span><br></pre></td></tr></tbody></table></figure>
<p>如果您正在调试单个模块，并且只想在跟踪中查看属于该模块的函数，这将非常有用。</p>
<p>在之前的文章中，启用和禁用记录到环形缓冲区是使用 tracing_on 文件以及 tracing_on() 和 tracing_off() 内核函数完成的。但是，如果您不想重新编译内核，并且想在特定函数处停止跟踪，则 set_ftrace_filter 有一个方法可以这样做。<br>使功能跟踪启用或禁用环形缓冲区的命令格式如下：</p>
<pre><code>function:command[:count]
</code></pre><p>这将在函数开始 时执行命令。该命令是 traceon 或 traceoff，并且可以添加一个可选的计数以使命令只执行给定的次数。如果计数被保留（包括前导冒号），则每次调用该函数时都会执行该命令。</p>
<p>不久前，我正在调试对内核所做的更改，该更改导致某些程序出现分段错误。我很难捕捉到跟踪，因为当我看到分段错误后能够停止跟踪时，数据已经被覆盖了。但是控制台上的回溯显示正在调用函数__bad_area_nosemaphore。然后我可以使用以下命令停止跟踪器：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo '__bad_area_nosemaphore:traceoff' &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line"><span class="comment">#### all functions enabled ####</span></span><br><span class="line">__bad_area_nosemaphore:traceoff:unlimited</span><br><span class="line">[tracing]<span class="comment"># echo function &gt; current_tracer</span></span><br></pre></td></tr></tbody></table></figure>
<p>请注意，带有命令的函数不会影响一般过滤器。即使已将命令添加到 <strong>bad_area_nosemaphore，过滤器仍允许跟踪所有函数。命令和过滤器功能是分开的，互不影响。将上述命令附加到函数 </strong>bad_area_nosemaphore 后，下次发生分段错误时，跟踪停止并包含调试情况所需的数据。</p>
<h1 id="Removing-functions-from-the-filters"><a href="#Removing-functions-from-the-filters" class="headerlink" title="Removing functions from the filters"></a>Removing functions from the filters</h1><p>如前所述，用“&gt;”回显将清除过滤器文件。但是如果您只想从过滤器中删除一些功能怎么办？</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter &gt; /tmp/filter</span></span><br><span class="line">[tracing]<span class="comment"># grep -v lock /tmp/filter &gt; set_ftrace_filter</span></span><br></pre></td></tr></tbody></table></figure>
<p>上述工作，但如前所述，如果 set_ftrace_filter 中已有多个函数，则可能需要一段时间才能完成。以下执行相同的操作，但速度要快得多：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo '!*lock*' &gt;&gt; set_ftrace_filter</span></span><br></pre></td></tr></tbody></table></figure>
<p>这 ‘！’符号将删除过滤器文件中列出的函数。如上所示，“！”与通配符一起使用，但也可以与单个函数一起使用。自从 ‘！’在 bash 中具有特殊含义，它必须用单引号括起来，否则 bash 将尝试执行其后的内容。另请注意使用了“&gt;&gt;”。如果您错误地使用了“&gt;”，则过滤器文件中将没有任何功能。 因为命令和过滤器不会相互干扰，清除 set_ftrace_filter 不会清除命令。命令必须用“！”清除象征。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 'sched*' &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># echo 'schedule:traceoff' &gt;&gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat trace | tail -5</span></span><br><span class="line">schedule_console_callback</span><br><span class="line">schedule_bh</span><br><span class="line">schedule_iso_resource</span><br><span class="line">schedule_reallocations</span><br><span class="line">schedule:traceoff:unlimited</span><br><span class="line">[tracing]<span class="comment"># echo &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line"><span class="comment">#### all functions enabled ####</span></span><br><span class="line">schedule:traceoff:unlimited</span><br><span class="line">[tracing]<span class="comment"># echo '!schedule:traceoff' &gt;&gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line"><span class="comment">#### all functions enabled ####</span></span><br><span class="line">[tracing]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure>
<p>这可能看起来很别扭，但是使用“&gt;”和“&gt;&gt;”只影响要跟踪的函数而不影响函数命令，实际上简化了过滤函数和添加和删除命令之间的控制。</p>
<h1 id="Tracing-a-specific-process"><a href="#Tracing-a-specific-process" class="headerlink" title="Tracing a specific process"></a>Tracing a specific process</h1><p>也许您只需要跟踪一个特定的进程或一组进程。文件 set_ftrace_pid 允许您指定要跟踪的特定进程。要仅跟踪当前线程，您可以执行以下操作：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo $$ &gt; set_ftrace_pid</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面将设置函数 tracer 只跟踪执行 echo 命令的 bash shell。如果要跟踪特定进程，可以创建一个 shell 脚本包装程序。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat ~/bin/ftrace-me</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">DEBUGFS=`grep debugfs /proc/mounts | awk <span class="string">'{ print $2; }'</span>`</span><br><span class="line"><span class="built_in">echo</span> $$ &gt; <span class="variable">$DEBUGFS</span>/tracing/set_ftrace_pid</span><br><span class="line"><span class="built_in">echo</span> <span class="keyword">function</span> &gt; <span class="variable">$DEBUGFS</span>/tracing/current_tracer</span><br><span class="line"><span class="built_in">exec</span> $*</span><br><span class="line">[tracing]<span class="comment"># ~/bin/ftrace-me ls -ltr</span></span><br></pre></td></tr></tbody></table></figure>
<p>请注意，如果要在执行上述操作后返回通用函数跟踪，则必须清除 set_ftrace_pid 文件。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo -1 &gt; set_ftrace_pid</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="What-calls-a-specific-function"><a href="#What-calls-a-specific-function" class="headerlink" title="What calls a specific function?"></a>What calls a specific function?</h1><p>有时了解什么在调用特定函数很有用。直接前任很有帮助，但整个回溯甚至更好。函数跟踪器包含一个选项，该选项将为跟踪器调用的每个函数在环形缓冲区中创建一个回溯。由于为每个函数创建回溯具有很大的开销，这可能会实时锁定系统，因此在使用此功能时必须小心。想象一下运行在 1000 HZ 的较慢系统上的定时器中断。很可能让定时器中断调用产生回溯的每个函数需要 1 毫秒才能完成。到定时器中断返回时，将在任何其他工作完成之前触发一个新的中断，从而导致活锁。</p>
<p>要使用函数跟踪器回溯功能，被调用的函数必须受到函数过滤器的限制。启用函数回溯的选项是函数跟踪器独有的，只有在启用函数跟踪器时才能激活它。这意味着您必须先启用函数跟踪器，然后才能访问该选项：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo kfree &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># cat set_ftrace_filter</span></span><br><span class="line">kfree</span><br><span class="line">[tracing]<span class="comment"># echo function &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># echo 1 &gt; options/func_stack_trace</span></span><br><span class="line">[tracing]<span class="comment"># cat trace | tail -8</span></span><br><span class="line"> =&gt; sys32_execve</span><br><span class="line"> =&gt; ia32_ptregs_common</span><br><span class="line">             cat-6829  [000] 1867248.965100: kfree &lt;-free_bprm</span><br><span class="line">             cat-6829  [000] 1867248.965100: &lt;stack trace&gt;</span><br><span class="line"></span><br><span class="line"> =&gt; free_bprm</span><br><span class="line"> =&gt; compat_do_execve</span><br><span class="line"> =&gt; sys32_execve</span><br><span class="line"> =&gt; ia32_ptregs_common</span><br><span class="line">[tracing]<span class="comment"># echo 0 &gt; options/func_stack_trace</span></span><br><span class="line">[tracing]<span class="comment"># echo &gt; set_ftrace_filter</span></span><br></pre></td></tr></tbody></table></figure>
<p>请注意，在启用 func_stack_trace 选项以确保启用过滤器之前，我小心地对 set_ftrace_filter 进行分类。最后，我在禁用过滤器之前禁用了 options/func_stack_trace。还要注意该选项是非易失性的，也就是说，即使您在 current_tracer 中启用了另一个跟踪器插件，如果您重新启用跟踪器功能，该选项仍然会启用。</p>
<h1 id="The-function-graph-tracer"><a href="#The-function-graph-tracer" class="headerlink" title="The function_graph tracer"></a>The function_graph tracer</h1><p>函数跟踪器非常强大，但可能很难理解它产生的线性格式。Frederic Weisbecker 已将函数跟踪器扩展到 function_graph 跟踪器。function_graph 跟踪器搭载了大部分由函数跟踪器创建的代码，但在 mcount 调用中添加了自己的钩子。因为它仍然使用 mcount 调用方法，所以上面解释的大部分函数过滤也适用于 function_graph 跟踪器，但 traceon / traceoff 命令和 set_ftrace_pid 除外（尽管后者将来可能会改变）。<br>function_graph tracer 在之前的文章中也有说明，但是 set_graph_function 文件没有说明。上一节中使用的 func_stack_trace 可以看到什么可能调用一个函数，但是 set_graph_function 可以用来查看一个函数调用了什么：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo kfree &gt; set_graph_function</span></span><br><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># cat trace</span></span><br><span class="line"><span class="comment"># tracer: function_graph</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># CPU  DURATION                  FUNCTION CALLS</span></span><br><span class="line"><span class="comment"># |     |   |                     |   |   |   |</span></span><br><span class="line"> 0)               |  <span class="function"><span class="title">kfree</span></span>() {</span><br><span class="line"> 0)               |    <span class="function"><span class="title">virt_to_cache</span></span>() {</span><br><span class="line"> 0)               |      <span class="function"><span class="title">virt_to_head_page</span></span>() {</span><br><span class="line"> 0)   0.955 us    |        __phys_addr();</span><br><span class="line"> 0)   2.643 us    |      }</span><br><span class="line"> 0)   4.299 us    |    }</span><br><span class="line"> 0)   0.855 us    |    __cache_free();</span><br><span class="line"> 0)   ==========&gt; |</span><br><span class="line"> 0)               |    <span class="function"><span class="title">smp_apic_timer_interrupt</span></span>() {</span><br><span class="line"> 0)               |      <span class="function"><span class="title">apic_write</span></span>() {</span><br><span class="line"> 0)   0.849 us    |        native_apic_mem_write();</span><br><span class="line"> 0)   2.853 us    |      }</span><br><span class="line">[tracing]<span class="comment"># echo &gt; set_graph_function</span></span><br></pre></td></tr></tbody></table></figure>
<p>这将显示仅由 kfree() 执行的调用图。“ ==========&gt; ”表示通话过程中发生了中断。跟踪记录 kfree() 块中的所有函数，甚至是那些在 kfree() 范围内触发的中断调用的函数。</p>
<p>function_graph 跟踪器显示函数在持续时间字段中花费的时间。在之前的文章中提到，只有叶子函数，即不调用其他函数的叶函数，才有准确的持续时间，因为父函数的持续时间还包括 function_graph 跟踪器调用子函数的开销。通过使用 set_ftrace_filter 文件，您可以强制任何函数成为 function_graph 跟踪器中的叶函数，这将允许您查看该函数的准确持续时间。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo smp_apic_timer_interrupt &gt; set_ftrace_filter</span></span><br><span class="line">[tracing]<span class="comment"># echo function_graph &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># cat trace | head</span></span><br><span class="line"><span class="comment"># tracer: function_graph</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># CPU  DURATION                  FUNCTION CALLS</span></span><br><span class="line"><span class="comment"># |     |   |                     |   |   |   |</span></span><br><span class="line"> 1)   ==========&gt; |</span><br><span class="line"> 1) + 16.433 us   |  smp_apic_timer_interrupt();</span><br><span class="line"> 1)   ==========&gt; |</span><br><span class="line"> 1) + 25.897 us   |  smp_apic_timer_interrupt();</span><br><span class="line"> 1)   ==========&gt; |</span><br><span class="line"> 1) + 24.764 us   |  smp_apic_timer_interrupt();</span><br></pre></td></tr></tbody></table></figure>
<p>上面显示定时器中断需要 16 到 26 微秒才能完成。</p>
<h1 id="Function-profiling"><a href="#Function-profiling" class="headerlink" title="Function profiling"></a>Function profiling</h1><p>oprofile 和 perf 是非常强大的分析工具，它们定期对系统进行采样，并可以显示大部分时间都花在了什么地方。使用函数分析器，可以很好地查看实际的函数执行情况，而不仅仅是示例。如果内核中配置了 CONFIG_FUNCTION_GRAPH_TRACER，则函数分析器将使用函数图基础结构来记录函数执行了多长时间。如果只配置了 CONFIG_FUNCTION_TRACER，函数分析器将只计算被调用的函数。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo nop &gt; current_tracer</span></span><br><span class="line">[tracing]<span class="comment"># echo 1 &gt; function_profile_enabled</span></span><br><span class="line">[tracing]<span class="comment"># cat trace_stat/function 0 |head</span></span><br><span class="line">  Function                               Hit    Time            Avg</span><br><span class="line">  --------                               ---    ----            ---</span><br><span class="line">  schedule                             22943    1994458706 us     86931.03 us</span><br><span class="line">  poll_schedule_timeout                 8683    1429165515 us     164593.5 us</span><br><span class="line">  schedule_hrtimeout_range              8638    1429155793 us     165449.8 us</span><br><span class="line">  sys_poll                             12366    875206110 us     70775.19 us</span><br><span class="line">  do_sys_poll                          12367    875136511 us     70763.84 us</span><br><span class="line">  compat_sys_select                     3395    527531945 us     155384.9 us</span><br><span class="line">  compat_core_sys_select                3395    527503300 us     155376.5 us</span><br><span class="line">  do_select                             3395    527477553 us     155368.9 us</span><br></pre></td></tr></tbody></table></figure>
<p>以上还包括函数被抢占或 schedule() 被调用以及任务被换出的次数。这可能看起来没用，但它确实可以让我们了解哪些函数经常被抢占。 Ftrace 还包括允许您让函数图跟踪器忽略任务计划时间的选项。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; options/sleep-time</span></span><br><span class="line">[tracing]<span class="comment"># echo 0 &gt; function_profile_enabled</span></span><br><span class="line">[tracing]<span class="comment"># echo 1 &gt; function_profile_enabled</span></span><br><span class="line">[tracing]<span class="comment"># cat trace_stat/function0  | head</span></span><br><span class="line">  Function                               Hit    Time            Avg</span><br><span class="line">  --------                               ---    ----            ---</span><br><span class="line">  default_idle                          2493    6763414 us     2712.962 us</span><br><span class="line">  native_safe_halt                      2492    6760641 us     2712.938 us</span><br><span class="line">  sys_poll                              4723    714243.6 us     151.226 us</span><br><span class="line">  do_sys_poll                           4723    692887.4 us     146.704 us</span><br><span class="line">  sys_read                              9211    460896.3 us     50.037 us</span><br><span class="line">  vfs_read                              9243    434521.2 us     47.010 us</span><br><span class="line">  smp_apic_timer_interrupt              3940    275747.4 us     69.986 us</span><br><span class="line">  sock_poll                            80613    268743.2 us     3.333 us</span><br></pre></td></tr></tbody></table></figure>
<p>请注意，sleep-time 选项包含“-”，而不是 sleep_time。</p>
<p>禁用功能分析器然后重新启用它会导致数字重置。该列表按平均时间排序，但使用脚本您可以轻松地按任何数字排序。所述 trace_stat / function0 仅表示存在一个 CPU 0 trace_stat /功能＃为系统上的每个 CPU。所有被追踪和命中的函数都在这个文件中。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># cat trace_stat/function0  | wc -l</span></span><br><span class="line">2978</span><br></pre></td></tr></tbody></table></figure>
<p>未命中的函数未列出。以上显示自我开始分析以来，已命中 2978 个函数。</p>
<p>影响分析的另一个选项是图形时间（再次使用“-”）。默认情况下它是启用的。启用后，函数的时间包括函数内调用的所有函数的时间。从上面示例的输出中可以看出，列出了几个系统调用的平均值最高。禁用时，次数只包括函数本身的执行次数，不包括从函数调用函数的次数：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[tracing]<span class="comment"># echo 0 &gt; options/graph-time</span></span><br><span class="line">[tracing]<span class="comment"># echo 0 &gt; function_profile_enabled</span></span><br><span class="line">[tracing]<span class="comment"># echo 1 &gt; function_profile_enabled</span></span><br><span class="line">[tracing]<span class="comment"># cat trace_stat/function0  | head</span></span><br><span class="line">  Function                               Hit    Time            Avg</span><br><span class="line">  --------                               ---    ----            ---</span><br><span class="line">  mwait_idle                           10132    246835458 us     24361.96 us</span><br><span class="line">  tg_shares_up                        154467    389883.5 us     2.524 us</span><br><span class="line">  _raw_spin_lock_irqsave              343012    263504.3 us     0.768 us</span><br><span class="line">  _raw_spin_unlock_irqrestore         351269    175205.6 us     0.498 us</span><br><span class="line">  walk_tg_tree                         14087    126078.4 us     8.949 us</span><br><span class="line">  __set_se_shares                     274937    88436.65 us     0.321 us</span><br><span class="line">  _raw_spin_lock                      100715    82692.61 us     0.821 us</span><br><span class="line">  kstat_irqs_cpu                      257500    80124.96 us     0.311 us</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>请注意，睡眠时间和图形时间也会影响 function_graph 跟踪器显示的持续时间。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>函数跟踪器非常强大，有很多不同的选项。它已经在主线 Linux 中可用，并且希望在大多数发行版中默认启用。它允许您深入了解内核及其功能库，让您很好地了解事情发生的原因。开始使用函数跟踪器打开我们称之为内核的黑​​匣子。玩得开心！</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《奔跑吧 Linux 内核》<br><a target="_blank" rel="noopener" href="https://lwn.net/Articles/365835/">https://lwn.net/Articles/365835/</a><br><a target="_blank" rel="noopener" href="https://lwn.net/Articles/366796/">https://lwn.net/Articles/366796/</a><br><a target="_blank" rel="noopener" href="https://lwn.net/Articles/370423/">https://lwn.net/Articles/370423/</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Debug/">Debug</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Kernel/">Kernel</a></div><div class="post_share"><div class="social-share" data-image="https://unsplash.it/1600/900?random&amp;7944" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/LinuxKernel/LinuxKernelDebugMem/" title="Linux 内核调试（二）内存检测"><img class="cover" src="https://unsplash.it/1600/900?random&amp;5599" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux 内核调试（二）内存检测</div></div></a></div><div class="next-post pull-right"><a href="/LinuxKernel/LinuxSyncRCU/" title="Linux 并发与同步（四）RCU"><img class="cover" src="https://unsplash.it/1600/900?random&amp;5451" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux 并发与同步（四）RCU</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/LinuxKernel/LinuxKernelDebugMem/" title="Linux 内核调试（二）内存检测"><img class="cover" src="https://unsplash.it/1600/900?random&5599" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-14</div><div class="title">Linux 内核调试（二）内存检测</div></div></a></div><div><a href="/LinuxKernel/LinuxKernelDebugVM/" title="Linux 内核调试（三）VM 参数调试"><img class="cover" src="https://unsplash.it/1600/900?random&4143" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-27</div><div class="title">Linux 内核调试（三）VM 参数调试</div></div></a></div><div><a href="/Debug/LinuxMemoryOptimization/" title="Linux 内存优化"><img class="cover" src="https://unsplash.it/1600/900?random&2923" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-01</div><div class="title">Linux 内存优化</div></div></a></div><div><a href="/Debug/LinuxPerf/" title="Linux 性能分析"><img class="cover" src="https://unsplash.it/1600/900?random&3236" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-01</div><div class="title">Linux 性能分析</div></div></a></div><div><a href="/Debug/LinuxSystemCropping/" title="Linux 系统裁剪"><img class="cover" src="https://unsplash.it/1600/900?random&2057" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-09</div><div class="title">Linux 系统裁剪</div></div></a></div><div><a href="/Debug/LinuxSystemStartOptimization/" title="Linux 启动优化"><img class="cover" src="https://unsplash.it/1600/900?random&860" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-19</div><div class="title">Linux 启动优化</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CarlyleLiu</div><div class="author-info__description">CarlyleLiu’s Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/carlyleliu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/carlyleliu" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yyliushuai@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://twitter.com/yyliushuai" target="_blank" title="Twitter"><i class="fab fa-twitter" style="color: #24292e;"></i></a><a class="social-icon" href="https://youtube.com/carlyleliu" target="_blank" title="YouTube"><i class="fab fa-youtube" style="color: #24292e;"></i></a><a class="social-icon" href="https://instagram.com/blurredliu" target="_blank" title="Instagram"><i class="fab fa-instagram" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">next主题站 https://carlyleliu.github.io/next</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">位置无关码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ftrace"><span class="toc-number">2.</span> <span class="toc-text">ftrace</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#irqs-%E8%B7%9F%E8%B8%AA%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">irqs 跟踪器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Function-tracing-no-modification-necessary"><span class="toc-number">4.</span> <span class="toc-text">Function tracing - no modification necessary</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Using-trace-printk"><span class="toc-number">5.</span> <span class="toc-text">Using trace_printk()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Starting-and-stopping-the-trace"><span class="toc-number">6.</span> <span class="toc-text">Starting and stopping the trace</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Trace-Markers"><span class="toc-number">7.</span> <span class="toc-text">Trace Markers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Starting-Stopping-and-Recording-in-a-Program"><span class="toc-number">8.</span> <span class="toc-text">Starting, Stopping and Recording in a Program</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Disabling-the-Tracer-Within-the-Kernel"><span class="toc-number">9.</span> <span class="toc-text">Disabling the Tracer Within the Kernel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ftrace-dump-on-oops"><span class="toc-number">10.</span> <span class="toc-text">ftrace_dump_on_oops</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stack-Tracing"><span class="toc-number">11.</span> <span class="toc-text">Stack Tracing</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Function-filtering"><span class="toc-number">12.</span> <span class="toc-text">Function filtering</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Wildcard-filters"><span class="toc-number">13.</span> <span class="toc-text">Wildcard filters</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Removing-functions-from-the-filters"><span class="toc-number">14.</span> <span class="toc-text">Removing functions from the filters</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tracing-a-specific-process"><span class="toc-number">15.</span> <span class="toc-text">Tracing a specific process</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#What-calls-a-specific-function"><span class="toc-number">16.</span> <span class="toc-text">What calls a specific function?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-function-graph-tracer"><span class="toc-number">17.</span> <span class="toc-text">The function_graph tracer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Function-profiling"><span class="toc-number">18.</span> <span class="toc-text">Function profiling</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">19.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">20.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By CarlyleLiu</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><!-- hexo injector body_end end --></body></html>